Phase 3.0: Mix Poker Platform - Master Specification Document
1. 開発ロードマップ (Detailed Development Roadmap)
プロジェクトを5つの主要フェーズに分割し、依存関係を整理した工程表です。

Phase 3-A: ルーム管理とステート基盤 (Current Priority)

目標: 複数の部屋（Open/Private）が存在し、ユーザーが着席・離席できる状態。

Room Manager (Server): メモリ内での部屋生成、削除、ID管理ロジック。

User Session (Server/Client): socket.id と username、stack の紐付け管理。

Lobby Integration: ロビー画面とサーバーの接続（部屋リストのリアルタイム更新）。

Seat Logic: 空席判定、着席処理、重複着席の防止。

Phase 3-B: ゲームループ・コアエンジン (The Engine)

目標: Texas Hold'em (NLH) が完全に動作し、チップが正しく移動する状態。

FSM (Finite State Machine): 状態遷移エンジン（Preflop → Flop → Turn → River → Showdown）。

Action Validation: 「今そのアクションが可能か（額は正しいか）」の判定ロジック。

Pot Logic: メインポット計算、オールイン時のサイドポット分割計算。

Showdown & Ranking: 役判定ライブラリの導入と勝者判定。

Phase 3-C: ミックスゲーム拡張 (The Mix)

目標: オマハ、ドロー、スタッドに対応し、ゲームローテーション機能が動く状態。

Variant Configuration: ゲームごとの「配布枚数」「ベット上限」「使用する役判定」の設定ファイル化。

Rotation Logic: ハンド数/周回数に基づくゲーム自動切り替えシステム。

Dealer Logic Expansion: スタッド用（ボタンなし）およびドロー用（交換）の処理追加。

Reshuffle Algorithm: パターンA/B/Cの実装。

Phase 3-D: 特殊ルール・サイドゲーム (Advanced Rules)

目標: ハウスルール、7-2ゲーム、スタンドアップゲームの実装。

Meta-Game Manager: ハンド外で進行するゲーム（Stand Up）の状態管理。

Special Rules: 8人TD時のUTG休み、BTN Anteの特殊徴収処理。

Notification UI: 「Next Game」演出、サイドゲームの勝敗演出。

2. データ構造・型定義設計書 (Data Structure Specifications)
サーバー・クライアント間で共有すべき「真実（Single Source of Truth）」の定義です。TypeScriptのインターフェースとして記述します。

2.1 Room & Table State (最重要)

TypeScript
// 部屋の状態定義
interface Room {
  id: string;             // 6桁の部屋ID
  hostId?: string;        // Private卓のホストSocketID (Open卓はnull)
  config: RoomConfig;     // 部屋の設定（ブラインド、許可ゲーム一覧など）
  
  // ゲーム進行状態
  gameState: {
    status: 'WAITING' | 'PLAYING' | 'PAUSED';
    gameVariant: string;  // 現在のゲーム (例: "PLO_OCEAN")
    street: number;       // 0:Pre, 1:Flop, 2:Turn, 3:River, 4:Showdown
    pot: PotState;
    board: string[];      // コミュニティカード
    deckStatus: {         // リシャッフル判定用
      stubCount: number;
      burnCount: number;
    };
  };

  // プレイヤー管理
  players: (Player | null)[]; // 長さMax6-8の配列 (nullは空席)
  dealerBtnIndex: number;     // ボタンの位置
  activePlayerIndex: number;  // 現在アクション待ちのプレイヤー
  
  // ローテーション管理
  rotation: {
    orbitCount: number;       // 現在の周回数
    gamesList: string[];      // ローテーション予定リスト
    currentGameIndex: number; // リストのどこにいるか
  };
  
  // サイドゲーム状態
  metaGame: {
    standUp: {
      isActive: boolean;
      remainingPlayers: string[]; // まだ勝っていないプレイヤーID
    };
    sevenDeuce: boolean;      // 有効かどうか
  };
}

// プレイヤー個人の状態
interface Player {
  socketId: string;
  name: string;
  stack: number;          // 持ちチップ量
  bet: number;            // 現在のストリートでのベット額
  totalBet: number;       // そのハンドでの総ベット額 (サイドポット計算用)
  
  status: 'ACTIVE' | 'FOLDED' | 'ALL_IN' | 'SIT_OUT';
  
  hand: string[] | null;  // サーバー内部のみ保持 (クライアントへは伏せて送る)
  
  // ゲーム固有情報
  drawDiscards?: number;  // ドローゲームで何枚交換したか
  studUpCards?: string[]; // スタッドの公開カード
}
3. アルゴリズム・ロジック詳細設計書 (Logic Specifications)
特に複雑なハウスルールの処理手順を定義します。

3.1 ゲームローテーション判定 (Rotation Logic)

トリガー: ハンド終了時（Showdown または WinByDefault 後） 入力: activePlayerCount, currentOrbit, buttonPosition

周回チェック:

今回ボタンが移動した結果、originalButtonPosition (ゲーム開始時のBTN位置) を通過したか？

Yesなら orbitCount++。

チェンジ条件判定:

Case A (Active <= 4): orbitCount >= 2 ならチェンジ。

Case B (Active >= 5): orbitCount >= 1 ならチェンジ。

実行処理:

条件を満たした場合:

orbitCount = 0 にリセット。

rotation.currentGameIndex を進める。

gameState.gameVariant を更新。

UI通知: NEXT_GAME_ANNOUNCEMENT イベントを送信（3秒待機）。

満たさない場合: そのまま次のハンドへ。

3.2 厳密なリシャッフル (Reshuffle Logic)

トリガー: dealCard() 実行時に stub が不足した場合。 オブジェクト:

Stub: 山札

Muck: 捨て札（Foldされたカード + 過去のStreetのBurn/Discard）

Burns: 各StreetでBurnされたカード（未使用）

Exposed: 場に出ているカード（Board + Player Hands）

処理フロー:

Check Pattern A:

Stub の枚数 > (必要な枚数 + 1枚(Burn)) か？

Yes → 通常通り Burn して Deal。

Check Pattern B:

Stub が足りないが、Burn カードを消費すれば足りるか？

※原則、デジタルではPattern Bは複雑すぎるためスキップし、Cへ移行することを推奨するが、仕様通り実装する場合：

Exposedされていない Burns を回収し、Stub に混ぜる（シャッフルなし、または簡易シャッフル）。

Execute Pattern C (Fallback):

Source: Muck 全て + 現在の Stub。

Exclude: Exposed (当然) および Current Burns (今のストリートのバーン)。

Action:

Source を全て混ぜて New Stub を生成。

シャッフルアルゴリズム (Fisher-Yates) を適用。

Burn を1枚行い、配布を再開。

3.3 スタッドゲームの仮想ディーラーとアクション順 (Stud Logic)

定義: スタッドには物理的なBTNはないが、アンテ徴収と配布開始位置のために「内部的なディーラーインデックス」を持つ。

配布順:

InternalDealerIndex の 左隣 (Index + 1) からカードを配る。

アクション順 (Bring-in / Betting):

各ストリート開始時に UpCards (公開札) を評価。

3rd Street: ランクが最も低い (Lo) プレイヤーが Bring-in 強制。タイの場合はスートランク (♠>♥>♦>♣) で決定（または座席順）。

4th Street以降: 役が最も高い (Hi) プレイヤーからアクション開始。

注意: Razzの場合は評価基準が逆転する（Aが最強/最弱の扱いに注意）。

4. API / イベントプロトコル設計 (Socket Events)
クライアント(C)とサーバー(S)の通信定義です。

接続・ロビー関連

C -> S join_room: { roomId: "ABC123", playerName: "User" }

S -> C room_joined: { roomState: Room } (成功時)

S -> C error: { message: "Room is full" }

ゲームアクション

C -> S player_action:

JSON
{
  "type": "BET" | "FOLD" | "CHECK" | "CALL",
  "amount": 100,
  "seqId": 45  // 同期ズレ防止ID
}
C -> S sit_down: { seatIndex: 2, buyIn: 1000 }

C -> S leave_seat: {}

サーバーからのブロードキャスト

S -> All game_state_update: { partialUpdate: ... } (差分更新推奨)

S -> All animation_event:

JSON
{
  "type": "DEAL_CARDS",
  "to": [0, 1, 2], // 座席インデックス
  "count": 2
}
※ステート更新とは別に、アニメーション発火用のイベントを分けることで、UIの演出制御が容易になる。




以下全体の進行目標
### 【Lv.2】 テキサスホールデム（もどき）の実装 (所要時間: 2〜3週間)

最も基本的なルールを作ります。まだ複雑なミックスゲームは考えません。

- **やること**:
    - **チップの概念**: 「コール」「フォールド」ボタンを作り、押すと数字が減るようにする。
    - **ターン進行**: Aさんがボタンを押すまで、Bさんは押せないように制御する。
    - **勝敗判定**: 最後に手札を見て、どちらが強いか判定する（AIにコードを書かせればOK）。
- **クリア条件**: 自分のPC内でブラウザを2つ開き、一人二役でチップを賭け合い、勝った方のチップが増えること。
- **工夫点**: データベースはまだ使いません。サーバーのメモリ（一時記憶）だけで動かします（再起動すると消えますが、開発中はそれで十分です）。

---

### 【Lv.3】 「着せ替え」システムの構築 (所要時間: 2週間)

ここで初めて、ミックスゲームに対応できる**「仕組み」**を作ります。これが一番の難関ですが、ここを乗り越えれば後は楽になります。

- **やること**:
    - プログラムを「ゲーム進行役」と「ルールブック」に分ける作業（リファクタリング）をします。
    - 「今はオマハの時間だよ」と設定を変えたら、配られる枚数が2枚から4枚に変わるように改造します。
- **クリア条件**: 設定ファイルを1行書き換えるだけで、ホールデムとオマハが切り替わるようになること。

---

### 【Lv.4】 こだわりの「ハウスルール」実装 (所要時間: 1ヶ月〜)

ここからが本番です。リストアップしていただいた特殊ルールを一つずつ追加していきます。

- **やること (優先度順)**:
    1. **Drawゲーム対応**: 「カードを捨てる・交換する」処理を追加（2-7 TDなど）。
    2. **Studゲーム対応**: 一部のカードを表向きにして配る処理を追加。
    3. **リシャッフル規則**: カードが足りなくなった時の「パターンC」などの処理を実装。
    4. **特殊ルール**: BTN Anteや、難波（端数チップ）の処理。
- **アドバイス**: 全部のゲームを一気に作ろうとせず、「今週は2-7 Triple Drawを作る！」と1つずつ攻略しましょう。

---

### 【Lv.5】 インターネット公開 (所要時間: 1〜2週間)

自分のパソコンから出して、友達がアクセスできるようにします。

- **やること**:
    - **クラウド契約**: 初心者はAWSよりも「Render.com」や「Railway」というサービスがおすすめです。設定が簡単で、最初は無料で使えます。
    - **データベース接続**: ユーザー登録や戦績を保存するために、ここで初めてデータベース（PostgreSQL）を繋ぎます。
- **クリア条件**: スマホの4G回線から、自分が作ったゲームのURLにアクセスして遊べること。