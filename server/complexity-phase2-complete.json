[{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/Dealer.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'collectBlinds' has a complexity of 14. Maximum allowed is 10.","line":198,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":198,"endColumn":18},{"ruleId":"complexity","severity":1,"message":"Method 'determineBringIn' has a complexity of 15. Maximum allowed is 10.","line":342,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":342,"endColumn":21},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 12. Maximum allowed is 10.","line":414,"column":63,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":414,"endColumn":65}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Phase 3-B: Dealer Class\n * ã‚«ãƒ¼ãƒ‰é…å¸ƒã€ãƒœã‚¿ãƒ³ç®¡ç†ã€ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å¾´åã‚’æ‹…å½“\n */\n\nimport type { Room, Player } from './types.js';\n\nexport class Dealer {\n    // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒƒã‚­ï¼ˆã‚¹ãƒ¼ãƒˆÃ—13ãƒ©ãƒ³ã‚¯ = 52æšï¼‰\n    private readonly SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];\n    private readonly RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];\n\n    /**\n     * 52æšã®ãƒ‡ãƒƒã‚­ã‚’ç”Ÿæˆã—ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«\n     */\n    createDeck(): string[] {\n        const deck: string[] = [];\n        for (const suit of this.SUITS) {\n            for (const rank of this.RANKS) {\n                deck.push(rank + suit);\n            }\n        }\n        return this.shuffle(deck);\n    }\n\n    /**\n     * Fisher-Yatesã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã‚·ãƒ£ãƒƒãƒ•ãƒ«\n     */\n    private shuffle(deck: string[]): string[] {\n        const shuffled = [...deck];\n        for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled;\n    }\n\n    /**\n     * ãƒ›ãƒ¼ãƒ«ã‚«ãƒ¼ãƒ‰ã‚’é…å¸ƒï¼ˆTexas Hold'em: 2æšï¼‰\n     * @param deck ãƒ‡ãƒƒã‚­ï¼ˆç ´å£Šçš„ã«ç·¨é›†ã•ã‚Œã‚‹ï¼‰\n     * @param players ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…åˆ—\n     * @param count å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é…ã‚‹æšæ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ2ï¼‰\n     */\n    dealHoleCards(deck: string[], players: (Player | null)[], count: number = 2): void {\n        const activePlayers = players.filter(p =>\n            p !== null && p.stack > 0 && p.status === 'ACTIVE'\n        ) as Player[];\n\n        // ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ­ãƒ“ãƒ³æ–¹å¼ã§é…å¸ƒ\n        for (let i = 0; i < count; i++) {\n            for (const player of activePlayers) {\n                if (deck.length === 0) {\n                    throw new Error('Deck is empty');\n                }\n                const card = deck.shift()!;\n                if (!player.hand) {\n                    player.hand = [];\n                }\n                player.hand.push(card);\n            }\n        }\n    }\n\n    /**\n     * ãƒ•ãƒ­ãƒƒãƒ—ã‚’é…å¸ƒï¼ˆãƒãƒ¼ãƒ³1æš + ãƒ•ãƒ­ãƒƒãƒ—3æšï¼‰\n     */\n    dealFlop(deck: string[]): string[] {\n        if (deck.length < 4) {\n            throw new Error('Not enough cards for flop');\n        }\n\n        deck.shift(); // ãƒãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰\n        return [deck.shift()!, deck.shift()!, deck.shift()!];\n    }\n\n    /**\n     * ã‚¿ãƒ¼ãƒ³ã‚’é…å¸ƒï¼ˆãƒãƒ¼ãƒ³1æš + ã‚¿ãƒ¼ãƒ³1æšï¼‰\n     */\n    dealTurn(deck: string[]): string {\n        if (deck.length < 2) {\n            throw new Error('Not enough cards for turn');\n        }\n\n        deck.shift(); // ãƒãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰\n        return deck.shift()!;\n    }\n\n    /**\n     * ãƒªãƒãƒ¼ã‚’é…å¸ƒï¼ˆãƒãƒ¼ãƒ³1æš + ãƒªãƒãƒ¼1æšï¼‰\n     */\n    dealRiver(deck: string[]): string {\n        if (deck.length < 2) {\n            throw new Error('Not enough cards for river');\n        }\n\n        deck.shift(); // ãƒãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰\n        return deck.shift()!;\n    }\n\n    /**\n     * æ±ç”¨ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰é…å¸ƒï¼ˆãƒãƒ¼ãƒ³1æš + æŒ‡å®šæšæ•°ï¼‰\n     * boardPatternã«åŸºã¥ããƒ‡ãƒ¼ã‚¿é§†å‹•ã®ã‚«ãƒ¼ãƒ‰é…å¸ƒ\n     */\n    dealBoardCards(deck: string[], count: number): string[] {\n        if (deck.length < count + 1) {\n            throw new Error(`Not enough cards: need ${count + 1}, have ${deck.length}`);\n        }\n\n        deck.shift(); // ãƒãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰\n        const cards: string[] = [];\n        for (let i = 0; i < count; i++) {\n            cards.push(deck.shift()!);\n        }\n        return cards;\n    }\n\n    /**\n     * ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ãƒœã‚¿ãƒ³ã‚’æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç§»å‹•\n     * @param room éƒ¨å±‹\n     * @returns æ–°ã—ã„ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     */\n    moveButton(room: Room): number {\n        const maxPlayers = room.config.maxPlayers;\n        let nextIndex = (room.dealerBtnIndex + 1) % maxPlayers;\n\n        // æ¬¡ã®æœ‰åŠ¹ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆç€å¸­ä¸­ï¼‰ã‚’æ¢ã™\n        let attempts = 0;\n        while (attempts < maxPlayers) {\n            const player = room.players[nextIndex];\n            if (player !== null && player.stack > 0) {\n                room.dealerBtnIndex = nextIndex;\n                return nextIndex;\n            }\n            nextIndex = (nextIndex + 1) % maxPlayers;\n            attempts++;\n        }\n\n        throw new Error('No active players to move button to');\n    }\n\n    /**\n     * æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n     * @param room éƒ¨å±‹\n     * @param currentIndex ç¾åœ¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     * @returns æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ-1ã®å ´åˆã¯å…¨å“¡å®Œäº†ï¼‰\n     */\n    getNextActivePlayer(room: Room, currentIndex: number): number {\n        const maxPlayers = room.config.maxPlayers;\n        let nextIndex = (currentIndex + 1) % maxPlayers;\n        let attempts = 0;\n\n        while (attempts < maxPlayers) {\n            const player = room.players[nextIndex];\n            if (\n                player !== null &&\n                player.status === 'ACTIVE' &&\n                player.stack > 0  // ã‚¹ã‚¿ãƒƒã‚¯ãŒã‚ã‚‹\n            ) {\n                return nextIndex;\n            }\n            nextIndex = (nextIndex + 1) % maxPlayers;\n            attempts++;\n        }\n\n        return -1; // å…¨å“¡ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†\n    }\n\n    /**\n     * æ¬¡ã®ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n     * @param includeWaitingForBB trueã®å ´åˆã€BBå¾…ã¡ã‚‚å¯¾è±¡ã«å«ã‚ã‚‹\n     */\n    getNextBlindPlayer(room: Room, currentIndex: number, includeWaitingForBB: boolean): number {\n        const maxPlayers = room.config.maxPlayers;\n        let nextIndex = (currentIndex + 1) % maxPlayers;\n        let attempts = 0;\n\n        while (attempts < maxPlayers) {\n            const player = room.players[nextIndex];\n            if (\n                player !== null &&\n                player.stack > 0 &&\n                (player.status === 'ACTIVE' || (includeWaitingForBB && player.waitingForBB))\n            ) {\n                return nextIndex;\n            }\n            nextIndex = (nextIndex + 1) % maxPlayers;\n            attempts++;\n        }\n\n        return -1;\n    }\n\n    /**\n     * ã‚¹ãƒ¢ãƒ¼ãƒ«ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ã¨ãƒ“ãƒƒã‚°ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ã‚’å¾´å\n     * @param room éƒ¨å±‹\n     * @returns {sbIndex, bbIndex} SBã¨BBã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     */\n    collectBlinds(room: Room): { sbIndex: number; bbIndex: number } {\n        const dealerIndex = room.dealerBtnIndex;\n        const maxPlayers = room.config.maxPlayers;\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’æ•°ãˆã‚‹\n        const activePlayers = room.players.filter(p =>\n            p !== null && p.stack > 0 && p.status === 'ACTIVE'\n        );\n\n        const blindEligible = room.players.filter(p =>\n            p !== null && p.stack > 0 && (p.status === 'ACTIVE' || p.waitingForBB)\n        );\n\n        if (blindEligible.length < 2) {\n            throw new Error('Need at least 2 players to collect blinds');\n        }\n\n        // ãƒ˜ãƒƒã‚ºã‚¢ãƒƒãƒ—ã®å ´åˆ: ãƒœã‚¿ãƒ³=SB, æ¬¡ãŒBB\n        // 3äººä»¥ä¸Šã®å ´åˆ: ãƒœã‚¿ãƒ³ã®æ¬¡=SB, ãã®æ¬¡=BB\n        let sbIndex: number;\n        let bbIndex: number;\n\n        if (activePlayers.length === 2) {\n            // ãƒ˜ãƒƒã‚ºã‚¢ãƒƒãƒ—\n            sbIndex = (room.players[dealerIndex]?.status === 'ACTIVE')\n                ? dealerIndex\n                : this.getNextActivePlayer(room, dealerIndex);\n            bbIndex = this.getNextBlindPlayer(room, sbIndex, true);\n        } else if (activePlayers.length < 2) {\n            sbIndex = (room.players[dealerIndex]?.status === 'ACTIVE')\n                ? dealerIndex\n                : this.getNextActivePlayer(room, dealerIndex);\n            if (sbIndex === -1) {\n                sbIndex = this.getNextBlindPlayer(room, dealerIndex, true);\n            }\n            bbIndex = this.getNextBlindPlayer(room, sbIndex, true);\n        } else {\n            // 3äººä»¥ä¸Š\n            sbIndex = this.getNextActivePlayer(room, dealerIndex);\n            bbIndex = this.getNextBlindPlayer(room, sbIndex, true);\n        }\n\n        // ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å¾´å\n        const sbPlayer = room.players[sbIndex];\n        const bbPlayer = room.players[bbIndex];\n\n        if (!sbPlayer || !bbPlayer) {\n            throw new Error('Blind positions not found');\n        }\n\n        const sb = room.config.smallBlind;\n        const bb = room.config.bigBlind;\n\n        // SBå¾´å\n        const sbAmount = Math.min(sbPlayer.stack, sb);\n        sbPlayer.stack -= sbAmount;\n        sbPlayer.bet = sbAmount;\n        sbPlayer.totalBet = sbAmount;\n        room.gameState.pot.main += sbAmount;\n\n        // BBå¾´å\n        const bbAmount = Math.min(bbPlayer.stack, bb);\n        bbPlayer.stack -= bbAmount;\n        bbPlayer.bet = bbAmount;\n        bbPlayer.totalBet = bbAmount;\n        room.gameState.pot.main += bbAmount;\n\n        // BBå¾…ã¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã“ã“ã§å‚åŠ æ‰±ã„ã«ã™ã‚‹\n        if (bbPlayer.waitingForBB) {\n            bbPlayer.waitingForBB = false;\n            bbPlayer.pendingJoin = false;\n            bbPlayer.status = 'ACTIVE';\n        }\n\n        // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ãƒã‚§ãƒƒã‚¯\n        if (sbPlayer.stack === 0) {\n            sbPlayer.status = 'ALL_IN';\n        }\n        if (bbPlayer.stack === 0) {\n            bbPlayer.status = 'ALL_IN';\n        }\n\n        console.log(`ğŸ’° Blinds collected: SB=${sbAmount} (seat ${sbIndex}), BB=${bbAmount} (seat ${bbIndex})`);\n\n        return { sbIndex, bbIndex };\n    }\n\n    /**\n     * ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’å–å¾—\n     */\n    getActivePlayerCount(room: Room): number {\n        return room.players.filter(p =>\n            p !== null &&\n            (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        ).length;\n    }\n\n    /**\n     * ãƒãƒ³ãƒ‰çµ‚äº†æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—\n     */\n    clearHands(room: Room): void {\n        for (const player of room.players) {\n            if (player) {\n                player.hand = null;\n                player.bet = 0;\n                player.totalBet = 0;\n                if (player.status === 'FOLDED') {\n                    player.status = 'ACTIVE';\n                }\n            }\n        }\n        room.gameState.board = [];\n        room.gameState.pot = { main: 0, side: [] };\n    }\n\n    /**\n     * ã‚«ãƒ¼ãƒ‰ã®ãƒ©ãƒ³ã‚¯å€¤ã‚’å–å¾—ï¼ˆBring-Inåˆ¤å®šç”¨ï¼‰\n     */\n    private getCardRankValue(card: string): number {\n        const rank = card[0];\n        const values: { [key: string]: number } = {\n            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10,\n            'J': 11, 'Q': 12, 'K': 13, 'A': 14\n        };\n        return values[rank] || 0;\n    }\n\n    /**\n     * ã‚«ãƒ¼ãƒ‰ã®ã‚¹ãƒ¼ãƒˆå€¤ã‚’å–å¾—ï¼ˆã‚¿ã‚¤ãƒ–ãƒ¬ãƒ¼ã‚¯ç”¨: â™£ < â™¦ < â™¥ < â™ ï¼‰\n     */\n    private getCardSuitValue(card: string): number {\n        const suit = card[1];\n        const values: { [key: string]: number } = {\n            'â™£': 1, 'â™¦': 2, 'â™¥': 3, 'â™ ': 4\n        };\n        return values[suit] || 0;\n    }\n\n    /**\n     * Stud Bring-Inåˆ¤å®š: æœ€ã‚‚å¼±ã„ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã‚’æŒã¤ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™\n     * @param players ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…åˆ—\n     * @param isRazz Razzã®å ´åˆã¯æœ€ã‚‚å¼·ã„ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰\n     * @returns ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     */\n    determineBringIn(players: (Player | null)[], isRazz: boolean = false): number {\n        let bringInIndex = -1;\n        let targetRank = isRazz ? 0 : 15; // Razz: é«˜ã„æ–¹ã€é€šå¸¸: ä½ã„æ–¹\n        let targetSuit = isRazz ? 0 : 5;\n\n        for (let i = 0; i < players.length; i++) {\n            const player = players[i];\n            if (!player || !player.studUpCards || player.studUpCards.length === 0) continue;\n\n            const upCard = player.studUpCards[0]; // 3rd Streetã®æœ€åˆã®ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰\n            const rank = this.getCardRankValue(upCard);\n            const suit = this.getCardSuitValue(upCard);\n\n            if (isRazz) {\n                // Razz: æœ€ã‚‚é«˜ã„ã‚«ãƒ¼ãƒ‰ï¼ˆå¼·ã„ï¼æ‚ªã„ï¼‰ãŒBring-In\n                if (rank > targetRank || (rank === targetRank && suit > targetSuit)) {\n                    targetRank = rank;\n                    targetSuit = suit;\n                    bringInIndex = i;\n                }\n            } else {\n                // é€šå¸¸Stud: æœ€ã‚‚ä½ã„ã‚«ãƒ¼ãƒ‰ãŒBring-In\n                if (rank < targetRank || (rank === targetRank && suit < targetSuit)) {\n                    targetRank = rank;\n                    targetSuit = suit;\n                    bringInIndex = i;\n                }\n            }\n        }\n\n        return bringInIndex;\n    }\n\n    /**\n     * Bring-Inã‚’å¾´å\n     * @param room éƒ¨å±‹\n     * @param bringInIndex Bring-Inãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     * @param bringInAmount Bring-Iné¡ï¼ˆé€šå¸¸ã¯SBã®åŠåˆ†ç¨‹åº¦ï¼‰\n     */\n    collectBringIn(room: Room, bringInIndex: number, bringInAmount: number): void {\n        const player = room.players[bringInIndex];\n        if (!player) return;\n\n        const amount = Math.min(player.stack, bringInAmount);\n        player.stack -= amount;\n        player.bet = amount;\n        player.totalBet = amount;\n        room.gameState.pot.main += amount;\n        room.gameState.currentBet = amount;\n\n        if (player.stack === 0) {\n            player.status = 'ALL_IN';\n        }\n\n        console.log(`ğŸ’° Bring-In: ${player.name} posts ${amount}`);\n    }\n\n    /**\n     * Studã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é–‹å§‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ±ºå®š\n     * - é€šå¸¸: æœ€ã‚‚å¼·ã„ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼\n     * - Razz: æœ€ã‚‚å¼±ã„ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼\n     * ã‚¿ã‚¤ã¯ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ã®å·¦ã‹ã‚‰é †ã«å„ªå…ˆ\n     */\n    getStudActionStartIndex(room: Room, isRazz: boolean = false): number {\n        const candidates = room.players\n            .map((player, index) => ({ player, index }))\n            .filter(p => p.player !== null && p.player.status === 'ACTIVE' && (p.player.studUpCards?.length || 0) > 0);\n\n        if (candidates.length === 0) {\n            return this.getNextActivePlayer(room, -1);\n        }\n\n        const compareUpCards = (a: Player, b: Player): number => {\n            const aRanks = (a.studUpCards || []).map(card => this.getCardRankValue(card));\n            const bRanks = (b.studUpCards || []).map(card => this.getCardRankValue(card));\n\n            aRanks.sort((x, y) => isRazz ? x - y : y - x);\n            bRanks.sort((x, y) => isRazz ? x - y : y - x);\n\n            const maxLen = Math.max(aRanks.length, bRanks.length);\n            for (let i = 0; i < maxLen; i++) {\n                const av = aRanks[i] ?? (isRazz ? 99 : 0);\n                const bv = bRanks[i] ?? (isRazz ? 99 : 0);\n                if (av === bv) continue;\n                return isRazz ? (av < bv ? 1 : -1) : (av > bv ? 1 : -1);\n            }\n            return 0;\n        };\n\n        let best = candidates[0];\n        let tied: number[] = [best.index];\n\n        for (const candidate of candidates.slice(1)) {\n            const result = compareUpCards(candidate.player!, best.player!);\n            if (result > 0) {\n                best = candidate;\n                tied = [candidate.index];\n            } else if (result === 0) {\n                tied.push(candidate.index);\n            }\n        }\n\n        if (tied.length === 1) {\n            return tied[0];\n        }\n\n        const maxPlayers = room.config.maxPlayers;\n        let idx = (room.dealerBtnIndex + 1) % maxPlayers;\n        for (let i = 0; i < maxPlayers; i++) {\n            if (tied.includes(idx)) {\n                return idx;\n            }\n            idx = (idx + 1) % maxPlayers;\n        }\n\n        return tied[0];\n    }\n\n    /**\n     * ã‚¹ã‚¿ãƒƒãƒ‰ç”¨ã‚«ãƒ¼ãƒ‰é…å¸ƒï¼ˆ3rd Street: 2 down + 1 upï¼‰\n     */\n    dealStudInitial(deck: string[], players: (Player | null)[]): void {\n        const activePlayers = players.filter(p =>\n            p !== null && p.stack > 0 && p.status === 'ACTIVE'\n        ) as Player[];\n\n        // 2æšãƒ€ã‚¦ãƒ³ã‚«ãƒ¼ãƒ‰\n        for (let i = 0; i < 2; i++) {\n            for (const player of activePlayers) {\n                if (deck.length === 0) throw new Error('Deck is empty');\n                const card = deck.shift()!;\n                if (!player.hand) player.hand = [];\n                player.hand.push(card);\n            }\n        }\n\n        // 1æšã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰\n        for (const player of activePlayers) {\n            if (deck.length === 0) throw new Error('Deck is empty');\n            const card = deck.shift()!;\n            player.hand!.push(card);\n            // ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã¯studUpCardsã«è¨˜éŒ²\n            if (!player.studUpCards) player.studUpCards = [];\n            player.studUpCards.push(card);\n        }\n\n        console.log('ğŸ´ Dealt Stud 3rd Street: 2 down + 1 up');\n    }\n\n    /**\n     * ã‚¹ã‚¿ãƒƒãƒ‰ç”¨è¿½åŠ ã‚«ãƒ¼ãƒ‰é…å¸ƒï¼ˆ4th-6th Street: up cardsï¼‰\n     */\n    dealStudStreet(deck: string[], players: (Player | null)[], isLastStreet: boolean = false): void {\n        const activePlayers = players.filter(p =>\n            p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        ) as Player[];\n\n        for (const player of activePlayers) {\n            if (deck.length === 0) throw new Error('Deck is empty');\n            const card = deck.shift()!;\n            player.hand!.push(card);\n\n            // 7th Streetã¯ãƒ€ã‚¦ãƒ³ã‚«ãƒ¼ãƒ‰ã€ãã‚Œä»¥å¤–ã¯ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰\n            if (!isLastStreet) {\n                if (!player.studUpCards) player.studUpCards = [];\n                player.studUpCards.push(card);\n            }\n        }\n\n        console.log(`ğŸ´ Dealt Stud street: ${isLastStreet ? 'down card' : 'up card'}`);\n    }\n\n    /**\n     * ãƒ‰ãƒ­ãƒ¼äº¤æ›å‡¦ç†\n     * @param deck ãƒ‡ãƒƒã‚­\n     * @param player ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼\n     * @param discardIndexes æ¨ã¦ã‚‹ã‚«ãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—\n     */\n    exchangeDrawCards(deck: string[], player: Player, discardIndexes: number[]): void {\n        if (!player.hand) return;\n\n        const discardCount = discardIndexes.length;\n        if (deck.length < discardCount) {\n            throw new Error('Not enough cards for draw exchange');\n        }\n\n        // Sort indexes in descending order to avoid index shift issues\n        const sortedIndexes = [...discardIndexes].sort((a, b) => b - a);\n\n        // Remove discarded cards\n        for (const idx of sortedIndexes) {\n            if (idx >= 0 && idx < player.hand.length) {\n                player.hand.splice(idx, 1);\n            }\n        }\n\n        // Deal new cards\n        for (let i = 0; i < discardCount; i++) {\n            const card = deck.shift()!;\n            player.hand.push(card);\n        }\n\n        console.log(`ğŸ”„ ${player.name} exchanged ${discardCount} cards`);\n    }\n\n    /**\n     * ãƒªã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆPattern C: é«˜åº¦ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰\n     * ãƒ‡ãƒƒã‚­ãŒä¸è¶³ã—ãŸå ´åˆã€ãƒ‡ã‚£ã‚¹ã‚«ãƒ¼ãƒ‰ãƒ‘ã‚¤ãƒ«ã¨ã‚¹ã‚¿ãƒ–ã‚’åˆã‚ã›ã¦ãƒªã‚·ãƒ£ãƒƒãƒ•ãƒ«\n     */\n    reshuffleIfNeeded(deck: string[], discardPile: string[], requiredCards: number): string[] {\n        if (deck.length >= requiredCards) {\n            return deck; // ååˆ†ãªã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹\n        }\n\n        console.log(`âš ï¸ Deck low (${deck.length} cards), need ${requiredCards}. Reshuffling...`);\n\n        // ã‚¹ã‚¿ãƒ–ã¨ãƒ‡ã‚£ã‚¹ã‚«ãƒ¼ãƒ‰ã‚’åˆã‚ã›ã‚‹\n        const combined = [...deck, ...discardPile];\n        const reshuffled = this.shuffle(combined);\n\n        console.log(`âœ… Reshuffled ${combined.length} cards`);\n\n        // ãƒ‡ã‚£ã‚¹ã‚«ãƒ¼ãƒ‰ãƒ‘ã‚¤ãƒ«ã‚’ã‚¯ãƒªã‚¢\n        discardPile.length = 0;\n\n        return reshuffled;\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/GameEngine.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'startHand' has too many lines (123). Maximum allowed is 100.","line":28,"column":5,"nodeType":"MethodDefinition","messageId":"exceed","endLine":150,"endColumn":6},{"ruleId":"complexity","severity":1,"message":"Method 'startHand' has a complexity of 21. Maximum allowed is 10.","line":28,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":28,"endColumn":14},{"ruleId":"complexity","severity":1,"message":"Method 'processBetOrRaise' has a complexity of 14. Maximum allowed is 10.","line":224,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":224,"endColumn":30},{"ruleId":"complexity","severity":1,"message":"Method 'advanceAction' has a complexity of 15. Maximum allowed is 10.","line":313,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":313,"endColumn":26},{"ruleId":"complexity","severity":1,"message":"Method 'nextStreet' has a complexity of 12. Maximum allowed is 10.","line":413,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":413,"endColumn":15},{"ruleId":"complexity","severity":1,"message":"Method 'getValidActions' has a complexity of 11. Maximum allowed is 10.","line":701,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":701,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Phase 3-B: Game Engine\n * FSMï¼ˆçŠ¶æ…‹é·ç§»ãƒã‚·ãƒ³ï¼‰ã¨ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’ç®¡ç†\n * Phase 3-C: ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œã‚’è¿½åŠ \n */\n\nimport type { Room, Player, GamePhase, ActionType, PlayerAction } from './types.js';\nimport { Dealer } from './Dealer.js';\nimport { RotationManager } from './RotationManager.js';\nimport { getVariantConfig } from './gameVariants.js';\n\nexport class GameEngine {\n    private dealer: Dealer;\n    private rotationManager: RotationManager;\n    private deck: string[] = [];\n    private actionTimeout: number = 30000; // 30ç§’\n\n    constructor() {\n        this.dealer = new Dealer();\n        this.rotationManager = new RotationManager();\n    }\n\n    /**\n     * ãƒãƒ³ãƒ‰ã‚’é–‹å§‹\n     * @param room éƒ¨å±‹\n     * @returns æˆåŠŸæ™‚true\n     */\n    startHand(room: Room): boolean {\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’ãƒã‚§ãƒƒã‚¯\n        const activePlayers = this.getSeatedPlayers(room);\n        if (activePlayers.length < 2) {\n            console.log('âš ï¸ Need at least 2 players to start hand');\n            return false;\n        }\n\n        console.log(`\\nğŸ´ Starting new hand #${room.gameState.handNumber + 1}`);\n\n        // ãƒãƒ³ãƒ‰ç•ªå·ã‚’å¢—åŠ \n        room.gameState.handNumber = (room.gameState.handNumber || 0) + 1;\n\n        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ\n        for (const player of room.players) {\n            if (!player || player.stack <= 0) continue;\n\n            if (player.pendingSitOut) {\n                player.status = 'SIT_OUT';\n                player.pendingSitOut = false;\n                player.pendingJoin = false;\n                player.waitingForBB = false;\n            } else if (player.disconnected) {\n                player.status = 'SIT_OUT';\n            } else if (player.status === 'SIT_OUT') {\n                if (player.pendingJoin && !player.waitingForBB) {\n                    player.status = 'ACTIVE';\n                    player.pendingJoin = false;\n                }\n            } else {\n                player.status = 'ACTIVE';\n            }\n\n            player.hand = null;\n            player.bet = 0;\n            player.totalBet = 0;\n            if (player.studUpCards) player.studUpCards = [];\n        }\n\n        // ãƒãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ\n        room.gameState.pot = { main: 0, side: [] };\n        room.gameState.board = [];\n        room.gameState.currentBet = 0;\n        room.gameState.minRaise = room.config.bigBlind;\n        room.gameState.raisesThisRound = 0; // ãƒ¬ã‚¤ã‚ºã‚«ã‚¦ãƒ³ã‚¿ãƒªã‚»ãƒƒãƒˆ\n\n        // æœ€å¾Œã®ã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ\n        room.lastAggressorIndex = -1;\n\n        // ãƒ‡ãƒƒã‚­ã‚’ä½œæˆ\n        this.deck = this.dealer.createDeck();\n\n        // ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆå–å¾—\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        // ãƒœã‚¿ãƒ³ã‚’ç§»å‹•ï¼ˆãƒœã‚¿ãƒ³ã‚ã‚Šã‚²ãƒ¼ãƒ ã®ã¿ï¼‰\n        if (variantConfig.hasButton) {\n            this.dealer.moveButton(room);\n        }\n\n        // ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å¾´åï¼ˆãƒœã‚¿ãƒ³ã‚ã‚Šã‚²ãƒ¼ãƒ ã®ã¿ã€Studã¯ã‚¢ãƒ³ãƒ†ã‚£ï¼‰\n        let sbIndex = -1;\n        let bbIndex = -1;\n        if (variantConfig.hasButton) {\n            const blinds = this.dealer.collectBlinds(room);\n            sbIndex = blinds.sbIndex;\n            bbIndex = blinds.bbIndex;\n            room.gameState.currentBet = room.config.bigBlind;\n        }\n\n        // ãƒãƒªã‚¢ãƒ³ãƒˆã«å¿œã˜ãŸã‚«ãƒ¼ãƒ‰é…å¸ƒ\n        let bringInIndex = -1;\n        if (variantConfig.communityCardType === 'stud') {\n            // Stud: 3rd Street (2 down + 1 up)\n            this.dealer.dealStudInitial(this.deck, room.players);\n            room.gameState.status = 'THIRD_STREET' as any;\n            room.gameState.street = 0;\n\n            // Bring-Inåˆ¤å®šï¼ˆRazzã¯æœ€ã‚‚å¼·ã„ã‚«ãƒ¼ãƒ‰ãŒBring-Inï¼‰\n            const isRazz = room.gameState.gameVariant === 'RAZZ';\n            bringInIndex = this.dealer.determineBringIn(room.players, isRazz);\n\n            if (bringInIndex !== -1) {\n                // Bring-Iné¡: è¨­å®šå€¤ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°BB/5ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ\n                const bringInAmount = room.config.studAnte ?? Math.max(1, Math.floor(room.config.bigBlind / 5));\n                this.dealer.collectBringIn(room, bringInIndex, bringInAmount);\n                // Completeé¡ = Small Bet (BBé¡)\n                // 3rd-4th Street: Small Bet = BB\n                // 5th+ Street: Big Bet = 2*BB (getFixedBetSizeã§å‡¦ç†)\n                room.gameState.minRaise = room.config.bigBlind;\n                room.gameState.currentBet = bringInAmount;\n            }\n        } else if (variantConfig.hasDrawPhase) {\n            // Draw: 5æšé…å¸ƒï¼ˆBadugiã¯4æšï¼‰\n            this.dealer.dealHoleCards(this.deck, room.players, variantConfig.holeCardCount);\n            room.gameState.status = 'PREDRAW' as any;\n            room.gameState.street = 0;\n        } else {\n            // Flop games (NLH, PLO): ãƒ›ãƒ¼ãƒ«ã‚«ãƒ¼ãƒ‰é…å¸ƒ\n            this.dealer.dealHoleCards(this.deck, room.players, variantConfig.holeCardCount);\n            room.gameState.status = 'PREFLOP' as any;\n            room.gameState.street = 0;\n        }\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨­å®š\n        if (variantConfig.hasButton && bbIndex !== -1) {\n            // ãƒœã‚¿ãƒ³ã‚ã‚Šã‚²ãƒ¼ãƒ : BBã®æ¬¡ã‹ã‚‰\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, bbIndex);\n        } else if (bringInIndex !== -1) {\n            // Stud: Bring-Inã®æ¬¡ã‹ã‚‰ï¼ˆæ™‚è¨ˆå›ã‚Šï¼‰\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, bringInIndex);\n        } else {\n            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åº§å¸­0ã‹ã‚‰\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, -1);\n        }\n\n        // ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã®é–‹å§‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨˜éŒ²\n        room.streetStarterIndex = room.activePlayerIndex;\n\n        console.log(`âœ… Hand started. Active player: seat ${room.activePlayerIndex}`);\n\n        return true;\n    }\n\n    /**\n     * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‡¦ç†\n     * @param room éƒ¨å±‹\n     * @param action ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n     * @returns å‡¦ç†çµæœ\n     */\n    processAction(room: Room, action: PlayerAction): { success: boolean; error?: string } {\n        const player = room.players.find(p => p?.socketId === action.playerId);\n\n        if (!player) {\n            return { success: false, error: 'Player not found' };\n        }\n\n        if (room.players[room.activePlayerIndex]?.socketId !== action.playerId) {\n            return { success: false, error: 'Not your turn' };\n        }\n\n        console.log(`ğŸ¯ ${player.name} -> ${action.type}${action.amount ? ` ${action.amount}` : ''}`);\n\n        const actionError = this.applyAction(room, player, action);\n        if (actionError) {\n            return { success: false, error: actionError };\n        }\n\n        // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç§»å‹•\n        this.advanceAction(room);\n\n        return { success: true };\n    }\n\n    private applyAction(room: Room, player: RoomPlayer, action: PlayerAction): string | null {\n        switch (action.type) {\n            case 'FOLD':\n                return this.processFold(player);\n            case 'CHECK':\n                return this.processCheck(room, player);\n            case 'CALL':\n                return this.processCall(room, player);\n            case 'BET':\n            case 'RAISE':\n                return this.processBetOrRaise(room, player, action);\n            case 'ALL_IN':\n                return this.processAllIn(room, player);\n            default:\n                return 'Invalid action';\n        }\n    }\n\n    private processFold(player: RoomPlayer): string | null {\n        player.status = 'FOLDED';\n        return null;\n    }\n\n    private processCheck(room: Room, player: RoomPlayer): string | null {\n        if (player.bet < room.gameState.currentBet) {\n            return 'Cannot check, must call or raise';\n        }\n        return null;\n    }\n\n    private processCall(room: Room, player: RoomPlayer): string | null {\n        const callAmount = Math.min(room.gameState.currentBet - player.bet, player.stack);\n        player.stack -= callAmount;\n        player.bet += callAmount;\n        player.totalBet += callAmount;\n        room.gameState.pot.main += callAmount;\n        if (player.stack === 0) {\n            player.status = 'ALL_IN';\n        }\n        return null;\n    }\n\n    private processBetOrRaise(room: Room, player: RoomPlayer, action: PlayerAction): string | null {\n        const betAmount = action.amount || 0;\n        if (!Number.isFinite(betAmount) || betAmount <= 0) {\n            return 'Invalid bet amount';\n        }\n        const variantConfigBet = getVariantConfig(room.gameState.gameVariant);\n        const isAllInBet = betAmount >= player.stack;\n\n        if (variantConfigBet.betStructure === 'fixed') {\n            const capLimit = this.getCapLimit(room);\n            if (room.gameState.raisesThisRound >= capLimit) {\n                return 'Betting is capped';\n            }\n        }\n\n        const minTotal = this.getMinBetTo(room, player);\n        const totalBet = player.bet + betAmount;\n\n        if (totalBet < minTotal && !isAllInBet) {\n            return `Minimum raise is ${minTotal}`;\n        }\n        if (betAmount > player.stack) {\n            return 'Not enough chips';\n        }\n\n        if (variantConfigBet.betStructure === 'pot-limit') {\n            const maxPotBet = this.calculatePotLimitMax(room, player);\n            if (totalBet > maxPotBet) {\n                return `Maximum bet is ${maxPotBet} (pot limit)`;\n            }\n        }\n\n        const raiseSize = totalBet - room.gameState.currentBet;\n        const reopensAction = raiseSize >= room.gameState.minRaise;\n\n        player.stack -= betAmount;\n        player.bet = totalBet;\n        player.totalBet += betAmount;\n        room.gameState.pot.main += betAmount;\n        room.gameState.currentBet = totalBet;\n\n        if (reopensAction) {\n            room.gameState.minRaise = raiseSize;\n            room.streetStarterIndex = room.activePlayerIndex;\n            if (variantConfigBet.betStructure === 'fixed') {\n                room.gameState.raisesThisRound++;\n            }\n        }\n\n        room.lastAggressorIndex = room.activePlayerIndex;\n\n        if (player.stack === 0) {\n            player.status = 'ALL_IN';\n        }\n        return null;\n    }\n\n    private processAllIn(room: Room, player: RoomPlayer): string | null {\n        const allInAmount = player.stack;\n        const newTotal = player.bet + allInAmount;\n        const raiseSizeAllIn = newTotal - room.gameState.currentBet;\n        const reopensAllIn = raiseSizeAllIn >= room.gameState.minRaise;\n\n        player.bet = newTotal;\n        player.totalBet += allInAmount;\n        player.stack = 0;\n        player.status = 'ALL_IN';\n        room.gameState.pot.main += allInAmount;\n\n        if (newTotal > room.gameState.currentBet) {\n            room.gameState.currentBet = newTotal;\n            if (reopensAllIn) {\n                room.gameState.minRaise = raiseSizeAllIn;\n                room.streetStarterIndex = room.activePlayerIndex;\n            }\n            room.lastAggressorIndex = room.activePlayerIndex;\n            const variantConfig = getVariantConfig(room.gameState.gameVariant);\n            if (variantConfig.betStructure === 'fixed' && reopensAllIn) {\n                room.gameState.raisesThisRound++;\n            } else if (variantConfig.betStructure !== 'fixed') {\n                room.gameState.raisesThisRound++;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é€²ã‚€ã€ã¾ãŸã¯ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’é€²ã‚ã‚‹\n     */\n    private advanceAction(room: Room): void {\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆFOLDED/ALL_INä»¥å¤–ï¼‰ã‚’å–å¾—\n        const actionablePlayers = room.players.filter(p =>\n            p !== null && p.status === 'ACTIVE'\n        );\n\n        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ALL INãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n        const allInPlayers = room.players.filter(p =>\n            p !== null && p.status === 'ALL_IN'\n        );\n\n        const remainingPlayers = room.players.filter(p =>\n            p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        );\n\n        // 1äººä»¥ä¸‹ãªã‚‰çµ‚äº†\n        if (remainingPlayers.length <= 1) {\n            this.endHand(room);\n            return;\n        }\n\n        // å…¨å“¡ALL INã®å ´åˆã€è‡ªå‹•çš„ã«ãƒªãƒãƒ¼ã¾ã§é€²ã‚ã¦ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³\n        if (actionablePlayers.length === 0 && allInPlayers.length >= 2) {\n            console.log('ğŸ’¥ All players ALL IN - auto-dealing to showdown');\n            // ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆæƒ…å ±ã‚’è¨˜éŒ²ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤ºã«ä½¿ç”¨ï¼‰\n            room.gameState.isRunout = true;\n            room.gameState.runoutPhase = room.gameState.status;\n            this.dealToShowdown(room);\n            this.endHand(room);\n            return;\n        }\n\n        // 1äººã ã‘ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ä»–ãŒALL-INã®å ´åˆã€ãã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚³ãƒ¼ãƒ«ã—ãŸã‚‰ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆ\n        // (ç›¸æ‰‹ãŒã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ã§ã‚·ãƒ§ãƒ¼ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã®å ´åˆãªã©)\n        if (actionablePlayers.length === 1 && allInPlayers.length >= 1) {\n            const activePlayer = actionablePlayers[0]!;\n            // å…¨å“¡ã®ãƒ™ãƒƒãƒˆãŒæƒã£ã¦ã„ã‚‹å ´åˆã€ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆã¸\n            const allBetsMatched = activePlayer.bet >= room.gameState.currentBet;\n            if (allBetsMatched) {\n                console.log('ğŸ’¥ One active player matched all-in bet - running out');\n                room.gameState.isRunout = true;\n                room.gameState.runoutPhase = room.gameState.status;\n                this.dealToShowdown(room);\n                this.endHand(room);\n                return;\n            }\n        }\n\n        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ0äººã®å ´åˆï¼ˆå…¨å“¡ALL_INã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ï¼‰\n        // æ®‹ã‚Šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ1äººä»¥ä¸‹ãªã‚‰çµ‚äº†ï¼ˆå‹è€…ç¢ºå®šï¼‰\n        if (actionablePlayers.length === 0) {\n            // 1äººã®ALL_INãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã¯ãã®ã¾ã¾çµ‚äº†\n            this.endHand(room);\n            return;\n        }\n\n        // å…¨å“¡ã®ãƒ™ãƒƒãƒˆãŒæƒã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\n        const allBetsEqual = actionablePlayers.every(p =>\n            p!.bet === room.gameState.currentBet || p!.stack === 0\n        );\n\n        // æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™\n        const nextIndex = this.dealer.getNextActivePlayer(room, room.activePlayerIndex);\n\n        // streetStarterãŒã¾ã ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ãƒã‚§ãƒƒã‚¯\n        const streetStarter = room.players[room.streetStarterIndex];\n        const streetStarterIsActive = streetStarter?.status === 'ACTIVE';\n\n        // ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†åˆ¤å®š\n        let roundComplete = false;\n\n        if (allBetsEqual) {\n            if (streetStarterIsActive) {\n                // é€šå¸¸ã‚±ãƒ¼ã‚¹: streetStarterã«æˆ»ã£ãŸã‚‰å®Œäº†\n                roundComplete = nextIndex === room.streetStarterIndex;\n            } else {\n                // streetStarterãŒALL_INã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã®å ´åˆ\n                // å…¨å“¡ã®ãƒ™ãƒƒãƒˆãŒæƒã£ã¦ã„ã‚Œã°ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒä¸€å‘¨ã—ãŸã¨ã¿ãªã™\n                // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨åŒã˜ï¼ˆ1äººã ã‘ï¼‰ã‹ã€-1ãªã‚‰å®Œäº†\n                roundComplete = nextIndex === -1 ||\n                    nextIndex === room.activePlayerIndex ||\n                    actionablePlayers.length === 1;\n            }\n        }\n\n        if (roundComplete) {\n            // æ¬¡ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã¸\n            this.nextStreet(room);\n        } else if (nextIndex === -1) {\n            // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„\n            this.endHand(room);\n        } else {\n            // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸\n            room.activePlayerIndex = nextIndex;\n        }\n    }\n\n    /**\n     * æ¬¡ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã«é€²ã‚€\n     */\n    nextStreet(room: Room): void {\n        // ãƒ™ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ\n        for (const player of room.players) {\n            if (player) {\n                player.bet = 0;\n            }\n        }\n        room.gameState.currentBet = 0;\n        room.gameState.raisesThisRound = 0; // ãƒ¬ã‚¤ã‚ºã‚«ã‚¦ãƒ³ã‚¿ãƒªã‚»ãƒƒãƒˆ\n\n        const phase = room.gameState.status;\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        // ã‚²ãƒ¼ãƒ ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œ\n        if (variantConfig.communityCardType === 'stud') {\n            this.nextStudStreet(room, phase);\n        } else if (variantConfig.hasDrawPhase) {\n            this.nextDrawStreet(room, phase);\n        } else {\n            this.nextFlopStreet(room, phase);\n        }\n\n        // ã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œå¾Œã€å†åº¦ALL INãƒã‚§ãƒƒã‚¯\n        const actionablePlayers = room.players.filter(p =>\n            p !== null && p.status === 'ACTIVE'\n        );\n\n        const allInPlayers = room.players.filter(p =>\n            p !== null && p.status === 'ALL_IN'\n        );\n\n        // SHOWDOWNã«åˆ°é”ã—ãŸå ´åˆã¯ãƒªã‚¿ãƒ¼ãƒ³\n        if (room.gameState.status === 'SHOWDOWN') {\n            return;\n        }\n\n        room.gameState.minRaise = variantConfig.betStructure === 'fixed'\n            ? this.getFixedBetSize(room)\n            : room.config.bigBlind;\n\n        // å…¨å“¡ALL INãªã‚‰è‡ªå‹•çš„ã«æ¬¡ã¸é€²ã‚€\n        if (actionablePlayers.length === 0 && allInPlayers.length >= 2) {\n            console.log('ğŸ’¥ All players still ALL IN - continuing auto-deal');\n            this.nextStreet(room);\n            return;\n        }\n\n        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ1äººã§ã€ç›¸æ‰‹ãŒå…¨å“¡ALL-INã®å ´åˆ\n        // ãã®1äººã¯èª°ã«ã‚‚å¯¾æŠ—ã§ããªã„ã®ã§ã€ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆã§æ®‹ã‚Šã®ã‚«ãƒ¼ãƒ‰ã‚’é…ã‚‹\n        if (actionablePlayers.length === 1 && allInPlayers.length >= 1) {\n            console.log('ğŸ’¥ Only one active player vs all-in - running out');\n            // ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆæƒ…å ±ã‚’è¨˜éŒ²ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤ºã«ä½¿ç”¨ï¼‰\n            room.gameState.isRunout = true;\n            room.gameState.runoutPhase = room.gameState.status;\n            this.dealToShowdown(room);\n            this.endHand(room);\n            return;\n        }\n\n        // ãƒœã‚¿ãƒ³ã®æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰é–‹å§‹ï¼ˆStudã¯åˆ¥ãƒ­ã‚¸ãƒƒã‚¯ï¼‰\n        if (variantConfig.hasButton) {\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, room.dealerBtnIndex);\n        } else {\n            // Stud: æœ€å¼·/æœ€å¼±ã®ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã‚’æŒã¤ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰\n            const isRazz = room.gameState.gameVariant === 'RAZZ';\n            room.activePlayerIndex = this.dealer.getStudActionStartIndex(room, isRazz);\n        }\n        // æ–°ã—ã„ã‚¹ãƒˆãƒªãƒ¼ãƒˆã®é–‹å§‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨˜éŒ²\n        room.streetStarterIndex = room.activePlayerIndex;\n    }\n\n    /**\n     * Flopç³»ã‚²ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œï¼ˆãƒ‡ãƒ¼ã‚¿é§†å‹•ï¼‰\n     * boardPatternã«åŸºã¥ã„ã¦ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ã‚’é…å¸ƒ\n     */\n    private nextFlopStreet(room: Room, phase: any): void {\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n        const boardPattern = variantConfig.boardPattern || [3, 1, 1];\n        // ãƒ•ã‚§ãƒ¼ã‚ºåã®é…åˆ—ï¼ˆstreet indexã«å¯¾å¿œï¼‰\n        const FLOP_PHASES = ['PREFLOP', 'FLOP', 'TURN', 'RIVER', 'OCEAN'];\n\n        const currentStreet = room.gameState.street;\n        const nextStreet = currentStreet + 1;\n\n        // å…¨ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ãŒé…å¸ƒæ¸ˆã¿ â†’ ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³\n        if (nextStreet > boardPattern.length) {\n            room.gameState.status = 'SHOWDOWN' as any;\n            room.gameState.street = nextStreet;\n            this.endHand(room);\n            return;\n        }\n\n        // æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã«é€²è¡Œ\n        const nextPhase = FLOP_PHASES[nextStreet] || 'SHOWDOWN';\n        room.gameState.status = nextPhase as any;\n        room.gameState.street = nextStreet;\n\n        // ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ã‚’é…å¸ƒ\n        const cardCount = boardPattern[nextStreet - 1]; // boardPattern[0]=flop, [1]=turn, [2]=river, [3]=ocean\n        const newCards = this.dealer.dealBoardCards(this.deck, cardCount);\n        room.gameState.board.push(...newCards);\n\n        console.log(`ğŸƒ ${nextPhase}: ${newCards.join(' ')} (board: ${room.gameState.board.join(' ')})`);\n    }\n\n    /**\n     * Studç³»ã‚²ãƒ¼ãƒ ï¼ˆ7CS, RAZZï¼‰ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œ\n     */\n    private nextStudStreet(room: Room, phase: any): void {\n        switch (phase) {\n            case 'PREFLOP': // ä¾¿å®œä¸ŠPREFLOPã¨ã—ã¦é–‹å§‹\n            case 'THIRD_STREET':\n                room.gameState.status = 'FOURTH_STREET' as any;\n                this.dealer.dealStudStreet(this.deck, room.players, false);\n                room.gameState.street = 1;\n                console.log(`ğŸ´ 4th Street dealt`);\n                break;\n\n            case 'FOURTH_STREET':\n                room.gameState.status = 'FIFTH_STREET' as any;\n                this.dealer.dealStudStreet(this.deck, room.players, false);\n                room.gameState.street = 2;\n                console.log(`ğŸ´ 5th Street dealt`);\n                break;\n\n            case 'FIFTH_STREET':\n                room.gameState.status = 'SIXTH_STREET' as any;\n                this.dealer.dealStudStreet(this.deck, room.players, false);\n                room.gameState.street = 3;\n                console.log(`ğŸ´ 6th Street dealt`);\n                break;\n\n            case 'SIXTH_STREET':\n                room.gameState.status = 'SEVENTH_STREET' as any;\n                this.dealer.dealStudStreet(this.deck, room.players, true); // æœ€å¾Œã¯ãƒ€ã‚¦ãƒ³ã‚«ãƒ¼ãƒ‰\n                room.gameState.street = 4;\n                console.log(`ğŸ´ 7th Street dealt (down card)`);\n                break;\n\n            case 'SEVENTH_STREET':\n                room.gameState.status = 'SHOWDOWN' as any;\n                room.gameState.street = 5;\n                this.endHand(room);\n                break;\n        }\n    }\n\n    /**\n     * Drawç³»ã‚²ãƒ¼ãƒ ï¼ˆ2-7 TD, Badugiï¼‰ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œ\n     * ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°å®Œäº†å¾Œã€ãƒ‰ãƒ­ãƒ¼äº¤æ›ãƒ•ã‚§ãƒ¼ã‚ºã«å…¥ã‚‹\n     */\n    private nextDrawStreet(room: Room, phase: any): void {\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n        const drawRounds = variantConfig.drawRounds || 3; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ãƒˆãƒªãƒ—ãƒ«ãƒ‰ãƒ­ãƒ¼\n        const DRAW_PHASES = ['PREDRAW', 'FIRST_DRAW', 'SECOND_DRAW', 'THIRD_DRAW'];\n\n        const currentStreet = room.gameState.street;\n        // PREFLOP/PREDRAWã¯street 0\n        const nextStreet = (phase === 'PREFLOP' || phase === 'PREDRAW') ? 1 : currentStreet + 1;\n\n        if (nextStreet > drawRounds) {\n            // å…¨ãƒ‰ãƒ­ãƒ¼ãƒ©ã‚¦ãƒ³ãƒ‰å®Œäº† â†’ ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³\n            room.gameState.status = 'SHOWDOWN' as any;\n            room.gameState.street = nextStreet;\n            room.gameState.isDrawPhase = false;\n            this.endHand(room);\n            return;\n        }\n\n        // æ¬¡ã®ãƒ‰ãƒ­ãƒ¼äº¤æ›ãƒ•ã‚§ãƒ¼ã‚ºã¸\n        const nextPhase = DRAW_PHASES[nextStreet];\n        room.gameState.status = nextPhase as any;\n        room.gameState.street = nextStreet;\n        room.gameState.isDrawPhase = true;\n        room.gameState.playersCompletedDraw = [];\n        this.autoCompleteAllInDraws(room);\n        console.log(`ğŸ”„ ${nextPhase} exchange phase - waiting for players to draw`);\n    }\n\n    /**\n     * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ‰ãƒ­ãƒ¼äº¤æ›ã‚’å®Œäº†ã—ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹\n     * å…¨å“¡å®Œäº†ã—ãŸã‚‰ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºã«ç§»è¡Œ\n     */\n    checkDrawPhaseComplete(room: Room): boolean {\n        if (!room.gameState.isDrawPhase) return false;\n\n        // FOLDEDä»¥å¤–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n        const activePlayers = room.players.filter(p =>\n            p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        );\n\n        const completedDraw = room.gameState.playersCompletedDraw || [];\n\n        // å…¨å“¡å®Œäº†ã—ãŸã‹ãƒã‚§ãƒƒã‚¯\n        const allCompleted = activePlayers.every(p =>\n            completedDraw.includes(p!.socketId)\n        );\n\n        if (allCompleted) {\n            // ãƒ‰ãƒ­ãƒ¼äº¤æ›å®Œäº† â†’ ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºã¸\n            room.gameState.isDrawPhase = false;\n            room.gameState.playersCompletedDraw = [];\n\n            // ãƒ™ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ\n            for (const player of room.players) {\n                if (player) {\n                    player.bet = 0;\n                }\n            }\n            room.gameState.currentBet = 0;\n            const variantConfig = getVariantConfig(room.gameState.gameVariant);\n            room.gameState.minRaise = variantConfig.betStructure === 'fixed'\n                ? this.getFixedBetSize(room)\n                : room.config.bigBlind;\n            room.gameState.raisesThisRound = 0;\n\n            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨­å®šï¼ˆãƒœã‚¿ãƒ³ã®æ¬¡ã‹ã‚‰ï¼‰\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, room.dealerBtnIndex);\n            room.streetStarterIndex = room.activePlayerIndex;\n\n            console.log(`âœ… Draw exchange complete - starting betting round`);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹æ™‚ã«ALL_INãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è‡ªå‹•çš„ã«å®Œäº†ã¨ã—ã¦ãƒãƒ¼ã‚¯\n     * ï¼ˆALL_INãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã‚«ãƒ¼ãƒ‰ã‚’äº¤æ›ã§ããªã„ãŸã‚ã€0æšäº¤æ›ã¨ã—ã¦æ‰±ã†ï¼‰\n     */\n    autoCompleteAllInDraws(room: Room): void {\n        if (!room.gameState.isDrawPhase) return;\n\n        const allInPlayers = room.players.filter(p =>\n            p !== null && p.status === 'ALL_IN'\n        );\n\n        for (const player of allInPlayers) {\n            if (player) {\n                this.markDrawComplete(room, player.socketId);\n                player.drawDiscards = 0; // ã‚¹ã‚¿ãƒ³ãƒ‰ãƒ‘ãƒƒãƒˆ\n                console.log(`ğŸ”„ ${player.name} auto-stands pat (ALL_IN)`);\n            }\n        }\n    }\n\n    /**\n     * ãƒ‰ãƒ­ãƒ¼äº¤æ›ã‚’å®Œäº†ã¨ã—ã¦ãƒãƒ¼ã‚¯\n     */\n    markDrawComplete(room: Room, playerId: string): void {\n        if (!room.gameState.playersCompletedDraw) {\n            room.gameState.playersCompletedDraw = [];\n        }\n        if (!room.gameState.playersCompletedDraw.includes(playerId)) {\n            room.gameState.playersCompletedDraw.push(playerId);\n        }\n    }\n\n    /**\n     * ãƒãƒ³ãƒ‰çµ‚äº†å‡¦ç†\n     */\n    endHand(room: Room): void {\n        console.log(`\\nğŸ Hand #${room.gameState.handNumber} ended`);\n\n        // çŠ¶æ…‹ã‚’SHOWDOWNã«è¨­å®šï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€šçŸ¥ç”¨ï¼‰\n        room.gameState.status = 'SHOWDOWN' as any;\n        room.activePlayerIndex = -1;\n    }\n\n    /**\n     * ç€å¸­ä¸­ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n     */\n    getSeatedPlayers(room: Room): Player[] {\n        return room.players.filter(p =>\n            p !== null &&\n            p.stack > 0 &&\n            (p.status === 'ACTIVE' || p.waitingForBB)\n        ) as Player[];\n    }\n\n    /**\n     * ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æœ‰åŠ¹ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—\n     * ãƒãƒ¼ã‚«ãƒ¼ãƒ«ãƒ¼ãƒ«:\n     * - ãƒ™ãƒƒãƒˆãŒãªã„ï¼ˆãƒã‚§ãƒƒã‚¯å¯èƒ½ï¼‰æ™‚ã¯FOLDã§ããªã„\n     * - ãƒ™ãƒƒãƒˆã«ç›´é¢ã—ã¦ã„ã‚‹æ™‚ã®ã¿FOLDå¯èƒ½\n     * - Fixed-Limit: ã‚­ãƒ£ãƒƒãƒ—ã«é”ã—ãŸã‚‰ãƒ¬ã‚¤ã‚ºä¸å¯\n     */\n    getValidActions(room: Room, playerId: string): ActionType[] {\n        const player = room.players.find(p => p?.socketId === playerId);\n        if (!player) return [];\n\n        const actions: ActionType[] = [];\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        // ä»–ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆACTIVEçŠ¶æ…‹ã®ã¿ï¼‰ã‚’å–å¾—\n        const otherActivePlayers = room.players.filter(p =>\n            p !== null && p.socketId !== playerId && p.status === 'ACTIVE'\n        );\n\n        // ã‚³ãƒ¼ãƒ«é¡ã‚’è¨ˆç®—\n        const callAmount = Math.max(0, room.gameState.currentBet - player.bet);\n        const wouldCallAllIn = callAmount >= player.stack;\n\n        if (player.bet >= room.gameState.currentBet) {\n            // ãƒ™ãƒƒãƒˆãŒãªã„ï¼ˆã¾ãŸã¯æ—¢ã«ã‚³ãƒ¼ãƒ«æ¸ˆã¿ï¼‰â†’ ãƒã‚§ãƒƒã‚¯å¯èƒ½ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ä¸å¯\n            actions.push('CHECK');\n        } else {\n            // ãƒ™ãƒƒãƒˆã«ç›´é¢ â†’ ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã¾ãŸã¯ã‚³ãƒ¼ãƒ«\n            actions.push('FOLD');\n            actions.push('CALL');\n        }\n\n        // BET/RAISEã®å¯å¦åˆ¤å®š\n        const canAffordRaise = player.stack > callAmount;\n\n        // Fixed-Limit: ã‚­ãƒ£ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯\n        const isCapped = variantConfig.betStructure === 'fixed' &&\n            room.gameState.raisesThisRound >= this.getCapLimit(room);\n\n        // ä»–ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„å ´åˆï¼ˆå…¨å“¡ALL-INã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ï¼‰ã€ãƒ¬ã‚¤ã‚ºä¸å¯\n        const canRaise = canAffordRaise && !isCapped && otherActivePlayers.length > 0;\n\n        if (canRaise) {\n            if (room.gameState.currentBet === 0) {\n                actions.push('BET');\n            } else {\n                actions.push('RAISE');\n            }\n        }\n\n        // ALL-IN: No-Limitã®ã¿ã€ã‹ã¤ã‚³ãƒ¼ãƒ«ãŒALL-INã«ãªã‚‰ãªã„å ´åˆã®ã¿è¡¨ç¤º\n        // ï¼ˆã‚³ãƒ¼ãƒ«ãŒALL-INã«ãªã‚‹å ´åˆã¯ã€CALLã‚’é¸ã¹ã°ALL-INã«ãªã‚‹ï¼‰\n        if (variantConfig.betStructure === 'no-limit' && !wouldCallAllIn && player.stack > 0) {\n            actions.push('ALL_IN');\n        }\n\n        return actions;\n    }\n\n    /**\n     * ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°æƒ…å ±ã‚’å–å¾—ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”¨ï¼‰\n     * minBet, maxBet, betStructure ãªã©ã‚’è¿”ã™\n     */\n    getBettingInfo(room: Room, playerId: string): {\n        minBet: number;\n        maxBet: number;\n        betStructure: string;\n        isCapped: boolean;\n        raisesRemaining: number;\n        fixedBetSize?: number;\n    } {\n        const player = room.players.find(p => p?.socketId === playerId);\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        if (!player) {\n            return {\n                minBet: 0,\n                maxBet: 0,\n                betStructure: variantConfig.betStructure,\n                isCapped: false,\n                raisesRemaining: 0\n            };\n        }\n\n        const callAmount = Math.max(0, room.gameState.currentBet - player.bet);\n        const minBetTo = this.getMinBetTo(room, player);\n\n        // æœ€å¤§ãƒ™ãƒƒãƒˆé¡ã®è¨ˆç®—\n        let maxBetTo: number;\n        let fixedBetSize: number | undefined;\n\n        switch (variantConfig.betStructure) {\n            case 'pot-limit':\n                maxBetTo = Math.min(\n                    this.calculatePotLimitMax(room, player),\n                    player.stack + player.bet\n                );\n                break;\n\n            case 'fixed':\n                // Fixed-Limit: Small Bet or Big Bet\n                fixedBetSize = this.getFixedBetSize(room);\n                maxBetTo = room.gameState.currentBet + fixedBetSize;\n                // ã‚¹ã‚¿ãƒƒã‚¯ãŒè¶³ã‚Šãªã„å ´åˆã¯èª¿æ•´\n                maxBetTo = Math.min(maxBetTo, player.stack + player.bet);\n                break;\n\n            default: // no-limit\n                maxBetTo = player.stack + player.bet;\n                break;\n        }\n\n        const capLimit = this.getCapLimit(room);\n        const isCapped = variantConfig.betStructure === 'fixed' &&\n            room.gameState.raisesThisRound >= capLimit;\n        const raisesRemaining = Math.max(0, capLimit - room.gameState.raisesThisRound);\n\n        return {\n            minBet: minBetTo,\n            maxBet: maxBetTo,\n            betStructure: variantConfig.betStructure,\n            isCapped,\n            raisesRemaining,\n            fixedBetSize\n        };\n    }\n\n    /**\n     * æœ€å°ãƒ™ãƒƒãƒˆ/ãƒ¬ã‚¤ã‚ºã®ã€ŒTOã€å€¤ã‚’å–å¾—\n     */\n    private getMinBetTo(room: Room, player: Player): number {\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n        if (variantConfig.betStructure === 'fixed') {\n            const fixedBetSize = this.getFixedBetSize(room);\n            return room.gameState.currentBet === 0\n                ? fixedBetSize\n                : room.gameState.currentBet + fixedBetSize;\n        }\n\n        return room.gameState.currentBet === 0\n            ? room.gameState.minRaise\n            : room.gameState.currentBet + room.gameState.minRaise;\n    }\n\n    /**\n     * Pot-Limitã®æœ€å¤§ãƒ™ãƒƒãƒˆé¡ã‚’è¨ˆç®—\n     * è¨ˆç®—å¼: MaxBetTo = CurrentPot + (AmountToCall * 2)\n     *\n     * Note: pot.main ã«ã¯æ—¢ã«å…¨ã¦ã®ãƒ™ãƒƒãƒˆï¼ˆãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å«ã‚€ï¼‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹ãŸã‚ã€\n     * player.bet ã‚’è¿½åŠ ã™ã‚‹ã¨äºŒé‡ã‚«ã‚¦ãƒ³ãƒˆã«ãªã‚‹ã€‚\n     */\n    private calculatePotLimitMax(room: Room, player: Player): number {\n        // ç¾åœ¨ã®ãƒãƒƒãƒˆï¼ˆãƒ¡ã‚¤ãƒ³ + ã‚µã‚¤ãƒ‰ï¼‰\n        // pot.main ã«ã¯æ—¢ã«ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ã‚„ä»Šãƒ©ã‚¦ãƒ³ãƒ‰ã®ãƒ™ãƒƒãƒˆãŒå«ã¾ã‚Œã¦ã„ã‚‹\n        let currentPot = room.gameState.pot.main;\n        for (const sidePot of room.gameState.pot.side) {\n            currentPot += sidePot.amount;\n        }\n\n        // ã‚³ãƒ¼ãƒ«é¡\n        const amountToCall = Math.max(0, room.gameState.currentBet - player.bet);\n\n        // Pot-Limitè¨ˆç®—: ã‚³ãƒ¼ãƒ«å¾Œã®ä»®æƒ³ãƒãƒƒãƒˆã¾ã§ãƒ¬ã‚¤ã‚ºå¯èƒ½\n        // ã‚³ãƒ¼ãƒ«å¾Œã®ãƒãƒƒãƒˆ = currentPot + amountToCall\n        // æœ€å¤§ãƒ¬ã‚¤ã‚º = ã‚³ãƒ¼ãƒ«å¾Œã®ãƒãƒƒãƒˆ\n        // MaxBetTo = amountToCall + (currentPot + amountToCall) = currentPot + 2*amountToCall\n        const maxBetTo = currentPot + (amountToCall * 2);\n\n        return maxBetTo;\n    }\n\n    /**\n     * Fixed-Limitã®ãƒ™ãƒƒãƒˆã‚µã‚¤ã‚ºã‚’å–å¾—\n     * Small Bet: Preflop, Flop (ã¾ãŸã¯ Stud 3rd-4th Street)\n     * Big Bet: Turn, River (ã¾ãŸã¯ Stud 5th-7th Street)\n     */\n    private getFixedBetSize(room: Room): number {\n        const smallBet = room.config.bigBlind; // Small Bet = BBé¡\n        const bigBet = smallBet * 2;           // Big Bet = 2x Small Bet\n\n        const phase = room.gameState.status;\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        // Studç³»: 5th Streetä»¥é™ã¯Big Bet\n        if (variantConfig.communityCardType === 'stud') {\n            if (phase === 'FIFTH_STREET' || phase === 'SIXTH_STREET' || phase === 'SEVENTH_STREET') {\n                return bigBet;\n            }\n            return smallBet;\n        }\n\n        // Drawç³»: å¾ŒåŠã®ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã¯Big Bet\n        if (variantConfig.hasDrawPhase) {\n            const drawRounds = variantConfig.drawRounds || 3;\n            // ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ•° = drawRounds + 1 (predraw + å„ãƒ‰ãƒ­ãƒ¼å¾Œ)\n            // Big Betã¯å¾ŒåŠã‹ã‚‰: Math.ceil((drawRounds+1) / 2)\n            // 3ãƒ©ã‚¦ãƒ³ãƒ‰: street 2,3 = Big Bet (SECOND_DRAW, THIRD_DRAW)\n            const bigBetStartStreet = Math.ceil((drawRounds + 1) / 2);\n            if (room.gameState.street >= bigBetStartStreet) {\n                return bigBet;\n            }\n            return smallBet;\n        }\n\n        // Flopç³»: å¾ŒåŠã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã¯Big Bet\n        // æ¨™æº–[3,1,1]: street 2(Turn),3(River) = Big Bet\n        // Ocean[3,1,1,1]: street 2(Turn),3(River),4(Ocean) = Big Bet\n        if (room.gameState.street >= 2) {\n            return bigBet;\n        }\n\n        return smallBet;\n    }\n\n    /**\n     * Fixed-Limitã®ã‚­ãƒ£ãƒƒãƒ—ï¼ˆãƒ¬ã‚¤ã‚ºä¸Šé™å›æ•°ï¼‰ã‚’å–å¾—\n     * é€šå¸¸: 4å›ï¼ˆ5-bet capï¼‰\n     * Heads-Up: ç„¡åˆ¶é™ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰\n     */\n    private getCapLimit(room: Room): number {\n        // Heads-Upï¼ˆ2äººï¼‰ã®å ´åˆã¯ç„¡åˆ¶é™ã‚’è¨±å¯ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³\n        // ç¾åœ¨ã¯ç°¡æ˜“ç‰ˆã¨ã—ã¦å¸¸ã«4å›ã¨ã™ã‚‹\n        const activePlayers = room.players.filter(p =>\n            p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        ).length;\n\n        // Heads-Upä¾‹å¤–: ç„¡åˆ¶é™ï¼ˆå¤§ããªæ•°ã‚’è¿”ã™ï¼‰\n        // TODO: è¨­å®šã§ ON/OFF å¯èƒ½ã«ã™ã‚‹\n        if (activePlayers === 2) {\n            return 99; // äº‹å®Ÿä¸Šç„¡åˆ¶é™\n        }\n\n        return 4; // 5-bet cap (1 bet + 4 raises)\n    }\n\n    /**\n     * ãƒ‡ãƒƒã‚­ã¸ã®å‚ç…§ã‚’å–å¾—ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰\n     */\n    getDeck(): string[] {\n        return this.deck;\n    }\n\n    /**\n     * ALL INæ™‚ã«æ®‹ã‚Šã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’è‡ªå‹•ã§é…ã‚‹\n     */\n    private dealToShowdown(room: Room): void {\n        const phase = room.gameState.status;\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        if (variantConfig.communityCardType === 'stud') {\n            // Stud: æ®‹ã‚Šã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’é…ã‚‹\n            this.dealStudToShowdown(room, phase);\n        } else if (variantConfig.hasDrawPhase) {\n            // Draw: ã‚«ãƒ¼ãƒ‰äº¤æ›ãªã—ã§ãã®ã¾ã¾ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³\n            console.log(`ğŸ”„ Auto-Showdown: No more draws`);\n            room.gameState.status = 'SHOWDOWN' as any;\n        } else {\n            // Flop games: ãƒœãƒ¼ãƒ‰ã‚’å®Œæˆã•ã›ã‚‹\n            this.dealFlopToShowdown(room, phase);\n        }\n    }\n\n    /**\n     * Flopç³»ã‚²ãƒ¼ãƒ ã®ã‚ªãƒ¼ãƒˆãƒ‡ã‚£ãƒ¼ãƒ«ï¼ˆå…¨ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ã‚’ä¸€æ°—ã«é…å¸ƒï¼‰\n     * boardPatternã«åŸºã¥ã„ã¦ãƒ‡ãƒ¼ã‚¿é§†å‹•\n     */\n    private dealFlopToShowdown(room: Room, phase: any): void {\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n        const boardPattern = variantConfig.boardPattern || [3, 1, 1];\n        const FLOP_PHASES = ['PREFLOP', 'FLOP', 'TURN', 'RIVER', 'OCEAN'];\n\n        const currentStreet = room.gameState.street;\n\n        // æ®‹ã‚Šã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’å…¨ã¦é…å¸ƒ\n        for (let streetIdx = currentStreet + 1; streetIdx <= boardPattern.length; streetIdx++) {\n            const cardCount = boardPattern[streetIdx - 1];\n            const newCards = this.dealer.dealBoardCards(this.deck, cardCount);\n            room.gameState.board.push(...newCards);\n            const phaseName = FLOP_PHASES[streetIdx] || `Street${streetIdx}`;\n            console.log(`ğŸƒ Auto-${phaseName}: ${newCards.join(' ')}`);\n        }\n\n        // æœ€å¾Œã®ãƒ•ã‚§ãƒ¼ã‚ºã«çŠ¶æ…‹ã‚’è¨­å®š\n        const lastStreet = boardPattern.length;\n        const lastPhase = FLOP_PHASES[lastStreet] || 'RIVER';\n        if (currentStreet < lastStreet) {\n            room.gameState.status = lastPhase as any;\n            room.gameState.street = lastStreet;\n        }\n    }\n\n    /**\n     * Studç³»ã‚²ãƒ¼ãƒ ã®ã‚ªãƒ¼ãƒˆãƒ‡ã‚£ãƒ¼ãƒ«\n     */\n    private dealStudToShowdown(room: Room, phase: any): void {\n        const phases = ['THIRD_STREET', 'FOURTH_STREET', 'FIFTH_STREET', 'SIXTH_STREET', 'SEVENTH_STREET'];\n        let currentIdx = phases.indexOf(phase);\n\n        // 3rd Street (PREFLOP)ã‹ã‚‰å§‹ã¾ã‚‹å ´åˆ\n        if (currentIdx === -1 && phase === 'PREFLOP') {\n            currentIdx = 0;\n        }\n\n        // æ®‹ã‚Šã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’é…ã‚‹\n        while (currentIdx < 4) { // 7th Streetã¾ã§\n            currentIdx++;\n            if (currentIdx <= 3) {\n                // 4th-6th Street: up card\n                this.dealer.dealStudStreet(this.deck, room.players, false);\n                console.log(`ğŸ´ Auto-${phases[currentIdx]}`);\n            } else if (currentIdx === 4) {\n                // 7th Street: down card\n                this.dealer.dealStudStreet(this.deck, room.players, true);\n                console.log(`ğŸ´ Auto-7th Street (down)`);\n            }\n        }\n\n        room.gameState.status = 'SEVENTH_STREET' as any;\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/ShowdownManager.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'executeHiLoShowdown' has too many lines (155). Maximum allowed is 100.","line":425,"column":5,"nodeType":"MethodDefinition","messageId":"exceed","endLine":579,"endColumn":6},{"ruleId":"complexity","severity":1,"message":"Method 'executeHiLoShowdown' has a complexity of 11. Maximum allowed is 10.","line":425,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":425,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Phase 3-B: Showdown Manager\n * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³æ™‚ã®å‹è€…åˆ¤å®šã¨ãƒãƒƒãƒˆåˆ†é…\n */\n\nimport type { Room, Player, PotState } from './types.js';\nimport {\n    evaluateHand,\n    compareHands,\n    evaluateLowHand8OrBetter,\n    evaluateRazzHand,\n    evaluateBadugiHand,\n    evaluateDeuceSeven,\n    compareLowHands,\n    compareBadugiHands,\n    compareDeuceSeven\n} from './handEvaluator.js';\nimport { PotManager } from './PotManager.js';\nimport { getVariantConfig } from './gameVariants.js';\n\n// ã‚«ãƒ¼ãƒ‰æ–‡å­—åˆ—ã‚’Cardã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›\ninterface Card {\n    rank: string;\n    suit: string;\n}\n\nfunction parseCard(cardStr: string): Card {\n    // ã‚«ãƒ¼ãƒ‰æ–‡å­—åˆ—ã¯ \"AS\", \"KH\", \"TD\" ãªã©ã®å½¢å¼\n    // Tã¯10ã‚’è¡¨ã™\n    const rank = cardStr[0] === 'T' ? '10' : cardStr[0];\n    const suit = cardStr[1];\n    return { rank, suit };\n}\n\nfunction parseCards(cards: string[]): Card[] {\n    return cards.map(parseCard);\n}\n\n/**\n * é…åˆ—ã‹ã‚‰nå€‹ã®è¦ç´ ã®çµ„ã¿åˆã‚ã›ã‚’ç”Ÿæˆ\n * @param arr å…ƒã®é…åˆ—\n * @param n é¸æŠã™ã‚‹è¦ç´ æ•°\n * @returns nå€‹ã®è¦ç´ ã®çµ„ã¿åˆã‚ã›ã®é…åˆ—\n */\nfunction combinations<T>(arr: T[], n: number): T[][] {\n    if (n === 0) return [[]];\n    if (n > arr.length) return [];\n\n    const result: T[][] = [];\n\n    function helper(start: number, current: T[]) {\n        if (current.length === n) {\n            result.push([...current]);\n            return;\n        }\n\n        for (let i = start; i <= arr.length - (n - current.length); i++) {\n            current.push(arr[i]);\n            helper(i + 1, current);\n            current.pop();\n        }\n    }\n\n    helper(0, []);\n    return result;\n}\n\n// 7æšã‹ã‚‰æœ€å¼·ã®5æšã‚’é¸ã¶\nfunction getBestFiveCards(cards: Card[]): Card[] {\n    if (cards.length <= 5) return cards;\n\n    // ã™ã¹ã¦ã®5æšã®çµ„ã¿åˆã‚ã›ã‚’è©¦ã™\n    let bestHand = cards.slice(0, 5);\n    let bestRank = evaluateHand(bestHand);\n\n    for (const hand of combinations(cards, 5)) {\n        const rank = evaluateHand(hand);\n        if (rank.rank > bestRank.rank) {\n            bestHand = hand;\n            bestRank = rank;\n        } else if (rank.rank === bestRank.rank) {\n            // åŒã˜å½¹ã®å ´åˆã€é«˜ä½ã‚«ãƒ¼ãƒ‰ã§æ¯”è¼ƒ\n            const comparison = compareHands(hand, bestHand);\n            if (comparison > 0) {\n                bestHand = hand;\n                bestRank = rank;\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// PLOç”¨: æ‰‹æœ­ã‹ã‚‰2æšã€ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšã‚’ä½¿ç”¨ã—ã¦æœ€å¼·ã®5æšã‚’é¸ã¶\nfunction getBestPLOFiveCards(holeCards: Card[], boardCards: Card[]): Card[] {\n    if (holeCards.length < 2 || boardCards.length < 3) {\n        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é€šå¸¸ã®è©•ä¾¡\n        return getBestFiveCards([...holeCards, ...boardCards]);\n    }\n\n    let bestHand = [...holeCards.slice(0, 2), ...boardCards.slice(0, 3)];\n    let bestRank = evaluateHand(bestHand);\n\n    // æ‰‹æœ­ã‹ã‚‰2æšé¸ã¶çµ„ã¿åˆã‚ã› (C(4,2) = 6é€šã‚Šã€ã¾ãŸã¯ C(n,2))\n    const holeCombos = combinations(holeCards, 2);\n    // ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšé¸ã¶çµ„ã¿åˆã‚ã› (C(5,3) = 10é€šã‚Š)\n    const boardCombos = combinations(boardCards, 3);\n\n    for (const holeCombo of holeCombos) {\n        for (const boardCombo of boardCombos) {\n            const hand = [...holeCombo, ...boardCombo];\n            const rank = evaluateHand(hand);\n            if (rank.rank > bestRank.rank) {\n                bestHand = hand;\n                bestRank = rank;\n            } else if (rank.rank === bestRank.rank) {\n                const comparison = compareHands(hand, bestHand);\n                if (comparison > 0) {\n                    bestHand = hand;\n                    bestRank = rank;\n                }\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// PLO8ç”¨: æ‰‹æœ­ã‹ã‚‰2æšã€ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšã‚’ä½¿ç”¨ã—ã¦æœ€å¼·ã®ãƒ­ãƒ¼ãƒãƒ³ãƒ‰5æšã‚’é¸ã¶\nfunction getBestPLOLowFiveCards(holeCards: Card[], boardCards: Card[]): Card[] | null {\n    if (holeCards.length < 2 || boardCards.length < 3) {\n        return null;\n    }\n\n    let bestHand: Card[] | null = null;\n    let bestLow = evaluateLowHand8OrBetter([]);\n\n    // æ‰‹æœ­ã‹ã‚‰2æšé¸ã¶çµ„ã¿åˆã‚ã›\n    const holeCombos = combinations(holeCards, 2);\n    // ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšé¸ã¶çµ„ã¿åˆã‚ã›\n    const boardCombos = combinations(boardCards, 3);\n\n    for (const holeCombo of holeCombos) {\n        for (const boardCombo of boardCombos) {\n            const hand = [...holeCombo, ...boardCombo];\n            const lowResult = evaluateLowHand8OrBetter(hand);\n            if (lowResult.valid) {\n                if (!bestHand || compareLowHands(lowResult, bestLow) > 0) {\n                    bestHand = hand;\n                    bestLow = lowResult;\n                }\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// 7æšã‹ã‚‰æœ€å¼·ã®ãƒ­ãƒ¼ãƒãƒ³ãƒ‰5æšã‚’é¸ã¶ï¼ˆ8-or-betterï¼‰\nfunction getBestLowFiveCards(cards: Card[]): Card[] | null {\n    if (cards.length < 5) return null;\n\n    let bestHand: Card[] | null = null;\n    let bestLow = evaluateLowHand8OrBetter([]);\n\n    // ã™ã¹ã¦ã®5æšã®çµ„ã¿åˆã‚ã›ã‚’è©¦ã™\n    for (const hand of combinations(cards, 5)) {\n        const lowResult = evaluateLowHand8OrBetter(hand);\n        if (lowResult.valid) {\n            if (!bestHand || compareLowHands(lowResult, bestLow) > 0) {\n                bestHand = hand;\n                bestLow = lowResult;\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// Razzç”¨: 7æšã‹ã‚‰æœ€å¼·ã®ãƒ­ãƒ¼ãƒãƒ³ãƒ‰5æšã‚’é¸ã¶\nfunction getBestRazzFiveCards(cards: Card[]): Card[] {\n    if (cards.length <= 5) return cards;\n\n    let bestHand = cards.slice(0, 5);\n    let bestLow = evaluateRazzHand(bestHand);\n\n    for (const hand of combinations(cards, 5)) {\n        const lowResult = evaluateRazzHand(hand);\n        if (compareLowHands(lowResult, bestLow) > 0) {\n            bestHand = hand;\n            bestLow = lowResult;\n        }\n    }\n\n    return bestHand;\n}\n\nexport interface ShowdownResult {\n    winners: {\n        playerId: string;\n        playerName: string;\n        hand: string[];\n        handRank: string;\n        amount: number;\n    }[];\n    allHands: {\n        playerId: string;\n        playerName: string;\n        hand: string[] | null;  // nullã®å ´åˆã¯ãƒãƒƒã‚¯ï¼ˆéè¡¨ç¤ºï¼‰\n        handRank: string;\n        isMucked?: boolean;     // ãƒãƒƒã‚¯ã•ã‚ŒãŸã‹ã©ã†ã‹\n    }[];\n}\n\nexport class ShowdownManager {\n    private potManager: PotManager;\n\n    constructor() {\n        this.potManager = new PotManager();\n    }\n\n    /**\n     * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã‚’æ±ºå®š\n     * - ãƒ©ã‚¹ãƒˆã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ãŒã„ã‚‹å ´åˆ: ã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ã‹ã‚‰æ™‚è¨ˆå›ã‚Š\n     * - ã„ãªã„å ´åˆï¼ˆå…¨å“¡ãƒã‚§ãƒƒã‚¯ï¼‰: ãƒœã‚¿ãƒ³ã®å·¦ï¼ˆSBä½ç½®ï¼‰ã‹ã‚‰æ™‚è¨ˆå›ã‚Š\n     */\n    private getShowdownOrder(room: Room, players: Player[]): Player[] {\n        const maxPlayers = room.config.maxPlayers;\n        const lastAggressorIdx = room.lastAggressorIndex;\n        const buttonIdx = room.dealerBtnIndex;\n\n        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®seatIndexã‚’å–å¾—\n        const playerSeats = players.map(p => {\n            const seatIdx = room.players.findIndex(rp => rp?.socketId === p.socketId);\n            return { player: p, seatIndex: seatIdx };\n        });\n\n        let startIndex: number;\n        if (lastAggressorIdx !== -1 && room.players[lastAggressorIdx]) {\n            // ãƒ©ã‚¹ãƒˆã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ãŒã„ã‚‹å ´åˆã€ãã®äººã‹ã‚‰é–‹å§‹\n            startIndex = lastAggressorIdx;\n        } else {\n            // å…¨å“¡ãƒã‚§ãƒƒã‚¯ã®å ´åˆã€ãƒœã‚¿ãƒ³ã®æ¬¡ï¼ˆSBä½ç½®ï¼‰ã‹ã‚‰é–‹å§‹\n            startIndex = (buttonIdx + 1) % maxPlayers;\n        }\n\n        // startIndexã‹ã‚‰æ™‚è¨ˆå›ã‚Šã«ã‚½ãƒ¼ãƒˆ\n        playerSeats.sort((a, b) => {\n            const distA = (a.seatIndex - startIndex + maxPlayers) % maxPlayers;\n            const distB = (b.seatIndex - startIndex + maxPlayers) % maxPlayers;\n            return distA - distB;\n        });\n\n        return playerSeats.map(ps => ps.player);\n    }\n\n    /**\n     * ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\n     */\n    private hasAllInPlayer(room: Room): boolean {\n        return room.players.some(p => p !== null && p.status === 'ALL_IN');\n    }\n\n    /**\n     * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ã‚’å®Ÿè¡Œã—ã€å‹è€…ã‚’æ±ºå®šã—ã¦ãƒãƒƒãƒˆã‚’åˆ†é…\n     * ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆã«å¿œã˜ãŸè©•ä¾¡ã‚’è¡Œã†\n     */\n    executeShowdown(room: Room): ShowdownResult {\n        const board = room.gameState.board;\n        const variant = room.gameState.gameVariant;\n        const variantConfig = getVariantConfig(variant);\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n        const showdownPlayers = room.players.filter(p =>\n            p !== null &&\n            (p.status === 'ACTIVE' || p.status === 'ALL_IN') &&\n            p.hand !== null\n        ) as Player[];\n\n        if (showdownPlayers.length === 0) {\n            return { winners: [], allHands: [] };\n        }\n\n        // ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆã«å¿œã˜ãŸè©•ä¾¡\n        switch (variantConfig.handEvaluation) {\n            case 'highlow':\n                return this.executeHiLoShowdown(room, showdownPlayers, board);\n            case 'razz':\n                return this.executeRazzShowdown(room, showdownPlayers, board);\n            case 'badugi':\n                return this.executeBadugiShowdown(room, showdownPlayers);\n            case '2-7':\n                return this.executeDeuce7Showdown(room, showdownPlayers);\n            default:\n                return this.executeHighShowdown(room, showdownPlayers, board);\n        }\n    }\n\n    /**\n     * ãƒã‚¤ãƒãƒ³ãƒ‰ã®ã¿ã®è©•ä¾¡ï¼ˆNLH, PLOç­‰ï¼‰\n     */\n    private executeHighShowdown(room: Room, players: Player[], board: string[]): ShowdownResult {\n        const variant = room.gameState.gameVariant;\n        const variantConfig = getVariantConfig(variant);\n        const useOmahaSelection = variantConfig.holeCardsForSelection !== undefined;\n        const isAllInShowdown = this.hasAllInPlayer(room);\n\n        // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã‚’æ±ºå®š\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        // å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹å½¹ã‚’è©•ä¾¡\n        const evaluations = orderedPlayers.map(player => {\n            const holeCards = parseCards(player.hand!);\n            const boardCards = parseCards(board);\n\n            // Omahaç³»: æ‰‹æœ­ã‹ã‚‰å¿…ãšNæšä½¿ç”¨ + ãƒœãƒ¼ãƒ‰3æšã®çµ„ã¿åˆã‚ã›\n            // Hold'emç³»: å…¨ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€å¼·ã®5æš\n            const bestFive = useOmahaSelection\n                ? getBestPLOFiveCards(holeCards, boardCards)\n                : getBestFiveCards([...holeCards, ...boardCards]);\n\n            const handResult = evaluateHand(bestFive);\n\n            return {\n                player,\n                bestFive,\n                handResult,\n                handRank: handResult.name\n            };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œã®ãƒãƒƒãƒˆåˆ†é…ï¼ˆå‹è€…ã®æ±ºå®šï¼‰\n        const winners = this.distributeToWinnersWithSidePots(room, evaluations, compareHands);\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n\n        if (isAllInShowdown) {\n            // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ã®å ´åˆ: å…¨å“¡å¼·åˆ¶ã‚ªãƒ¼ãƒ—ãƒ³ï¼ˆå…±è¬€é˜²æ­¢ï¼‰\n            // ãƒãƒ³ãƒ‰ã¯ã‚³ãƒ”ãƒ¼ã—ã¦å‚ç…§å•é¡Œã‚’é˜²ã\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n            console.log(`ğŸ† All-In Showdown: All hands revealed`);\n        } else {\n            // é€šå¸¸ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³: é †åºã«å¾“ã£ã¦Show/Muckåˆ¤å®š\n            allHands = this.determineShowMuck(evaluations, winnerIds, compareHands);\n        }\n\n        console.log(`ğŸ† Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã«å¾“ã£ã¦Show/Muckã‚’åˆ¤å®š\n     * - 1ç•ªæ‰‹: å¿…ãšShow\n     * - 2ç•ªæ‰‹ä»¥é™: ç¾åœ¨ã®ãƒ™ã‚¹ãƒˆã‚ˆã‚Šå¼·ã„ã‹åŒã˜ãªã‚‰Showã€å¼±ã‘ã‚Œã°Muck\n     */\n    private determineShowMuck<T extends { player: Player; bestFive: Card[]; handRank: string }>(\n        evaluations: T[],\n        winnerIds: Set<string>,\n        compareFunc: (a: Card[], b: Card[]) => number\n    ): ShowdownResult['allHands'] {\n        let currentBestFive: Card[] | null = null;\n\n        return evaluations.map((e, index) => {\n            // 1ç•ªæ‰‹ã¯å¿…ãšShow\n            if (index === 0) {\n                currentBestFive = e.bestFive;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            }\n\n            // 2ç•ªæ‰‹ä»¥é™: ç¾åœ¨ã®ãƒ™ã‚¹ãƒˆã¨æ¯”è¼ƒ\n            const comparison = compareFunc(e.bestFive, currentBestFive!);\n\n            if (comparison > 0) {\n                // å‹ã£ã¦ã„ã‚‹ â†’ Show & ãƒ™ã‚¹ãƒˆæ›´æ–°\n                currentBestFive = e.bestFive;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else if (comparison === 0) {\n                // å¼•ãåˆ†ã‘ â†’ Showï¼ˆãƒãƒƒãƒˆåˆ†å‰²ã®æ¨©åˆ©ï¼‰\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else {\n                // è² ã‘ã¦ã„ã‚‹ â†’ Muck\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: null,\n                    handRank: 'Mucked',\n                    isMucked: true\n                };\n            }\n        });\n    }\n\n    /**\n     * Hi-Loè©•ä¾¡ï¼ˆPLO8, 7CS8ç­‰ï¼‰\n     * ãƒãƒƒãƒˆã‚’ãƒã‚¤ã¨ãƒ­ãƒ¼ã§åŠåˆ†ãšã¤åˆ†ã‘ã‚‹\n     * æ³¨: Hi-Loã§ã¯ã€Highã¾ãŸã¯Lowã®ã„ãšã‚Œã‹ã§å‹ã¦ã‚‹å ´åˆã«Showã€‚ä¸¡æ–¹ã§è² ã‘ã‚‹å ´åˆã®ã¿Muckã€‚\n     */\n    private executeHiLoShowdown(room: Room, players: Player[], board: string[]): ShowdownResult {\n        const variant = room.gameState.gameVariant;\n        const variantConfig = getVariantConfig(variant);\n        const useOmahaSelection = variantConfig.holeCardsForSelection !== undefined;\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        // ãƒã‚¤ãƒãƒ³ãƒ‰è©•ä¾¡ï¼ˆã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã§è©•ä¾¡ï¼‰\n        const highEvaluations = orderedPlayers.map(player => {\n            const holeCards = parseCards(player.hand!);\n            const boardCards = parseCards(board);\n\n            // Omahaç³»: æ‰‹æœ­ã‹ã‚‰å¿…ãšNæšä½¿ç”¨ + ãƒœãƒ¼ãƒ‰3æšã®çµ„ã¿åˆã‚ã›\n            // Studç³»: å…¨ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€å¼·ã®5æš\n            const bestFive = useOmahaSelection\n                ? getBestPLOFiveCards(holeCards, boardCards)\n                : getBestFiveCards([...holeCards, ...boardCards]);\n\n            const handResult = evaluateHand(bestFive);\n            return { player, bestFive, handResult, handRank: handResult.name };\n        });\n\n        // ãƒ­ãƒ¼ãƒãƒ³ãƒ‰è©•ä¾¡\n        const lowEvaluations = orderedPlayers.map(player => {\n            const holeCards = parseCards(player.hand!);\n            const boardCards = parseCards(board);\n\n            // Omahaç³»: æ‰‹æœ­ã‹ã‚‰å¿…ãšNæšä½¿ç”¨ + ãƒœãƒ¼ãƒ‰3æšã®çµ„ã¿åˆã‚ã›\n            // Studç³»: å…¨ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€å¼·ã®5æš\n            const bestLowFive = useOmahaSelection\n                ? getBestPLOLowFiveCards(holeCards, boardCards)\n                : getBestLowFiveCards([...holeCards, ...boardCards]);\n\n            const lowResult = bestLowFive ? evaluateLowHand8OrBetter(bestLowFive) : { valid: false, cards: [], name: 'No Low' };\n            return { player, bestLowFive, lowResult, handRank: lowResult.name };\n        }).filter(e => e.lowResult.valid);\n\n        const winnersMap = new Map<string, { player: Player; amount: number; highRank?: string; lowRank?: string }>();\n\n        const addWinnings = (player: Player, amount: number, side: 'high' | 'low', handRank: string) => {\n            if (amount <= 0) return;\n            const existing = winnersMap.get(player.socketId);\n            if (existing) {\n                existing.amount += amount;\n                if (side === 'high') existing.highRank = handRank;\n                if (side === 'low') existing.lowRank = handRank;\n            } else {\n                winnersMap.set(player.socketId, {\n                    player,\n                    amount,\n                    highRank: side === 'high' ? handRank : undefined,\n                    lowRank: side === 'low' ? handRank : undefined\n                });\n            }\n        };\n\n        const allEligibleIds = highEvaluations.map(e => e.player.socketId);\n        const potSlices = [\n            { amount: room.gameState.pot.main, eligiblePlayers: allEligibleIds },\n            ...room.gameState.pot.side.map(p => ({ amount: p.amount, eligiblePlayers: p.eligiblePlayers }))\n        ];\n\n        for (const pot of potSlices) {\n            if (pot.amount <= 0) continue;\n\n            const eligibleHigh = highEvaluations.filter(e =>\n                pot.eligiblePlayers.includes(e.player.socketId)\n            );\n            if (eligibleHigh.length === 0) continue;\n\n            let bestHighEval = eligibleHigh[0];\n            for (const e of eligibleHigh) {\n                if (compareHands(e.bestFive, bestHighEval.bestFive) > 0) {\n                    bestHighEval = e;\n                }\n            }\n            const highWinners = eligibleHigh.filter(e =>\n                compareHands(e.bestFive, bestHighEval.bestFive) === 0\n            );\n\n            const eligibleLow = lowEvaluations.filter(e =>\n                pot.eligiblePlayers.includes(e.player.socketId)\n            );\n\n            const hasLowWinner = eligibleLow.length > 0;\n            const highPot = hasLowWinner ? Math.floor(pot.amount / 2) : pot.amount;\n            const lowPot = hasLowWinner ? pot.amount - highPot : 0;\n\n            const highShare = Math.floor(highPot / highWinners.length);\n            const highRemainder = highPot % highWinners.length;\n            highWinners.forEach((w, i) => {\n                const amount = highShare + (i < highRemainder ? 1 : 0);\n                w.player.stack += amount;\n                addWinnings(w.player, amount, 'high', w.handRank);\n            });\n\n            if (hasLowWinner) {\n                let bestLowEval = eligibleLow[0];\n                for (const e of eligibleLow) {\n                    if (compareLowHands(e.lowResult, bestLowEval.lowResult) > 0) {\n                        bestLowEval = e;\n                    }\n                }\n                const lowWinners = eligibleLow.filter(e =>\n                    compareLowHands(e.lowResult, bestLowEval.lowResult) === 0\n                );\n\n                const lowShare = Math.floor(lowPot / lowWinners.length);\n                const lowRemainder = lowPot % lowWinners.length;\n                lowWinners.forEach((w, i) => {\n                    const amount = lowShare + (i < lowRemainder ? 1 : 0);\n                    w.player.stack += amount;\n                    addWinnings(w.player, amount, 'low', w.handRank);\n                });\n            }\n        }\n\n        room.gameState.pot = { main: 0, side: [] };\n\n        const winners: ShowdownResult['winners'] = Array.from(winnersMap.values()).map(w => {\n            const rankParts: string[] = [];\n            if (w.highRank) rankParts.push(`High: ${w.highRank}`);\n            if (w.lowRank) rankParts.push(`Low: ${w.lowRank}`);\n            return {\n                playerId: w.player.socketId,\n                playerName: w.player.name,\n                hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: rankParts.join(' / '),\n                amount: w.amount\n            };\n        });\n\n        // å‹è€…ã®IDã‚»ãƒƒãƒˆ\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        const allHands = highEvaluations.map(e => {\n            const isWinner = winnerIds.has(e.player.socketId);\n            const lowEval = lowEvaluations.find(le => le.player.socketId === e.player.socketId);\n            const rankStr = isWinner || isAllInShowdown\n                ? (lowEval ? `High: ${e.handRank} / Low: ${lowEval.handRank}` : `High: ${e.handRank}`)\n                : 'Mucked';\n            return {\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: (isWinner || isAllInShowdown) ? [...e.player.hand!] : null,  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: rankStr,\n                isMucked: !(isWinner || isAllInShowdown)\n            };\n        });\n\n        console.log(`ğŸ† Hi-Lo Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * Razzè©•ä¾¡ï¼ˆæœ€ã‚‚ä½ã„ãƒãƒ³ãƒ‰ãŒå‹ã¡ï¼‰\n     */\n    private executeRazzShowdown(room: Room, players: Player[], board: string[]): ShowdownResult {\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        const evaluations = orderedPlayers.map(player => {\n            const allCards = parseCards([...player.hand!, ...board]);\n            const bestFive = getBestRazzFiveCards(allCards);\n            const handResult = evaluateRazzHand(bestFive);\n            return { player, bestFive, handResult, handRank: handResult.name };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œ: handResultã‚’ä½¿ã£ãŸæ¯”è¼ƒ\n        const winners = this.distributeWithHandResultComparison(\n            room,\n            evaluations,\n            (a, b) => compareLowHands(a.handResult, b.handResult)\n        );\n\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n        if (isAllInShowdown) {\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n        } else {\n            allHands = this.determineShowMuckWithHandResult(\n                evaluations,\n                winnerIds,\n                (a, b) => compareLowHands(a.handResult, b.handResult)\n            );\n        }\n\n        console.log(`ğŸ† Razz Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * Badugiè©•ä¾¡\n     */\n    private executeBadugiShowdown(room: Room, players: Player[]): ShowdownResult {\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        const evaluations = orderedPlayers.map(player => {\n            const cards = parseCards(player.hand!);\n            const handResult = evaluateBadugiHand(cards);\n            return { player, handResult, handRank: handResult.name };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œ\n        const winners = this.distributeWithHandResultComparison(\n            room,\n            evaluations,\n            (a, b) => compareBadugiHands(a.handResult, b.handResult)\n        );\n\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n        if (isAllInShowdown) {\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n        } else {\n            allHands = this.determineShowMuckWithHandResult(\n                evaluations,\n                winnerIds,\n                (a, b) => compareBadugiHands(a.handResult, b.handResult)\n            );\n        }\n\n        console.log(`ğŸ† Badugi Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * 2-7 Lowballè©•ä¾¡\n     */\n    private executeDeuce7Showdown(room: Room, players: Player[]): ShowdownResult {\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        const evaluations = orderedPlayers.map(player => {\n            const cards = parseCards(player.hand!);\n            const handResult = evaluateDeuceSeven(cards);\n            return { player, handResult, handRank: handResult.name };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œ\n        const winners = this.distributeWithHandResultComparison(\n            room,\n            evaluations,\n            (a, b) => compareDeuceSeven(a.handResult, b.handResult)\n        );\n\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n        if (isAllInShowdown) {\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n        } else {\n            allHands = this.determineShowMuckWithHandResult(\n                evaluations,\n                winnerIds,\n                (a, b) => compareDeuceSeven(a.handResult, b.handResult)\n            );\n        }\n\n        console.log(`ğŸ† 2-7 Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * handResultãƒ™ãƒ¼ã‚¹ã®Show/Muckåˆ¤å®šï¼ˆRazz, Badugi, 2-7ç”¨ï¼‰\n     */\n    private determineShowMuckWithHandResult<T extends { player: Player; handResult: any; handRank: string }>(\n        evaluations: T[],\n        winnerIds: Set<string>,\n        compareFunc: (a: T, b: T) => number\n    ): ShowdownResult['allHands'] {\n        let currentBest: T | null = null;\n\n        return evaluations.map((e, index) => {\n            // 1ç•ªæ‰‹ã¯å¿…ãšShow\n            if (index === 0) {\n                currentBest = e;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            }\n\n            // 2ç•ªæ‰‹ä»¥é™: ç¾åœ¨ã®ãƒ™ã‚¹ãƒˆã¨æ¯”è¼ƒ\n            const comparison = compareFunc(e, currentBest!);\n\n            if (comparison > 0) {\n                // å‹ã£ã¦ã„ã‚‹ â†’ Show & ãƒ™ã‚¹ãƒˆæ›´æ–°\n                currentBest = e;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else if (comparison === 0) {\n                // å¼•ãåˆ†ã‘ â†’ Show\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else {\n                // è² ã‘ã¦ã„ã‚‹ â†’ Muck\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: null,\n                    handRank: 'Mucked',\n                    isMucked: true\n                };\n            }\n        });\n    }\n\n    /**\n     * æ±ç”¨çš„ãªã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œåˆ†é…ï¼ˆhandResultã‚’ä½¿ã†æ¯”è¼ƒç”¨ï¼‰\n     */\n    private distributeWithHandResultComparison<T extends { player: Player; handRank: string }>(\n        room: Room,\n        allEvaluations: T[],\n        compareFunc: (a: T, b: T) => number\n    ): ShowdownResult['winners'] {\n        const winnersMap = new Map<string, { player: Player; handRank: string; amount: number }>();\n\n        // ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆã®åˆ†é…\n        if (room.gameState.pot.main > 0 && allEvaluations.length > 0) {\n            let bestEval = allEvaluations[0];\n            for (const e of allEvaluations) {\n                if (compareFunc(e, bestEval) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            const mainWinners = allEvaluations.filter(e => compareFunc(e, bestEval) === 0);\n            const share = Math.floor(room.gameState.pot.main / mainWinners.length);\n            const remainder = room.gameState.pot.main % mainWinners.length;\n\n            mainWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n                winnersMap.set(w.player.socketId, {\n                    player: w.player,\n                    handRank: w.handRank,\n                    amount\n                });\n            });\n        }\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã®åˆ†é…\n        for (const sidePot of room.gameState.pot.side) {\n            if (sidePot.amount <= 0) continue;\n\n            const eligibleEvaluations = allEvaluations.filter(e =>\n                sidePot.eligiblePlayers.includes(e.player.socketId)\n            );\n            if (eligibleEvaluations.length === 0) continue;\n\n            let bestEval = eligibleEvaluations[0];\n            for (const e of eligibleEvaluations) {\n                if (compareFunc(e, bestEval) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            const sideWinners = eligibleEvaluations.filter(e => compareFunc(e, bestEval) === 0);\n            const share = Math.floor(sidePot.amount / sideWinners.length);\n            const remainder = sidePot.amount % sideWinners.length;\n\n            sideWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n\n                const existing = winnersMap.get(w.player.socketId);\n                if (existing) {\n                    existing.amount += amount;\n                } else {\n                    winnersMap.set(w.player.socketId, {\n                        player: w.player,\n                        handRank: w.handRank,\n                        amount\n                    });\n                }\n            });\n        }\n\n        room.gameState.pot = { main: 0, side: [] };\n\n        return Array.from(winnersMap.values()).map(w => ({\n            playerId: w.player.socketId,\n            playerName: w.player.name,\n            hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n            handRank: w.handRank,\n            amount: w.amount\n        }));\n    }\n\n    /**\n     * ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œã®ãƒãƒƒãƒˆåˆ†é…\n     * å„ãƒãƒƒãƒˆã”ã¨ã«å‚åŠ è³‡æ ¼ã®ã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­ã‹ã‚‰å‹è€…ã‚’æ±ºå®š\n     */\n    private distributeToWinnersWithSidePots(\n        room: Room,\n        allEvaluations: { player: Player; bestFive: Card[]; handRank: string }[],\n        compareFunc: (a: Card[], b: Card[]) => number\n    ): ShowdownResult['winners'] {\n        const winnersMap = new Map<string, { player: Player; handRank: string; amount: number }>();\n\n        // å…¨å‚åŠ è€…ã®ã‚½ã‚±ãƒƒãƒˆIDï¼ˆãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆè³‡æ ¼è€…ï¼‰\n        const allPlayerIds = allEvaluations.map(e => e.player.socketId);\n\n        // ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆã®åˆ†é…\n        if (room.gameState.pot.main > 0) {\n            // å…¨å“¡ã®ä¸­ã‹ã‚‰æœ€å¼·ã®ãƒãƒ³ãƒ‰ã‚’è¦‹ã¤ã‘ã‚‹\n            let bestEval = allEvaluations[0];\n            for (const e of allEvaluations) {\n                if (compareFunc(e.bestFive, bestEval.bestFive) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            // åŒç€å‹è€…ã‚’è¦‹ã¤ã‘ã‚‹\n            const mainWinners = allEvaluations.filter(e =>\n                compareFunc(e.bestFive, bestEval.bestFive) === 0\n            );\n\n            const share = Math.floor(room.gameState.pot.main / mainWinners.length);\n            const remainder = room.gameState.pot.main % mainWinners.length;\n\n            mainWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n\n                winnersMap.set(w.player.socketId, {\n                    player: w.player,\n                    handRank: w.handRank,\n                    amount\n                });\n            });\n        }\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã®åˆ†é…\n        for (const sidePot of room.gameState.pot.side) {\n            if (sidePot.amount <= 0) continue;\n\n            // ã“ã®ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã«å‚åŠ è³‡æ ¼ã®ã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è©•ä¾¡ã®ã¿\n            const eligibleEvaluations = allEvaluations.filter(e =>\n                sidePot.eligiblePlayers.includes(e.player.socketId)\n            );\n\n            if (eligibleEvaluations.length === 0) continue;\n\n            // å‚åŠ è³‡æ ¼è€…ã®ä¸­ã‹ã‚‰æœ€å¼·ã®ãƒãƒ³ãƒ‰ã‚’è¦‹ã¤ã‘ã‚‹\n            let bestEval = eligibleEvaluations[0];\n            for (const e of eligibleEvaluations) {\n                if (compareFunc(e.bestFive, bestEval.bestFive) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            // åŒç€å‹è€…ã‚’è¦‹ã¤ã‘ã‚‹\n            const sideWinners = eligibleEvaluations.filter(e =>\n                compareFunc(e.bestFive, bestEval.bestFive) === 0\n            );\n\n            const share = Math.floor(sidePot.amount / sideWinners.length);\n            const remainder = sidePot.amount % sideWinners.length;\n\n            sideWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n\n                const existing = winnersMap.get(w.player.socketId);\n                if (existing) {\n                    existing.amount += amount;\n                } else {\n                    winnersMap.set(w.player.socketId, {\n                        player: w.player,\n                        handRank: w.handRank,\n                        amount\n                    });\n                }\n            });\n        }\n\n        room.gameState.pot = { main: 0, side: [] };\n\n        return Array.from(winnersMap.values()).map(w => ({\n            playerId: w.player.socketId,\n            playerName: w.player.name,\n            hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n            handRank: w.handRank,\n            amount: w.amount\n        }));\n    }\n\n    /**\n     * å‹è€…ã¸ã®ãƒãƒƒãƒˆåˆ†é…å…±é€šå‡¦ç†ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰\n     */\n    private distributeToWinners(room: Room, winningPlayers: any[]): ShowdownResult['winners'] {\n        const totalPot = room.gameState.pot.main +\n            room.gameState.pot.side.reduce((sum, s) => sum + s.amount, 0);\n\n        const share = Math.floor(totalPot / winningPlayers.length);\n        const remainder = totalPot % winningPlayers.length;\n\n        const winners = winningPlayers.map((w, i) => {\n            const amount = share + (i < remainder ? 1 : 0);\n            w.player.stack += amount;\n            return {\n                playerId: w.player.socketId,\n                playerName: w.player.name,\n                hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: w.handRank,\n                amount\n            };\n        });\n\n        room.gameState.pot = { main: 0, side: [] };\n        return winners;\n    }\n\n    /**\n     * 1äººã‚’é™¤ã„ã¦å…¨å“¡ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã—ãŸå ´åˆã®å‡¦ç†\n     * ä¸æˆ¦å‹ã®ãŸã‚ã€å‹è€…ã®ãƒãƒ³ãƒ‰ã¯è¡¨ç¤ºã—ãªã„ï¼ˆMuckæ‰±ã„ï¼‰\n     */\n    awardToLastPlayer(room: Room): ShowdownResult {\n        const lastPlayer = room.players.find(p =>\n            p !== null &&\n            (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        ) as Player | undefined;\n\n        if (!lastPlayer) {\n            return { winners: [], allHands: [] };\n        }\n\n        const totalPot = room.gameState.pot.main +\n            room.gameState.pot.side.reduce((sum, s) => sum + s.amount, 0);\n\n        lastPlayer.stack += totalPot;\n        room.gameState.pot = { main: 0, side: [] };\n\n        console.log(`ğŸ† ${lastPlayer.name} wins ${totalPot} (others folded)`);\n\n        // ä¸æˆ¦å‹: å‹è€…ã®ãƒãƒ³ãƒ‰ã¯è¡¨ç¤ºã—ãªã„ï¼ˆhand: nullï¼‰\n        // ãƒãƒ¼ã‚«ãƒ¼ãƒ«ãƒ¼ãƒ«: ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ã«é€²ã‚“ã§ã„ãªã„ãŸã‚ã€ãƒãƒ³ãƒ‰ã‚’è¦‹ã›ã‚‹ç¾©å‹™ã¯ãªã„\n        return {\n            winners: [{\n                playerId: lastPlayer.socketId,\n                playerName: lastPlayer.name,\n                hand: [],  // ç©ºé…åˆ— = ãƒãƒ³ãƒ‰éè¡¨ç¤º\n                handRank: 'Uncontested',\n                amount: totalPot\n            }],\n            allHands: []\n        };\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/index.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'processPostAction' has a complexity of 11. Maximum allowed is 10.","line":211,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":211,"endColumn":27},{"ruleId":"complexity","severity":1,"message":"Function 'handleRoomExit' has a complexity of 17. Maximum allowed is 10.","line":402,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":402,"endColumn":24},{"ruleId":"complexity","severity":1,"message":"Function 'validateDrawExchangeRequest' has a complexity of 23. Maximum allowed is 10.","line":749,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":749,"endColumn":37},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (731). Maximum allowed is 100.","line":949,"column":21,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":1679,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 14. Maximum allowed is 10.","line":956,"column":50,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":956,"endColumn":52},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":977,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":981,"endColumn":14},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 11. Maximum allowed is 10.","line":1406,"column":6,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":1406,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport { randomUUID } from 'crypto';\nimport { createServer } from 'http';\nimport { Server } from 'socket.io';\nimport cors from 'cors';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\n// ESMç”¨ã®__dirnameå–å¾—\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nimport { evaluateHand, compareHands } from './handEvaluator.js';\nimport { roomManager } from './RoomManager.js';\nimport { GameEngine } from './GameEngine.js';\nimport { ShowdownManager } from './ShowdownManager.js';\nimport { ActionValidator } from './ActionValidator.js';\nimport { Dealer } from './Dealer.js';\nimport type {\n  JoinRoomRequest,\n  SitDownRequest,\n  Player as RoomPlayer,\n  PlayerStatus,\n  ActionType\n} from './types.js';\nimport { RotationManager } from './RotationManager.js';\nimport { MetaGameManager } from './MetaGameManager.js';\nimport { PotManager } from './PotManager.js';\nimport { getVariantConfig } from './gameVariants.js';\nimport { logEvent, incrementMetric } from './logger.js';\nimport authRoutes from './auth/authRoutes.js';\nimport { verifyToken } from './auth/authService.js';\nimport { findRandomEmptySeat } from './autoSeating.js';\n\n// Phase 3-B: ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆéƒ¨å±‹ã”ã¨ã«ç®¡ç†ï¼‰\nconst gameEngines: Map<string, GameEngine> = new Map();\nconst showdownManager = new ShowdownManager();\nconst actionValidator = new ActionValidator();\nconst metaGameManager = new MetaGameManager();\nconst rotationManager = new RotationManager();\nconst potManager = new PotManager();\nconst actionTokens: Map<string, { token: string; issuedAt: number }> = new Map(); // playerId -> token meta\nconst actionInFlight: Set<string> = new Set(); // playerId in progress\nconst roomActionInFlight: Set<string> = new Set(); // roomId in progress\nconst invalidActionCounts: Map<string, { count: number; lastAt: number }> = new Map();\nconst actionRateLimit: Map<string, { count: number; windowStart: number }> = new Map();\n\n// ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†\ninterface PlayerTimer {\n  roomId: string;\n  playerId: string;\n  seconds: number;\n  intervalId: NodeJS.Timeout;\n  timeBankChips: number;\n}\nconst activeTimers: Map<string, PlayerTimer> = new Map(); // playerId -> timer\nconst playerTimeBanks: Map<string, number> = new Map(); // playerId -> chips\n\nconst MAX_TIMER_SECONDS = 30;\nconst INITIAL_TIMEBANK_CHIPS = 5;\nconst HAND_END_DELAY_MS = 2000;\nconst AUTO_START_DELAY_MS = 2000;\nconst ACTION_TOKEN_TTL_MS = 35000;\nconst ACTION_RATE_LIMIT_WINDOW_MS = 2000;\nconst ACTION_RATE_LIMIT_MAX = 6;\n\n// è‡ªå‹•ã‚²ãƒ¼ãƒ é–‹å§‹ç®¡ç†\nconst pendingStarts: Map<string, NodeJS.Timeout> = new Map();\n\nfunction cleanupSocketSession(socketId: string) {\n  clearPlayerTimer(socketId);\n  actionTokens.delete(socketId);\n  actionInFlight.delete(socketId);\n  invalidActionCounts.delete(socketId);\n  actionRateLimit.delete(socketId);\n  playerTimeBanks.delete(socketId);\n}\n\nfunction cleanupPendingLeavers(roomId: string, io: Server): boolean {\n  const room = roomManager.getRoomById(roomId);\n  if (!room) return true;\n\n  let removed = false;\n  room.players.forEach((player, index) => {\n    if (player?.pendingLeave) {\n      cleanupSocketSession(player.socketId);\n      room.players[index] = null;\n      removed = true;\n    }\n  });\n\n  if (removed) {\n    const allEmpty = room.players.every(p => p === null);\n    if (allEmpty && !room.isPreset) {\n      roomManager.deleteRoom(roomId);\n      gameEngines.delete(roomId);\n      roomActionInFlight.delete(roomId);\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n      return true;\n    }\n    io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n  }\n\n  return false;\n}\n\n// ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹é–¢æ•°\nfunction startPlayerTimer(roomId: string, playerId: string, io: Server) {\n  // æ—¢å­˜ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢\n  clearPlayerTimer(playerId);\n\n  // ã‚¿ã‚¤ãƒ ãƒãƒ³ã‚¯åˆæœŸåŒ–ï¼ˆåˆå›ã®ã¿ï¼‰\n  if (!playerTimeBanks.has(playerId)) {\n    playerTimeBanks.set(playerId, INITIAL_TIMEBANK_CHIPS);\n  }\n\n  const timer: PlayerTimer = {\n    roomId,\n    playerId,\n    seconds: MAX_TIMER_SECONDS,\n    intervalId: setInterval(() => {\n      const t = activeTimers.get(playerId);\n      if (!t) return;\n\n      t.seconds--;\n\n      // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°ã‚’é€ä¿¡\n      io.to(playerId).emit('timer-update', { seconds: t.seconds });\n\n      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®è‡ªå‹•ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n      if (t.seconds <= 0) {\n        clearPlayerTimer(playerId);\n        handleTimerTimeout(roomId, playerId, io);\n      }\n    }, 1000),\n    timeBankChips: playerTimeBanks.get(playerId) || INITIAL_TIMEBANK_CHIPS\n  };\n\n  activeTimers.set(playerId, timer);\n}\n\n// ã‚¿ã‚¤ãƒãƒ¼ã‚¯ãƒªã‚¢é–¢æ•°\nfunction clearPlayerTimer(playerId: string) {\n  const timer = activeTimers.get(playerId);\n  if (timer) {\n    clearInterval(timer.intervalId);\n    activeTimers.delete(playerId);\n  }\n}\n\n// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®è‡ªå‹•ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\nfunction handleTimerTimeout(roomId: string, playerId: string, io: Server) {\n  const room = roomManager.getRoomById(roomId);\n  if (!room) return;\n\n  const engine = gameEngines.get(roomId);\n  if (!engine) return;\n\n  const player = room.players.find(p => p?.socketId === playerId);\n  if (!player) return;\n\n  actionTokens.delete(playerId);\n\n  // ãƒã‚§ãƒƒã‚¯å¯èƒ½ãªã‚‰ãƒã‚§ãƒƒã‚¯ã€ãã†ã§ãªã‘ã‚Œã°ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰\n  const validActions = engine.getValidActions(room, playerId);\n  const actionType: ActionType = validActions.includes('CHECK') ? 'CHECK' : 'FOLD';\n\n  console.log(`â° Timer timeout for ${player.name} - Auto ${actionType}`);\n\n  const result = engine.processAction(room, {\n    playerId,\n    type: actionType,\n    timestamp: Date.now()\n  });\n\n  if (result.success) {\n    // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯ç­‰ã®å‡¦ç†ã¯ player-action ã¨åŒæ§˜ã«è¡Œã†\n    processPostAction(roomId, room, engine, io);\n  }\n}\n\nfunction issueActionToken(playerId: string): string {\n  const token = randomUUID();\n  actionTokens.set(playerId, { token, issuedAt: Date.now() });\n  return token;\n}\n\nfunction emitYourTurn(roomId: string, room: any, engine: GameEngine, io: Server, player: any) {\n  const validActions = engine.getValidActions(room, player.socketId);\n  const bettingInfo = engine.getBettingInfo(room, player.socketId);\n  const actionToken = issueActionToken(player.socketId);\n  io.to(player.socketId).emit('your-turn', {\n    validActions,\n    currentBet: room.gameState.currentBet,\n    minRaise: bettingInfo.minBet,\n    maxBet: bettingInfo.maxBet,\n    betStructure: bettingInfo.betStructure,\n    isCapped: bettingInfo.isCapped,\n    raisesRemaining: bettingInfo.raisesRemaining,\n    fixedBetSize: bettingInfo.fixedBetSize,\n    timeout: MAX_TIMER_SECONDS * 1000,\n    actionToken\n  });\n\n  startPlayerTimer(roomId, player.socketId, io);\n\n  const timeBankChips = playerTimeBanks.get(player.socketId) || INITIAL_TIMEBANK_CHIPS;\n  io.to(player.socketId).emit('timebank-update', { chips: timeBankChips });\n}\n\n// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾Œã®å…±é€šå‡¦ç†\nfunction processPostAction(roomId: string, room: any, engine: GameEngine, io: Server) {\n  // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\n  if (room.gameState.status === 'SHOWDOWN') {\n    const activePlayers = room.players.filter((p: any) =>\n      p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n    );\n\n    if (room.gameState.isRunout && activePlayers.length >= 2) {\n      // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆã®å‡¦ç†ã¯æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã«ä»»ã›ã‚‹\n      return;\n    }\n\n    let showdownResult;\n    if (activePlayers.length === 1) {\n      showdownResult = showdownManager.awardToLastPlayer(room);\n    } else {\n      const calculatedPots = potManager.calculatePots(room.players);\n      room.gameState.pot = calculatedPots;\n      showdownResult = showdownManager.executeShowdown(room);\n    }\n\n    io.to(`room:${roomId}`).emit('showdown-result', showdownResult);\n\n    // 7-2ãƒœãƒ¼ãƒŠã‚¹ãƒã‚§ãƒƒã‚¯\n    if (showdownResult.winners.length > 0) {\n      for (const winner of showdownResult.winners) {\n        const bonus = metaGameManager.checkSevenDeuce(room, winner.playerId, winner.hand);\n        if (bonus) {\n          io.to(`room:${roomId}`).emit('seven-deuce-bonus', bonus);\n        }\n      }\n    }\n\n    // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯\n    const rotation = rotationManager.checkRotation(room);\n    if (rotation.changed) {\n      io.to(`room:${roomId}`).emit('next-game', {\n        nextGame: rotation.nextGame,\n        gamesList: room.rotation.gamesList\n      });\n    }\n\n    room.gameState.status = 'WAITING' as any;\n\n    // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³å¾Œã®é…å»¶ï¼ˆ1.5ç§’ï¼‰\n    setTimeout(() => {\n      if (cleanupPendingLeavers(roomId, io)) {\n        return;\n      }\n      // æ¬¡ã®ãƒãƒ³ãƒ‰ã‚’è‡ªå‹•é–‹å§‹\n      scheduleNextHand(roomId, io);\n    }, 1500);\n  }\n\n  // å…¨å“¡ã«æ›´æ–°ã‚’é€ä¿¡\n  broadcastRoomState(roomId, room, io);\n\n  // æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n  if (room.activePlayerIndex !== -1) {\n    const nextPlayer = room.players[room.activePlayerIndex];\n    if (nextPlayer) {\n      emitYourTurn(roomId, room, engine, io, nextPlayer);\n    }\n  }\n}\n\n/**\n * è‡ªå‹•ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼\n * 2äººä»¥ä¸Šã®ACTIVEãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ã¦WAITINGçŠ¶æ…‹ãªã‚‰ã€è‡ªå‹•ã§ãƒãƒ³ãƒ‰ã‚’é–‹å§‹\n */\nfunction scheduleNextHand(roomId: string, io: Server) {\n  // æ—¢å­˜ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«\n  const existing = pendingStarts.get(roomId);\n  if (existing) {\n    clearTimeout(existing);\n    pendingStarts.delete(roomId);\n  }\n\n  const room = roomManager.getRoomById(roomId);\n  if (!room) return;\n\n  // WAITINGçŠ¶æ…‹ã§ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„\n  if (room.gameState.status !== 'WAITING') return;\n\n  // ACTIVEãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’ç¢ºèªï¼ˆpendingJoinã‚„SIT_OUTã¯é™¤ãï¼‰\n  const activePlayers = room.players.filter(p =>\n    p !== null && p.status !== 'SIT_OUT' && !p.pendingJoin && !p.pendingSitOut && !p.pendingLeave\n  );\n\n  if (activePlayers.length < 2) return;\n\n  const timeout = setTimeout(() => {\n    pendingStarts.delete(roomId);\n\n    const currentRoom = roomManager.getRoomById(roomId);\n    if (!currentRoom || currentRoom.gameState.status !== 'WAITING') return;\n\n    // å†åº¦ACTIVEãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’ãƒã‚§ãƒƒã‚¯\n    const readyPlayers = currentRoom.players.filter(p =>\n      p !== null && p.status !== 'SIT_OUT' && !p.pendingJoin && !p.pendingSitOut && !p.pendingLeave\n    );\n    if (readyPlayers.length < 2) return;\n\n    // GameEngineã‚’å–å¾—ã¾ãŸã¯ä½œæˆ\n    let engine = gameEngines.get(roomId);\n    if (!engine) {\n      engine = new GameEngine();\n      gameEngines.set(roomId, engine);\n    }\n\n    // ãƒãƒ³ãƒ‰ã‚’é–‹å§‹\n    const success = engine.startHand(currentRoom);\n    if (!success) return;\n\n    // å…¨å“¡ã«ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã¨è‡ªåˆ†ã®ãƒãƒ³ãƒ‰ã‚’é€ä¿¡\n    for (const player of currentRoom.players) {\n      if (player) {\n        io.to(player.socketId).emit('game-started', {\n          room: sanitizeRoomForViewer(currentRoom, player.socketId),\n          yourHand: player.hand\n        });\n      }\n    }\n\n    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n    const activePlayer = currentRoom.players[currentRoom.activePlayerIndex];\n    if (activePlayer) {\n      emitYourTurn(roomId, currentRoom, engine, io, activePlayer);\n    }\n\n    console.log(`ğŸ® Auto-started game in room ${roomId}`);\n    logEvent('auto_start', { roomId, playerCount: readyPlayers.length });\n    incrementMetric('auto_start');\n  }, AUTO_START_DELAY_MS);\n\n  pendingStarts.set(roomId, timeout);\n}\n\n/**\n * ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚µãƒ‹ã‚¿ã‚¤ã‚ºï¼ˆä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®handã‚’éš ã™ï¼‰\n * @param room ãƒ«ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ\n * @param viewerSocketId é–²è¦§è€…ã®socketIdï¼ˆã“ã®äººã«ã¯è‡ªåˆ†ã®æ‰‹æœ­ãŒè¦‹ãˆã‚‹ï¼‰\n */\nfunction sanitizeRoomForViewer(room: any, viewerSocketId?: string): any {\n  return {\n    ...room,\n    players: room.players.map((p: any) => {\n      if (!p) return null;\n      const isOwnPlayer = viewerSocketId && p.socketId === viewerSocketId;\n\n      // Studç”¨: 4thã‚¹ãƒˆãƒªãƒ¼ãƒˆã®ã‚«ãƒ¼ãƒ‰ï¼ˆstudUpCards[1]ï¼‰ã¯ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã¯è¦‹ã›ãªã„\n      // è‡ªåˆ†ã«ã¯å…¨ã¦è¦‹ãˆã‚‹ã€ä»–è€…ã«ã¯ãƒ‰ã‚¢ã‚«ãƒ¼ãƒ‰(0)ã¨5th(2)ã€6th(3)ã®ã¿\n      let visibleUpCards = p.studUpCards || [];\n      if (!isOwnPlayer && visibleUpCards.length > 1) {\n        // 4thã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚«ãƒ¼ãƒ‰ï¼ˆindex 1ï¼‰ã‚’é™¤å¤–\n        visibleUpCards = visibleUpCards.filter((_: any, i: number) => i !== 1);\n      }\n\n      return {\n        ...p,\n        // è‡ªåˆ†ä»¥å¤–ã®handã¯éš ã™\n        hand: isOwnPlayer ? p.hand : null,\n        // studUpCardsã¯4thã‚¹ãƒˆãƒªãƒ¼ãƒˆä»¥å¤–ã‚’ä»–è€…ã«å…¬é–‹\n        studUpCards: visibleUpCards\n      };\n    })\n  };\n}\n\nfunction broadcastRoomState(roomId: string, room: any, io: Server) {\n  void io.in(`room:${roomId}`).fetchSockets()\n    .then(sockets => {\n      for (const sock of sockets) {\n        sock.emit('room-state-update', sanitizeRoomForViewer(room, sock.id));\n      }\n    })\n    .catch(error => {\n      console.error('âŒ Failed to broadcast room-state-update', {\n        roomId,\n        error: error instanceof Error ? error.message : error\n      });\n    });\n}\n\n// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: socketã‹ã‚‰roomIdã‚’å–å¾—\nfunction getRoomIdFromSocket(socket: any): string | null {\n  const rooms = Array.from(socket.rooms) as string[];\n  const roomEntry = rooms.find((r: string) => r.startsWith('room:'));\n  return roomEntry ? roomEntry.slice(5) : null;\n}\n\nfunction handleRoomExit(\n  socket: any,\n  roomId: string,\n  io: Server,\n  options: { leaveRoom?: boolean } = {}\n) {\n  const room = roomManager.getRoomById(roomId);\n  cleanupSocketSession(socket.id);\n  const leaveRoom = options.leaveRoom !== false;\n\n  if (!room) {\n    if (leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n    return;\n  }\n\n  const seatIndex = room.players.findIndex(p => p?.socketId === socket.id);\n  if (seatIndex === -1) {\n    if (leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n    return;\n  }\n\n  const player = room.players[seatIndex]!;\n  const isInHand = room.gameState.status !== 'WAITING';\n\n  if (isInHand) {\n    player.pendingLeave = true;\n    player.pendingSitOut = true;\n    player.pendingJoin = false;\n    player.waitingForBB = false;\n    player.disconnected = true;\n\n    const engine = gameEngines.get(roomId);\n    const isActivePlayer = room.activePlayerIndex === seatIndex;\n    let actionProcessed = false;\n\n    if (engine && isActivePlayer && player.status === 'ACTIVE') {\n      const result = engine.processAction(room, {\n        playerId: socket.id,\n        type: 'FOLD' as ActionType,\n        timestamp: Date.now()\n      });\n\n      if (result.success) {\n        processPostAction(roomId, room, engine, io);\n        actionProcessed = true;\n      } else {\n        player.status = 'FOLDED';\n      }\n    } else if (player.status === 'ACTIVE') {\n      player.status = 'FOLDED';\n    }\n\n    if (leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n    if (!actionProcessed) {\n      broadcastRoomState(roomId, room, io);\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n    }\n    return;\n  }\n\n  roomManager.standUp(roomId, socket.id);\n  if (leaveRoom) {\n    socket.leave(`room:${roomId}`);\n  }\n\n  const roomStillExists = roomManager.getRoomById(roomId);\n  if (roomStillExists) {\n    broadcastRoomState(roomId, roomStillExists, io);\n  } else {\n    gameEngines.delete(roomId);\n    roomActionInFlight.delete(roomId);\n    if (!leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n  }\n\n  io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n}\n\nfunction getRoomIdOrError(socket: any): string | null {\n  const roomId = getRoomIdFromSocket(socket);\n  if (!roomId) {\n    socket.emit('error', { message: 'You are not in any room' });\n    return null;\n  }\n  return roomId;\n}\n\nfunction getRoomOrError(roomId: string, socket: any) {\n  const room = roomManager.getRoomById(roomId);\n  if (!room) {\n    socket.emit('error', { message: 'Room not found' });\n    return null;\n  }\n  return room;\n}\n\nfunction getEngineOrError(roomId: string, socket: any) {\n  const engine = gameEngines.get(roomId);\n  if (!engine) {\n    socket.emit('error', { message: 'Game not started' });\n    return null;\n  }\n  return engine;\n}\n\nfunction checkActionRateLimit(socket: any, roomId: string, now: number): boolean {\n  const rate = actionRateLimit.get(socket.id);\n  if (!rate || now - rate.windowStart > ACTION_RATE_LIMIT_WINDOW_MS) {\n    actionRateLimit.set(socket.id, { count: 1, windowStart: now });\n    return true;\n  }\n\n  rate.count += 1;\n  if (rate.count > ACTION_RATE_LIMIT_MAX) {\n    const ip = socket.handshake.address;\n    console.warn(`âš ï¸ Rate limit: ${socket.id} (${ip}) ${rate.count}/${ACTION_RATE_LIMIT_WINDOW_MS}ms`);\n    socket.emit('action-invalid', { reason: 'Too many actions' });\n    logEvent('rate_limited', { roomId, playerId: socket.id, ip, count: rate.count });\n    incrementMetric('rate_limited');\n    return false;\n  }\n\n  return true;\n}\n\nfunction validateActionToken(socket: any, roomId: string, token: string | undefined, now: number): boolean {\n  const expectedToken = actionTokens.get(socket.id);\n  if (!token || !expectedToken || token !== expectedToken.token) {\n    socket.emit('action-invalid', { reason: 'Invalid action token' });\n    logEvent('action_invalid', { roomId, playerId: socket.id, reason: 'Invalid action token' });\n    incrementMetric('action_invalid', { reason: 'invalid_token' });\n    const stats = invalidActionCounts.get(socket.id);\n    if (!stats || now - stats.lastAt > 5000) {\n      invalidActionCounts.set(socket.id, { count: 1, lastAt: now });\n    } else {\n      stats.count += 1;\n      stats.lastAt = now;\n      if (stats.count >= 3) {\n        console.warn(`âš ï¸ Repeated invalid actions from ${socket.id} (${stats.count} in 5s)`);\n        logEvent('invalid_action_spam', { roomId, playerId: socket.id, count: stats.count });\n        incrementMetric('invalid_action_spam');\n      }\n    }\n    return false;\n  }\n\n  if (now - expectedToken.issuedAt > ACTION_TOKEN_TTL_MS) {\n    actionTokens.delete(socket.id);\n    socket.emit('action-invalid', { reason: 'Action token expired' });\n    logEvent('action_invalid', { roomId, playerId: socket.id, reason: 'Action token expired' });\n    incrementMetric('action_invalid', { reason: 'token_expired' });\n    return false;\n  }\n\n  return true;\n}\n\nfunction validatePlayerActionRequest(\n  socket: any,\n  data: { type: ActionType; amount?: number; actionToken?: string }\n): { roomId: string; room: any; engine: GameEngine } | null {\n  const roomId = getRoomIdOrError(socket);\n  if (!roomId) return null;\n  const room = getRoomOrError(roomId, socket);\n  if (!room) return null;\n  const engine = getEngineOrError(roomId, socket);\n  if (!engine) return null;\n\n  if (roomActionInFlight.has(roomId)) {\n    socket.emit('action-invalid', { reason: 'Room is processing another action' });\n    return null;\n  }\n\n  if (room.gameState.isDrawPhase) {\n    socket.emit('action-invalid', { reason: 'Draw phase in progress' });\n    logEvent('action_invalid', { roomId, playerId: socket.id, reason: 'Draw phase in progress' });\n    incrementMetric('action_invalid', { reason: 'draw_phase' });\n    return null;\n  }\n\n  const now = Date.now();\n  if (!checkActionRateLimit(socket, roomId, now)) {\n    return null;\n  }\n  if (!validateActionToken(socket, roomId, data.actionToken, now)) {\n    return null;\n  }\n\n  if (actionInFlight.has(socket.id)) {\n    socket.emit('action-invalid', { reason: 'Action already in progress' });\n    return null;\n  }\n\n  return { roomId, room, engine };\n}\n\nfunction handleAllInRunout(roomId: string, room: any, io: Server) {\n  const runoutPhase = room.gameState.runoutPhase || 'PREFLOP';\n  const board = room.gameState.board;\n  const DELAY = 1500; // 1.5ç§’\n\n  console.log(`ğŸ¬ Starting all-in runout from ${runoutPhase}`);\n\n  io.to(`room:${roomId}`).emit('runout-started', {\n    runoutPhase,\n    fullBoard: board\n  });\n\n  const scheduleRunout = async () => {\n    if (runoutPhase === 'PREFLOP') {\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 3), phase: 'FLOP' });\n\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 4), phase: 'TURN' });\n\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 5), phase: 'RIVER' });\n\n    } else if (runoutPhase === 'FLOP') {\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 4), phase: 'TURN' });\n\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 5), phase: 'RIVER' });\n\n    } else if (runoutPhase === 'TURN') {\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 5), phase: 'RIVER' });\n    }\n\n    await new Promise(r => setTimeout(r, DELAY));\n\n    const calculatedPots = potManager.calculatePots(room.players);\n    room.gameState.pot = calculatedPots;\n    console.log(`ğŸ’° Pots calculated: Main=${calculatedPots.main}, Sides=${calculatedPots.side.map(s => s.amount).join(',')}`);\n\n    const showdownResult = showdownManager.executeShowdown(room);\n    io.to(`room:${roomId}`).emit('showdown-result', showdownResult);\n\n    if (showdownResult.winners.length > 0) {\n      for (const winner of showdownResult.winners) {\n        const bonus = metaGameManager.checkSevenDeuce(room, winner.playerId, winner.hand);\n        if (bonus) {\n          io.to(`room:${roomId}`).emit('seven-deuce-bonus', bonus);\n          console.log(`ğŸ² 7-2 BONUS: ${winner.playerName} wins ${bonus.amount}`);\n        }\n      }\n    }\n\n    const rotation = rotationManager.checkRotation(room);\n    if (rotation.changed) {\n      console.log(`ğŸ”„ Next game: ${rotation.nextGame}`);\n      io.to(`room:${roomId}`).emit('next-game', {\n        nextGame: rotation.nextGame,\n        gamesList: room.rotation.gamesList\n      });\n    }\n\n    room.gameState.isRunout = false;\n    room.gameState.runoutPhase = undefined;\n    room.gameState.status = 'WAITING' as any;\n\n    broadcastRoomState(roomId, room, io);\n\n    setTimeout(() => {\n      if (cleanupPendingLeavers(roomId, io)) {\n        return;\n      }\n      scheduleNextHand(roomId, io);\n    }, 1500);\n  };\n\n  scheduleRunout();\n}\n\nfunction handleNormalShowdown(roomId: string, room: any, io: Server) {\n  let showdownResult;\n  const activePlayers = room.players.filter(p =>\n    p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n  );\n\n  if (activePlayers.length === 1) {\n    showdownResult = showdownManager.awardToLastPlayer(room);\n  } else {\n    const calculatedPots = potManager.calculatePots(room.players);\n    room.gameState.pot = calculatedPots;\n    console.log(`ğŸ’° Pots calculated: Main=${calculatedPots.main}, Sides=${calculatedPots.side.map(s => s.amount).join(',')}`);\n    showdownResult = showdownManager.executeShowdown(room);\n  }\n\n  io.to(`room:${roomId}`).emit('showdown-result', showdownResult);\n\n  if (showdownResult.winners.length > 0) {\n    for (const winner of showdownResult.winners) {\n      const bonus = metaGameManager.checkSevenDeuce(room, winner.playerId, winner.hand);\n      if (bonus) {\n        io.to(`room:${roomId}`).emit('seven-deuce-bonus', bonus);\n        console.log(`ğŸ² 7-2 BONUS: ${winner.playerName} wins ${bonus.amount}`);\n      }\n    }\n  }\n\n  const rotation = rotationManager.checkRotation(room);\n  if (rotation.changed) {\n    console.log(`ğŸ”„ Next game: ${rotation.nextGame}`);\n    io.to(`room:${roomId}`).emit('next-game', {\n      nextGame: rotation.nextGame,\n      gamesList: room.rotation.gamesList\n    });\n  }\n\n  room.gameState.status = 'WAITING' as any;\n\n  setTimeout(() => {\n    if (cleanupPendingLeavers(roomId, io)) {\n      return;\n    }\n    scheduleNextHand(roomId, io);\n  }, 1500);\n}\n\nfunction maybeHandleShowdown(roomId: string, room: any, io: Server): boolean {\n  if (room.gameState.status !== 'SHOWDOWN') {\n    return false;\n  }\n\n  const activePlayers = room.players.filter(p =>\n    p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n  );\n\n  if (room.gameState.isRunout && activePlayers.length >= 2) {\n    handleAllInRunout(roomId, room, io);\n    return true;\n  }\n\n  handleNormalShowdown(roomId, room, io);\n  return false;\n}\n\nfunction validateDrawExchangeRequest(\n  socket: any,\n  data: { discardIndexes: number[] }\n): { roomId: string; room: any; engine: GameEngine; player: RoomPlayer; discardIndexes: number[] } | null {\n  const roomId = getRoomIdOrError(socket);\n  if (!roomId) return null;\n  const room = getRoomOrError(roomId, socket);\n  if (!room) return null;\n  const engine = getEngineOrError(roomId, socket);\n  if (!engine) return null;\n\n  const player = room.players.find(p => p?.socketId === socket.id);\n  if (!player) {\n    socket.emit('error', { message: 'Player not found' });\n    return null;\n  }\n\n  const status = room.gameState.status;\n  const isDrawPhase = room.gameState.isDrawPhase;\n  if (!isDrawPhase || (status !== 'FIRST_DRAW' && status !== 'SECOND_DRAW' && status !== 'THIRD_DRAW')) {\n    socket.emit('error', { message: 'Not in draw exchange phase' });\n    return null;\n  }\n\n  if (player.status !== 'ACTIVE' && player.status !== 'ALL_IN') {\n    socket.emit('error', { message: 'You cannot draw' });\n    return null;\n  }\n\n  const completedDraw = room.gameState.playersCompletedDraw || [];\n  if (completedDraw.includes(socket.id)) {\n    socket.emit('error', { message: 'You have already drawn this round' });\n    return null;\n  }\n\n  const variantConfig = getVariantConfig(room.gameState.gameVariant);\n  const maxDrawCount = variantConfig.maxDrawCount ?? player.hand?.length ?? 0;\n  const discardIndexes = Array.isArray(data.discardIndexes) ? data.discardIndexes : [];\n  const uniqueIndexes = new Set<number>();\n  for (const idx of discardIndexes) {\n    if (!Number.isInteger(idx)) {\n      socket.emit('error', { message: 'Invalid discard index' });\n      return null;\n    }\n    uniqueIndexes.add(idx);\n  }\n  if (discardIndexes.length !== uniqueIndexes.size) {\n    socket.emit('error', { message: 'Duplicate discard indexes' });\n    return null;\n  }\n  if (discardIndexes.length > maxDrawCount) {\n    socket.emit('error', { message: `Too many cards to discard (max ${maxDrawCount})` });\n    return null;\n  }\n  if (!player.hand || discardIndexes.some(idx => idx < 0 || idx >= player.hand.length)) {\n    socket.emit('error', { message: 'Discard index out of range' });\n    return null;\n  }\n\n  return { roomId, room, engine, player, discardIndexes };\n}\n\nfunction validateQuickJoinBuyIn(room: any, buyIn: number, socket: any): boolean {\n  const minBuyIn = room.config.buyInMin || room.config.bigBlind * 20;\n  const maxBuyIn = room.config.buyInMax || room.config.bigBlind * 100;\n  if (buyIn < minBuyIn || buyIn > maxBuyIn) {\n    socket.emit('error', { message: `Buy-in must be between ${minBuyIn} and ${maxBuyIn}` });\n    return false;\n  }\n  return true;\n}\n\nfunction removeExistingPlayerSession(room: any, socket: any, user: any, roomId: string) {\n  const existingPlayerIndex = room.players.findIndex(p => {\n    if (!p) return false;\n    if (p.socketId === socket.id) return true;\n    if (user?.userId && p.userId === user.userId) return true;\n    return false;\n  });\n\n  if (existingPlayerIndex === -1) return;\n\n  const oldPlayer = room.players[existingPlayerIndex]!;\n  console.log(`ğŸ”„ Removing old session for ${oldPlayer.name} (old: ${oldPlayer.socketId}, new: ${socket.id})`);\n\n  if (room.gameState.status !== 'WAITING') {\n    const engine = gameEngines.get(roomId);\n    if (engine && room.activePlayerIndex === existingPlayerIndex && oldPlayer.status === 'ACTIVE') {\n      engine.processAction(room, {\n        playerId: oldPlayer.socketId,\n        type: 'FOLD' as ActionType,\n        timestamp: Date.now()\n      });\n    }\n  }\n\n  room.players[existingPlayerIndex] = null;\n}\n\nfunction createQuickJoinPlayer(socket: any, user: any, room: any, buyIn: number): RoomPlayer {\n  const variantConfig = getVariantConfig(room.gameState.gameVariant);\n  const isWaiting = room.gameState.status === 'WAITING';\n  return {\n    socketId: socket.id,\n    name: user?.displayName || 'Guest',\n    stack: buyIn,\n    bet: 0,\n    totalBet: 0,\n    status: (isWaiting ? 'ACTIVE' : 'SIT_OUT') as PlayerStatus,\n    hand: null,\n    pendingJoin: !isWaiting,\n    waitingForBB: !isWaiting && variantConfig.hasButton,\n    disconnected: false,\n    userId: user?.userId,\n    avatarIcon: user?.avatarIcon\n  };\n}\n\nconst app = express();\nconst isProduction = process.env.NODE_ENV === 'production';\n\n// CORSè¨­å®š: æœ¬ç•ªç’°å¢ƒã§ã¯åŒä¸€ã‚ªãƒªã‚¸ãƒ³ã€é–‹ç™ºç’°å¢ƒã§ã¯è¤‡æ•°ãƒãƒ¼ãƒˆè¨±å¯\nconst ALLOWED_ORIGINS: string[] = isProduction\n  ? [process.env.CLIENT_URL].filter((url): url is string => Boolean(url))\n  : [\n      'http://localhost:5173',\n      'http://localhost:5174',\n      'http://localhost:5175',\n      process.env.CLIENT_URL\n    ].filter((url): url is string => Boolean(url));\n\napp.use(cors({\n  origin: (origin, callback) => {\n    // originãŒãªã„å ´åˆï¼ˆåŒä¸€ã‚ªãƒªã‚¸ãƒ³ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼‰ã¾ãŸã¯è¨±å¯ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã‚‹å ´åˆã¯è¨±å¯\n    if (!origin || ALLOWED_ORIGINS.includes(origin) || isProduction) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true\n}));\n\n// JSON bodyãƒ‘ãƒ¼ã‚µãƒ¼\napp.use(express.json());\n\n// èªè¨¼APIãƒ«ãƒ¼ãƒˆ\napp.use('/api/auth', authRoutes);\n\n// ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆå…¨ç’°å¢ƒå…±é€šï¼‰\napp.get('/api/health', (_req, res) => {\n  res.json({ status: 'ok', message: 'Mix Poker Game Server is running' });\n});\n\n// æœ¬ç•ªç’°å¢ƒ: é™çš„ãƒ•ã‚¡ã‚¤ãƒ«é…ä¿¡\nif (isProduction) {\n  const clientDistPath = path.join(__dirname, '../../client/dist');\n  app.use(express.static(clientDistPath));\n\n  // APIä»¥å¤–ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯index.htmlã‚’è¿”ã™ï¼ˆSPAå¯¾å¿œï¼‰\n  // Express 5ã§ã¯ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã«åå‰ä»˜ããƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¿…è¦\n  app.get('/{*splat}', (req, res, next) => {\n    // Socket.IOã‚„APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯é™¤å¤–\n    if (req.path.startsWith('/socket.io') || req.path.startsWith('/api/')) {\n      return next();\n    }\n    res.sendFile(path.join(clientDistPath, 'index.html'));\n  });\n} else {\n  app.get('/', (req, res) => {\n    res.json({ status: 'ok', message: 'Mix Poker Game Server is running' });\n  });\n}\n\nconst httpServer = createServer(app);\n// Socket.ioã®è¨­å®š (CORSè¨±å¯)\nconst io = new Server(httpServer, {\n  cors: {\n    origin: ALLOWED_ORIGINS,\n    methods: [\"GET\", \"POST\"],\n    credentials: true\n  }\n});\n\n// Socket.IOèªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢\nio.use((socket, next) => {\n  const token = socket.handshake.auth?.token;\n  if (token) {\n    const user = verifyToken(token);\n    if (user) {\n      socket.data.user = user;\n      return next();\n    }\n  }\n  // èªè¨¼ãªã—ã§ã‚‚æ¥ç¶šã‚’è¨±å¯ï¼ˆã‚²ã‚¹ãƒˆå¯¾å¿œã®ä½™åœ°ï¼‰\n  // ãŸã ã—useræƒ…å ±ã¯null\n  socket.data.user = null;\n  next();\n});\n\nio.on('connection', (socket) => {\n  const user = socket.data.user;\n  console.log(`ğŸ”¥ Player connected! ID: ${socket.id}, User: ${user?.displayName || 'Guest'}`);\n\n  // ========== Room Management Events ==========\n\n  // éƒ¨å±‹å‚åŠ \n  socket.on('join-room', (data: JoinRoomRequest) => {\n    try {\n      const existingRoomId = getRoomIdFromSocket(socket);\n      if (existingRoomId && existingRoomId !== data.roomId) {\n        handleRoomExit(socket, existingRoomId, io);\n      }\n\n      const room = roomManager.getRoomById(data.roomId);\n\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      if (data.resumeToken) {\n        const existingPlayer = room.players.find(p => p?.resumeToken === data.resumeToken);\n        if (existingPlayer) {\n          const previousSocketId = existingPlayer.socketId;\n          if (previousSocketId !== socket.id) {\n            cleanupSocketSession(previousSocketId);\n            const oldSocket = io.sockets.sockets.get(previousSocketId);\n            if (oldSocket) {\n              oldSocket.leave(`room:${data.roomId}`);\n              oldSocket.emit('error', { message: 'Session replaced by reconnection' });\n              oldSocket.disconnect(true);\n            }\n          }\n\n          existingPlayer.socketId = socket.id;\n          existingPlayer.disconnected = false;\n          (socket.data as any).playerName = existingPlayer.name;\n          if (room.gameState.status === 'WAITING' && existingPlayer.status === 'SIT_OUT' && !existingPlayer.pendingSitOut) {\n            existingPlayer.status = 'ACTIVE';\n          } else if (room.gameState.status !== 'WAITING') {\n            existingPlayer.pendingJoin = true;\n          }\n\n          socket.join(`room:${data.roomId}`);\n          (socket.data as any).roomId = data.roomId;\n          socket.emit('room-joined', {\n            room: sanitizeRoomForViewer(room, socket.id),\n            yourSocketId: socket.id,\n            yourHand: existingPlayer.hand || null\n          });\n          logEvent('room_resumed', { roomId: data.roomId, playerName: existingPlayer.name });\n          incrementMetric('room_resumed');\n          broadcastRoomState(data.roomId, room, io);\n          return;\n        }\n      }\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’socket.dataã«ä¿å­˜ï¼ˆsit-downæ™‚ã«ä½¿ç”¨ï¼‰\n      (socket.data as any).playerName = data.playerName;\n\n      // Socket.IOã®ãƒ«ãƒ¼ãƒ ã«å‚åŠ \n      socket.join(`room:${data.roomId}`);\n      (socket.data as any).roomId = data.roomId;\n      (socket.data as any).roomId = data.roomId;\n\n      socket.emit('room-joined', {\n        room: sanitizeRoomForViewer(room, socket.id),\n        yourSocketId: socket.id,\n        yourHand: null\n      });\n\n      console.log(`ğŸšª ${data.playerName} joined room ${data.roomId}`);\n      logEvent('room_joined', { roomId: data.roomId, playerName: data.playerName });\n      incrementMetric('room_joined');\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // éƒ¨å±‹ãƒªã‚¹ãƒˆå–å¾—ï¼ˆãƒ­ãƒ“ãƒ¼ç”¨ï¼‰\n  socket.on('get-room-list', () => {\n    // ãƒ­ãƒ“ãƒ¼ã®Socket.IOãƒ«ãƒ¼ãƒ ã«å‚åŠ \n    socket.join('lobby');\n    socket.emit('room-list-update', roomManager.getAllRooms());\n  });\n\n  // éƒ¨å±‹é€€å‡º\n  socket.on('leave-room', () => {\n    const roomId = getRoomIdFromSocket(socket);\n    if (!roomId) return;\n    try {\n      handleRoomExit(socket, roomId, io, { leaveRoom: true });\n      if ((socket.data as any).roomId === roomId) {\n        delete (socket.data as any).roomId;\n      }\n    } catch (error) {\n      // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–\n    }\n  });\n\n  // ç€å¸­\n  socket.on('sit-down', (data: SitDownRequest) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // socket.dataã«playerNameã‚’ä¿å­˜ã—ã¦ãŠãï¼ˆjoin-roomæ™‚ã«è¨­å®šã™ã‚‹ã“ã¨ã‚’æƒ³å®šï¼‰\n      const playerName = (socket.data as any).playerName || 'Anonymous';\n      const variantConfig = getVariantConfig(room.gameState.gameVariant);\n      const isWaiting = room.gameState.status === 'WAITING';\n\n      // ç€å¸­ã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’ä½œæˆ\n      const player: RoomPlayer = {\n        socketId: socket.id,\n        name: playerName,\n        stack: data.buyIn,\n        bet: 0,\n        totalBet: 0,\n        status: (isWaiting ? 'ACTIVE' : 'SIT_OUT') as PlayerStatus,\n        hand: null,\n        resumeToken: data.resumeToken,\n        pendingJoin: !isWaiting,\n        waitingForBB: !isWaiting && variantConfig.hasButton,\n        disconnected: false\n      };\n\n      roomManager.sitDown(roomId, data.seatIndex, player);\n\n      console.log(`âœ… ${playerName} sat down at seat ${data.seatIndex}`);\n      logEvent('sit_down', { roomId, playerName, seatIndex: data.seatIndex });\n      incrementMetric('sit_down');\n\n      // ç€å¸­æˆåŠŸã‚’é€šçŸ¥ï¼ˆæœ¬äººï¼‰\n      socket.emit('sit-down-success', { seatIndex: data.seatIndex });\n\n      // éƒ¨å±‹å†…ã®å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n\n      // ãƒ­ãƒ“ãƒ¼ã«éƒ¨å±‹ãƒªã‚¹ãƒˆæ›´æ–°ã‚’é€šçŸ¥\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n\n    } catch (error: any) {\n      console.error(`âŒ Sit-down failed: ${error.message}`);\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ã‚¯ã‚¤ãƒƒã‚¯å‚åŠ ï¼ˆjoin-room + è‡ªå‹•ç€å¸­ã‚’1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ï¼‰\n  socket.on('quick-join', (data: { roomId: string; buyIn: number }) => {\n    try {\n      // æ—¢ã«åˆ¥ã®éƒ¨å±‹ã«ã„ã‚‹å ´åˆã¯é€€å‡º\n      const existingRoomId = getRoomIdFromSocket(socket);\n      if (existingRoomId && existingRoomId !== data.roomId) {\n        handleRoomExit(socket, existingRoomId, io);\n      }\n\n      const room = roomManager.getRoomById(data.roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ãƒã‚¤ã‚¤ãƒ³é¡ãƒã‚§ãƒƒã‚¯\n      if (!validateQuickJoinBuyIn(room, data.buyIn, socket)) {\n        return;\n      }\n\n      // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—\n      const user = socket.data?.user;\n      const playerName = user?.displayName || 'Guest';\n\n      removeExistingPlayerSession(room, socket, user, data.roomId);\n\n      // ç©ºå¸­ã‚’æ¢ã™\n      const seatIndex = findRandomEmptySeat(room.players);\n      if (seatIndex === null) {\n        socket.emit('error', { message: 'Room is full' });\n        return;\n      }\n\n      // socket.dataã«playerNameã‚’ä¿å­˜\n      (socket.data as any).playerName = playerName;\n\n      // Socket.IOã®ãƒ«ãƒ¼ãƒ ã«å‚åŠ \n      socket.join(`room:${data.roomId}`);\n      (socket.data as any).roomId = data.roomId;\n      // ãƒ­ãƒ“ãƒ¼ã‹ã‚‰é›¢è„±\n      socket.leave('lobby');\n\n      const player = createQuickJoinPlayer(socket, user, room, data.buyIn);\n\n      roomManager.sitDown(data.roomId, seatIndex, player);\n\n      console.log(`âš¡ ${playerName} quick-joined room ${data.roomId} at seat ${seatIndex}`);\n      logEvent('quick_join', { roomId: data.roomId, playerName, seatIndex, buyIn: data.buyIn });\n      incrementMetric('quick_join');\n\n      // å‚åŠ æˆåŠŸã‚’é€šçŸ¥ï¼ˆæœ¬äººï¼‰\n      socket.emit('room-joined', {\n        room: sanitizeRoomForViewer(room, socket.id),\n        yourSocketId: socket.id,\n        yourHand: null\n      });\n      socket.emit('sit-down-success', { seatIndex });\n\n      // éƒ¨å±‹å†…ã®å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(data.roomId, room, io);\n\n      // ãƒ­ãƒ“ãƒ¼ã«éƒ¨å±‹ãƒªã‚¹ãƒˆæ›´æ–°ã‚’é€šçŸ¥\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n\n      // è‡ªå‹•ã‚²ãƒ¼ãƒ é–‹å§‹ãƒã‚§ãƒƒã‚¯\n      scheduleNextHand(data.roomId, io);\n\n    } catch (error: any) {\n      console.error(`âŒ Quick-join failed: ${error.message}`);\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒªãƒã‚¤ï¼ˆãƒãƒƒãƒ—è¿½åŠ ï¼‰\n  socket.on('rebuy', (data: { amount: number }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™\n      const player = room.players.find(p => p?.socketId === socket.id);\n      if (!player) {\n        socket.emit('error', { message: 'You are not seated' });\n        return;\n      }\n\n      // ã‚²ãƒ¼ãƒ ä¸­ã¯ãƒªãƒã‚¤ä¸å¯\n      if (room.gameState.status !== 'WAITING') {\n        socket.emit('error', { message: 'Cannot rebuy during a hand' });\n        return;\n      }\n\n      // é‡‘é¡ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³\n      const newStack = player.stack + data.amount;\n      const buyInMin = room.config.buyInMin ?? room.config.bigBlind * 20;\n      const buyInMax = room.config.buyInMax ?? room.config.bigBlind * 200;\n      if (newStack < buyInMin) {\n        socket.emit('error', { message: `Minimum buy-in is ${buyInMin}` });\n        return;\n      }\n      if (newStack > buyInMax) {\n        socket.emit('error', { message: `Maximum buy-in is ${buyInMax}` });\n        return;\n      }\n\n      // ãƒªãƒã‚¤å®Ÿè¡Œ\n      player.stack = newStack;\n      console.log(`ğŸ’° ${player.name} rebought for ${data.amount} (new stack: ${newStack})`);\n\n      // ãƒªãƒã‚¤æˆåŠŸã‚’é€šçŸ¥\n      socket.emit('rebuy-success', { amount: data.amount, newStack });\n\n      // éƒ¨å±‹å†…ã®å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n\n      // ã‚²ãƒ¼ãƒ é–‹å§‹ãƒã‚§ãƒƒã‚¯ï¼ˆãƒªãƒã‚¤å¾Œã«äººæ•°ãŒæƒã£ãŸå ´åˆï¼‰\n      scheduleNextHand(roomId, io);\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ========== Phase 3-B: Game Engine Events ==========\n\n  // ã‚¿ã‚¤ãƒ ãƒãƒ³ã‚¯ä½¿ç”¨\n  socket.on('use-timebank', () => {\n    try {\n      const timer = activeTimers.get(socket.id);\n      if (!timer) {\n        socket.emit('error', { message: 'No active timer' });\n        return;\n      }\n\n      const currentChips = playerTimeBanks.get(socket.id) || 0;\n      if (currentChips <= 0) {\n        socket.emit('error', { message: 'No time bank chips remaining' });\n        return;\n      }\n\n      // ã‚¿ã‚¤ãƒ ãƒãƒ³ã‚¯ãƒãƒƒãƒ—ã‚’æ¶ˆè²»ã—ã¦30ç§’è¿½åŠ \n      playerTimeBanks.set(socket.id, currentChips - 1);\n      timer.seconds += 30;\n\n      console.log(`â±ï¸ Time bank used by ${socket.id} (${currentChips - 1} chips remaining)`);\n\n      // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æ›´æ–°ã‚’é€šçŸ¥\n      socket.emit('timer-update', { seconds: timer.seconds });\n      socket.emit('timebank-update', { chips: currentChips - 1 });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n  socket.on('player-action', (data: { type: ActionType; amount?: number; actionToken?: string }) => {\n    try {\n      const context = validatePlayerActionRequest(socket, data);\n      if (!context) return;\n      const { roomId, room, engine } = context;\n\n      // ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢\n      clearPlayerTimer(socket.id);\n\n      actionInFlight.add(socket.id);\n      roomActionInFlight.add(roomId);\n      let result;\n      try {\n        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‡¦ç†\n        result = engine.processAction(room, {\n          playerId: socket.id,\n          type: data.type,\n          amount: data.amount,\n          timestamp: Date.now()\n        });\n      } finally {\n        actionInFlight.delete(socket.id);\n        roomActionInFlight.delete(roomId);\n      }\n\n      if (!result.success) {\n        socket.emit('action-invalid', { reason: result.error });\n        logEvent('action_invalid', { roomId, playerId: socket.id, reason: result.error });\n        incrementMetric('action_invalid', { reason: 'engine_reject' });\n        startPlayerTimer(roomId, socket.id, io);\n        return;\n      }\n      actionTokens.delete(socket.id);\n\n      // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\n      if (maybeHandleShowdown(roomId, room, io)) {\n        return;\n      }\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€ä¿¡\n      broadcastRoomState(roomId, room, io);\n\n      // æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n      if (room.activePlayerIndex !== -1) {\n        const nextPlayer = room.players[room.activePlayerIndex];\n        if (nextPlayer) {\n          emitYourTurn(roomId, room, engine, io, nextPlayer);\n        }\n      }\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ‰ãƒ­ãƒ¼äº¤æ›ï¼ˆ2-7 Triple Draw, Badugiç”¨ï¼‰\n  socket.on('draw-exchange', (data: { discardIndexes: number[] }) => {\n    try {\n      const context = validateDrawExchangeRequest(socket, data);\n      if (!context) return;\n      const { roomId, room, engine, player, discardIndexes } = context;\n\n      // ã‚«ãƒ¼ãƒ‰äº¤æ›ã‚’å®Ÿè¡Œ\n      const deck = engine.getDeck();\n      const dealer = new Dealer();\n      dealer.exchangeDrawCards(deck, player, discardIndexes);\n\n      // äº¤æ›æšæ•°ã‚’è¨˜éŒ²\n      player.drawDiscards = discardIndexes.length;\n\n      // ãƒ‰ãƒ­ãƒ¼å®Œäº†ã‚’ãƒãƒ¼ã‚¯\n      engine.markDrawComplete(room, socket.id);\n\n      console.log(`ğŸ”„ ${player.name} drew ${discardIndexes.length} cards`);\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ–°ã—ã„æ‰‹æœ­ã‚’é€ä¿¡\n      io.to(socket.id).emit('draw-complete', {\n        newHand: player.hand\n      });\n\n      // å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«äº¤æ›æšæ•°ã‚’é€šçŸ¥ï¼ˆæ‰‹æœ­ã¯è¦‹ã›ãªã„ï¼‰\n      io.to(`room:${roomId}`).emit('player-drew', {\n        playerId: socket.id,\n        playerName: player.name,\n        cardCount: discardIndexes.length\n      });\n\n      // å…¨å“¡å®Œäº†ã—ãŸã‹ãƒã‚§ãƒƒã‚¯\n      if (engine.checkDrawPhaseComplete(room)) {\n        // ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºã«ç§»è¡Œ\n        console.log(`âœ… All players completed draw - starting betting for ${room.gameState.status}`);\n\n        // å…¨å“¡ã«æ›´æ–°ã‚’é€ä¿¡\n        broadcastRoomState(roomId, room, io);\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n        if (room.activePlayerIndex !== -1) {\n          const nextPlayer = room.players[room.activePlayerIndex];\n          if (nextPlayer) {\n            emitYourTurn(roomId, room, engine, io, nextPlayer);\n          }\n        }\n      } else {\n        // ã¾ã å…¨å“¡å®Œäº†ã—ã¦ã„ãªã„å ´åˆã®ã¿çŠ¶æ…‹é€ä¿¡\n        broadcastRoomState(roomId, room, io);\n      }\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // çŠ¶æ…‹å†åŒæœŸ\n  socket.on('request-room-state', () => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) return;\n      const room = roomManager.getRoomById(roomId);\n      if (!room) return;\n      socket.emit('room-state-update', sanitizeRoomForViewer(room, socket.id));\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ========== ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«å¤‰æ›´ ==========\n\n  // ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ãƒ»ãƒã‚¤ã‚¤ãƒ³è¨­å®šå¤‰æ›´\n  socket.on('update-room-config', (data: {\n    smallBlind?: number;\n    bigBlind?: number;\n    buyInMin?: number;\n    buyInMax?: number;\n    timeLimit?: number;\n    studAnte?: number;\n  }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ã‚²ãƒ¼ãƒ ä¸­ã¯å¤‰æ›´ä¸å¯\n      if (room.gameState.status !== 'WAITING') {\n        socket.emit('error', { message: 'Cannot change config while game is in progress' });\n        return;\n      }\n\n      // è¨­å®šã‚’æ›´æ–°\n      if (data.smallBlind !== undefined) {\n        room.config.smallBlind = data.smallBlind;\n      }\n      if (data.bigBlind !== undefined) {\n        room.config.bigBlind = data.bigBlind;\n      }\n      if (data.buyInMin !== undefined) {\n        room.config.buyInMin = data.buyInMin;\n      }\n      if (data.buyInMax !== undefined) {\n        room.config.buyInMax = data.buyInMax;\n      }\n      if (data.timeLimit !== undefined) {\n        room.config.timeLimit = data.timeLimit;\n      }\n      if (data.studAnte !== undefined) {\n        room.config.studAnte = data.studAnte;\n      }\n\n      console.log(`âš™ï¸ Room ${roomId} config updated: SB=${room.config.smallBlind}, BB=${room.config.bigBlind}, Ante=${room.config.studAnte}`);\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n      io.to(`room:${roomId}`).emit('config-updated', { config: room.config });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ¡ã‚¿ã‚²ãƒ¼ãƒ ãƒˆã‚°ãƒ« (7-2ã‚²ãƒ¼ãƒ , Stand Up)\n  socket.on('toggle-meta-game', (data: { game: 'sevenDeuce' | 'standUp'; enabled: boolean }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // metaGameãŒæœªåˆæœŸåŒ–ã®å ´åˆã¯åˆæœŸåŒ–\n      if (!room.metaGame) {\n        room.metaGame = {\n          standUp: { isActive: false, remainingPlayers: [] },\n          sevenDeuce: false\n        };\n      }\n\n      if (data.game === 'sevenDeuce') {\n        room.metaGame.sevenDeuce = data.enabled;\n        console.log(`ğŸ² Room ${roomId}: 7-2 game ${data.enabled ? 'enabled' : 'disabled'}`);\n      } else if (data.game === 'standUp') {\n        room.metaGame.standUp.isActive = data.enabled;\n        if (data.enabled) {\n          // Stand Upé–‹å§‹æ™‚ã€å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’remainingPlayersã«è¿½åŠ \n          room.metaGame.standUp.remainingPlayers = room.players\n            .filter(p => p !== null)\n            .map(p => p!.socketId);\n        }\n        console.log(`ğŸ† Room ${roomId}: Stand Up game ${data.enabled ? 'enabled' : 'disabled'}`);\n      }\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n      io.to(`room:${roomId}`).emit('meta-game-updated', { metaGame: room.metaGame });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ã‚²ãƒ¼ãƒ ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š\n  socket.on('set-rotation', (data: {\n    enabled: boolean;\n    gamesList?: string[];\n    handsPerGame?: number;\n  }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã‚’æ›´æ–°\n      room.rotation.enabled = data.enabled;\n\n      if (data.gamesList !== undefined && data.gamesList.length > 0) {\n        room.rotation.gamesList = data.gamesList;\n        room.rotation.currentGameIndex = 0;\n        // æœ€åˆã®ã‚²ãƒ¼ãƒ ã‚’è¨­å®š\n        room.gameState.gameVariant = data.gamesList[0];\n      }\n\n      if (data.handsPerGame !== undefined) {\n        room.rotation.handsPerGame = data.handsPerGame;\n        rotationManager.setHandsPerGame(data.handsPerGame);\n      }\n\n      const gamesStr = room.rotation.gamesList.join(' â†’ ');\n      console.log(`ğŸ”„ Room ${roomId}: Rotation ${data.enabled ? 'enabled' : 'disabled'} [${gamesStr}]`);\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n      io.to(`room:${roomId}`).emit('rotation-updated', { rotation: room.rotation });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆå³æ™‚å¤‰æ›´ï¼ˆãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å¤–ï¼‰\n  const applyGameVariantChange = (variant: string) => {\n    const roomId = getRoomIdFromSocket(socket);\n    if (!roomId) {\n      socket.emit('error', { message: 'You are not in any room' });\n      return;\n    }\n\n    const room = roomManager.getRoomById(roomId);\n    if (!room) {\n      socket.emit('error', { message: 'Room not found' });\n      return;\n    }\n\n    if (room.gameState.status !== 'WAITING') {\n      socket.emit('error', { message: 'Cannot change game while hand is in progress' });\n      return;\n    }\n\n    const validVariants = ['NLH', 'PLO', 'PLO8', '7CS', '7CS8', 'RAZZ', '2-7_TD', 'BADUGI'];\n    if (!validVariants.includes(variant)) {\n      socket.emit('error', { message: `Invalid variant: ${variant}` });\n      return;\n    }\n\n    room.gameState.gameVariant = variant;\n    console.log(`ğŸ® Room ${roomId}: Game variant changed to ${variant}`);\n\n    broadcastRoomState(roomId, room, io);\n    io.to(`room:${roomId}`).emit('game-variant-changed', { variant });\n  };\n\n  socket.on('set-game-variant', (data: { variant: string }) => {\n    try {\n      applyGameVariantChange(data.variant);\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  socket.on('change-variant', (data: { variant: string }) => {\n    try {\n      applyGameVariantChange(data.variant);\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ‡ãƒãƒƒã‚°ç”¨: æ¬¡ã‚²ãƒ¼ãƒ ã¸å¼·åˆ¶åˆ‡æ›¿\n  socket.on('force-next-game', () => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      if (room.gameState.status !== 'WAITING') {\n        socket.emit('error', { message: 'Cannot change game while hand is in progress' });\n        return;\n      }\n\n      if (room.rotation.gamesList.length <= 1) {\n        socket.emit('error', { message: 'Rotation is not enabled' });\n        return;\n      }\n\n      const nextIndex = (room.rotation.currentGameIndex + 1) % room.rotation.gamesList.length;\n      const nextGame = room.rotation.gamesList[nextIndex];\n      room.rotation.currentGameIndex = nextIndex;\n      room.gameState.gameVariant = nextGame;\n\n      if (nextIndex === 0) {\n        room.rotation.orbitCount = (room.rotation.orbitCount || 0) + 1;\n      }\n\n      io.to(`room:${roomId}`).emit('next-game', {\n        nextGame,\n        gamesList: room.rotation.gamesList\n      });\n      broadcastRoomState(roomId, room, io);\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // é›¢å¸­\n  socket.on('leave-seat', () => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n      handleRoomExit(socket, roomId, io, { leaveRoom: false });\n      if ((socket.data as any).roomId === roomId) {\n        delete (socket.data as any).roomId;\n      }\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // åˆ‡æ–­ã—ãŸæ™‚\n  socket.on('disconnect', () => {\n    const roomId = (socket.data as any).roomId || getRoomIdFromSocket(socket);\n    if (!roomId) {\n      console.log('ğŸ‘‹ Player disconnected (not in any room):', socket.id);\n      return;\n    }\n    console.log(`ğŸ‘‹ Player disconnected: ${socket.id} from room ${roomId}`);\n    logEvent('disconnect', { playerId: socket.id });\n    incrementMetric('disconnect');\n\n    try {\n      handleRoomExit(socket, roomId, io);\n      delete (socket.data as any).roomId;\n    } catch (error) {\n      // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼ˆã™ã§ã«é›¢å¸­æ¸ˆã¿ã®å¯èƒ½æ€§ï¼‰\n    }\n\n    io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n  });\n});\n\n// Phase 2: ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰\nexport {\n  getRoomIdOrError,\n  getRoomOrError,\n  getEngineOrError,\n  checkActionRateLimit,\n  validateActionToken,\n  validatePlayerActionRequest,\n  handleAllInRunout,\n  handleNormalShowdown,\n  maybeHandleShowdown,\n  validateDrawExchangeRequest,\n  validateQuickJoinBuyIn,\n  removeExistingPlayerSession,\n  createQuickJoinPlayer,\n  getRoomIdFromSocket,\n  broadcastRoomState,\n  cleanupPendingLeavers,\n  scheduleNextHand\n};\n\n// ãƒ†ã‚¹ãƒˆç”¨: çŠ¶æ…‹ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°\nexport const __testing__ = {\n  getGameEngine: (roomId: string) => gameEngines.get(roomId),\n  setGameEngine: (roomId: string, engine: GameEngine) => gameEngines.set(roomId, engine),\n  getActionToken: (socketId: string) => actionTokens.get(socketId),\n  setActionToken: (socketId: string, token: string, issuedAt: number) =>\n    actionTokens.set(socketId, { token, issuedAt }),\n  getActionRateLimit: (socketId: string) => actionRateLimit.get(socketId),\n  setActionRateLimit: (socketId: string, count: number, windowStart: number) =>\n    actionRateLimit.set(socketId, { count, windowStart }),\n  clearActionTokens: () => actionTokens.clear(),\n  clearActionRateLimit: () => actionRateLimit.clear(),\n  clearInvalidActionCounts: () => invalidActionCounts.clear(),\n  ACTION_TOKEN_TTL_MS,\n  ACTION_RATE_LIMIT_WINDOW_MS,\n  ACTION_RATE_LIMIT_MAX\n};\n\nconst PORT = process.env.PORT || 3000;\nconst HOST = '0.0.0.0';\nhttpServer.listen(Number(PORT), HOST, () => {\n  console.log(`\\nğŸš€ Server is running on http://${HOST}:${PORT}`);\n\n  // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã‚’åˆæœŸåŒ–\n  roomManager.initializePresetRooms();\n});\n","usedDeprecatedRules":[]}]
