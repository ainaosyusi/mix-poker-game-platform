[{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/index.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'processPostAction' has a complexity of 11. Maximum allowed is 10.","line":211,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":211,"endColumn":27},{"ruleId":"complexity","severity":1,"message":"Function 'handleRoomExit' has a complexity of 17. Maximum allowed is 10.","line":402,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":402,"endColumn":24},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (1072). Maximum allowed is 100.","line":569,"column":21,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":1640,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 14. Maximum allowed is 10.","line":576,"column":50,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":576,"endColumn":52},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":597,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":601,"endColumn":14},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (118). Maximum allowed is 100.","line":727,"column":27,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":844,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 22. Maximum allowed is 10.","line":727,"column":69,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":727,"endColumn":71},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (282). Maximum allowed is 100.","line":938,"column":30,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":1219,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 30. Maximum allowed is 10.","line":938,"column":98,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":938,"endColumn":100},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":1173,"column":13,"nodeType":"ForOfStatement","messageId":"tooDeeply","endLine":1179,"endColumn":14},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":1175,"column":15,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":1178,"endColumn":16},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (121). Maximum allowed is 100.","line":1222,"column":30,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":1342,"endColumn":4},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 27. Maximum allowed is 10.","line":1222,"column":67,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":1222,"endColumn":69},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 11. Maximum allowed is 10.","line":1367,"column":6,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":1367,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport { randomUUID } from 'crypto';\nimport { createServer } from 'http';\nimport { Server } from 'socket.io';\nimport cors from 'cors';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\n// ESMç”¨ã®__dirnameå–å¾—\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nimport { evaluateHand, compareHands } from './handEvaluator.js';\nimport { roomManager } from './RoomManager.js';\nimport { GameEngine } from './GameEngine.js';\nimport { ShowdownManager } from './ShowdownManager.js';\nimport { ActionValidator } from './ActionValidator.js';\nimport { Dealer } from './Dealer.js';\nimport type {\n  JoinRoomRequest,\n  SitDownRequest,\n  Player as RoomPlayer,\n  PlayerStatus,\n  ActionType\n} from './types.js';\nimport { RotationManager } from './RotationManager.js';\nimport { MetaGameManager } from './MetaGameManager.js';\nimport { PotManager } from './PotManager.js';\nimport { getVariantConfig } from './gameVariants.js';\nimport { logEvent, incrementMetric } from './logger.js';\nimport authRoutes from './auth/authRoutes.js';\nimport { verifyToken } from './auth/authService.js';\nimport { findRandomEmptySeat } from './autoSeating.js';\n\n// Phase 3-B: ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆéƒ¨å±‹ã”ã¨ã«ç®¡ç†ï¼‰\nconst gameEngines: Map<string, GameEngine> = new Map();\nconst showdownManager = new ShowdownManager();\nconst actionValidator = new ActionValidator();\nconst metaGameManager = new MetaGameManager();\nconst rotationManager = new RotationManager();\nconst potManager = new PotManager();\nconst actionTokens: Map<string, { token: string; issuedAt: number }> = new Map(); // playerId -> token meta\nconst actionInFlight: Set<string> = new Set(); // playerId in progress\nconst roomActionInFlight: Set<string> = new Set(); // roomId in progress\nconst invalidActionCounts: Map<string, { count: number; lastAt: number }> = new Map();\nconst actionRateLimit: Map<string, { count: number; windowStart: number }> = new Map();\n\n// ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†\ninterface PlayerTimer {\n  roomId: string;\n  playerId: string;\n  seconds: number;\n  intervalId: NodeJS.Timeout;\n  timeBankChips: number;\n}\nconst activeTimers: Map<string, PlayerTimer> = new Map(); // playerId -> timer\nconst playerTimeBanks: Map<string, number> = new Map(); // playerId -> chips\n\nconst MAX_TIMER_SECONDS = 30;\nconst INITIAL_TIMEBANK_CHIPS = 5;\nconst HAND_END_DELAY_MS = 2000;\nconst AUTO_START_DELAY_MS = 2000;\nconst ACTION_TOKEN_TTL_MS = 35000;\nconst ACTION_RATE_LIMIT_WINDOW_MS = 2000;\nconst ACTION_RATE_LIMIT_MAX = 6;\n\n// è‡ªå‹•ã‚²ãƒ¼ãƒ é–‹å§‹ç®¡ç†\nconst pendingStarts: Map<string, NodeJS.Timeout> = new Map();\n\nfunction cleanupSocketSession(socketId: string) {\n  clearPlayerTimer(socketId);\n  actionTokens.delete(socketId);\n  actionInFlight.delete(socketId);\n  invalidActionCounts.delete(socketId);\n  actionRateLimit.delete(socketId);\n  playerTimeBanks.delete(socketId);\n}\n\nfunction cleanupPendingLeavers(roomId: string, io: Server): boolean {\n  const room = roomManager.getRoomById(roomId);\n  if (!room) return true;\n\n  let removed = false;\n  room.players.forEach((player, index) => {\n    if (player?.pendingLeave) {\n      cleanupSocketSession(player.socketId);\n      room.players[index] = null;\n      removed = true;\n    }\n  });\n\n  if (removed) {\n    const allEmpty = room.players.every(p => p === null);\n    if (allEmpty && !room.isPreset) {\n      roomManager.deleteRoom(roomId);\n      gameEngines.delete(roomId);\n      roomActionInFlight.delete(roomId);\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n      return true;\n    }\n    io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n  }\n\n  return false;\n}\n\n// ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹é–¢æ•°\nfunction startPlayerTimer(roomId: string, playerId: string, io: Server) {\n  // æ—¢å­˜ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢\n  clearPlayerTimer(playerId);\n\n  // ã‚¿ã‚¤ãƒ ãƒãƒ³ã‚¯åˆæœŸåŒ–ï¼ˆåˆå›ã®ã¿ï¼‰\n  if (!playerTimeBanks.has(playerId)) {\n    playerTimeBanks.set(playerId, INITIAL_TIMEBANK_CHIPS);\n  }\n\n  const timer: PlayerTimer = {\n    roomId,\n    playerId,\n    seconds: MAX_TIMER_SECONDS,\n    intervalId: setInterval(() => {\n      const t = activeTimers.get(playerId);\n      if (!t) return;\n\n      t.seconds--;\n\n      // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°ã‚’é€ä¿¡\n      io.to(playerId).emit('timer-update', { seconds: t.seconds });\n\n      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®è‡ªå‹•ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n      if (t.seconds <= 0) {\n        clearPlayerTimer(playerId);\n        handleTimerTimeout(roomId, playerId, io);\n      }\n    }, 1000),\n    timeBankChips: playerTimeBanks.get(playerId) || INITIAL_TIMEBANK_CHIPS\n  };\n\n  activeTimers.set(playerId, timer);\n}\n\n// ã‚¿ã‚¤ãƒãƒ¼ã‚¯ãƒªã‚¢é–¢æ•°\nfunction clearPlayerTimer(playerId: string) {\n  const timer = activeTimers.get(playerId);\n  if (timer) {\n    clearInterval(timer.intervalId);\n    activeTimers.delete(playerId);\n  }\n}\n\n// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®è‡ªå‹•ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\nfunction handleTimerTimeout(roomId: string, playerId: string, io: Server) {\n  const room = roomManager.getRoomById(roomId);\n  if (!room) return;\n\n  const engine = gameEngines.get(roomId);\n  if (!engine) return;\n\n  const player = room.players.find(p => p?.socketId === playerId);\n  if (!player) return;\n\n  actionTokens.delete(playerId);\n\n  // ãƒã‚§ãƒƒã‚¯å¯èƒ½ãªã‚‰ãƒã‚§ãƒƒã‚¯ã€ãã†ã§ãªã‘ã‚Œã°ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰\n  const validActions = engine.getValidActions(room, playerId);\n  const actionType: ActionType = validActions.includes('CHECK') ? 'CHECK' : 'FOLD';\n\n  console.log(`â° Timer timeout for ${player.name} - Auto ${actionType}`);\n\n  const result = engine.processAction(room, {\n    playerId,\n    type: actionType,\n    timestamp: Date.now()\n  });\n\n  if (result.success) {\n    // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯ç­‰ã®å‡¦ç†ã¯ player-action ã¨åŒæ§˜ã«è¡Œã†\n    processPostAction(roomId, room, engine, io);\n  }\n}\n\nfunction issueActionToken(playerId: string): string {\n  const token = randomUUID();\n  actionTokens.set(playerId, { token, issuedAt: Date.now() });\n  return token;\n}\n\nfunction emitYourTurn(roomId: string, room: any, engine: GameEngine, io: Server, player: any) {\n  const validActions = engine.getValidActions(room, player.socketId);\n  const bettingInfo = engine.getBettingInfo(room, player.socketId);\n  const actionToken = issueActionToken(player.socketId);\n  io.to(player.socketId).emit('your-turn', {\n    validActions,\n    currentBet: room.gameState.currentBet,\n    minRaise: bettingInfo.minBet,\n    maxBet: bettingInfo.maxBet,\n    betStructure: bettingInfo.betStructure,\n    isCapped: bettingInfo.isCapped,\n    raisesRemaining: bettingInfo.raisesRemaining,\n    fixedBetSize: bettingInfo.fixedBetSize,\n    timeout: MAX_TIMER_SECONDS * 1000,\n    actionToken\n  });\n\n  startPlayerTimer(roomId, player.socketId, io);\n\n  const timeBankChips = playerTimeBanks.get(player.socketId) || INITIAL_TIMEBANK_CHIPS;\n  io.to(player.socketId).emit('timebank-update', { chips: timeBankChips });\n}\n\n// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾Œã®å…±é€šå‡¦ç†\nfunction processPostAction(roomId: string, room: any, engine: GameEngine, io: Server) {\n  // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\n  if (room.gameState.status === 'SHOWDOWN') {\n    const activePlayers = room.players.filter((p: any) =>\n      p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n    );\n\n    if (room.gameState.isRunout && activePlayers.length >= 2) {\n      // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆã®å‡¦ç†ã¯æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã«ä»»ã›ã‚‹\n      return;\n    }\n\n    let showdownResult;\n    if (activePlayers.length === 1) {\n      showdownResult = showdownManager.awardToLastPlayer(room);\n    } else {\n      const calculatedPots = potManager.calculatePots(room.players);\n      room.gameState.pot = calculatedPots;\n      showdownResult = showdownManager.executeShowdown(room);\n    }\n\n    io.to(`room:${roomId}`).emit('showdown-result', showdownResult);\n\n    // 7-2ãƒœãƒ¼ãƒŠã‚¹ãƒã‚§ãƒƒã‚¯\n    if (showdownResult.winners.length > 0) {\n      for (const winner of showdownResult.winners) {\n        const bonus = metaGameManager.checkSevenDeuce(room, winner.playerId, winner.hand);\n        if (bonus) {\n          io.to(`room:${roomId}`).emit('seven-deuce-bonus', bonus);\n        }\n      }\n    }\n\n    // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯\n    const rotation = rotationManager.checkRotation(room);\n    if (rotation.changed) {\n      io.to(`room:${roomId}`).emit('next-game', {\n        nextGame: rotation.nextGame,\n        gamesList: room.rotation.gamesList\n      });\n    }\n\n    room.gameState.status = 'WAITING' as any;\n\n    // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³å¾Œã®é…å»¶ï¼ˆ1.5ç§’ï¼‰\n    setTimeout(() => {\n      if (cleanupPendingLeavers(roomId, io)) {\n        return;\n      }\n      // æ¬¡ã®ãƒãƒ³ãƒ‰ã‚’è‡ªå‹•é–‹å§‹\n      scheduleNextHand(roomId, io);\n    }, 1500);\n  }\n\n  // å…¨å“¡ã«æ›´æ–°ã‚’é€ä¿¡\n  broadcastRoomState(roomId, room, io);\n\n  // æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n  if (room.activePlayerIndex !== -1) {\n    const nextPlayer = room.players[room.activePlayerIndex];\n    if (nextPlayer) {\n      emitYourTurn(roomId, room, engine, io, nextPlayer);\n    }\n  }\n}\n\n/**\n * è‡ªå‹•ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼\n * 2äººä»¥ä¸Šã®ACTIVEãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ã¦WAITINGçŠ¶æ…‹ãªã‚‰ã€è‡ªå‹•ã§ãƒãƒ³ãƒ‰ã‚’é–‹å§‹\n */\nfunction scheduleNextHand(roomId: string, io: Server) {\n  // æ—¢å­˜ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«\n  const existing = pendingStarts.get(roomId);\n  if (existing) {\n    clearTimeout(existing);\n    pendingStarts.delete(roomId);\n  }\n\n  const room = roomManager.getRoomById(roomId);\n  if (!room) return;\n\n  // WAITINGçŠ¶æ…‹ã§ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„\n  if (room.gameState.status !== 'WAITING') return;\n\n  // ACTIVEãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’ç¢ºèªï¼ˆpendingJoinã‚„SIT_OUTã¯é™¤ãï¼‰\n  const activePlayers = room.players.filter(p =>\n    p !== null && p.status !== 'SIT_OUT' && !p.pendingJoin && !p.pendingSitOut && !p.pendingLeave\n  );\n\n  if (activePlayers.length < 2) return;\n\n  const timeout = setTimeout(() => {\n    pendingStarts.delete(roomId);\n\n    const currentRoom = roomManager.getRoomById(roomId);\n    if (!currentRoom || currentRoom.gameState.status !== 'WAITING') return;\n\n    // å†åº¦ACTIVEãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’ãƒã‚§ãƒƒã‚¯\n    const readyPlayers = currentRoom.players.filter(p =>\n      p !== null && p.status !== 'SIT_OUT' && !p.pendingJoin && !p.pendingSitOut && !p.pendingLeave\n    );\n    if (readyPlayers.length < 2) return;\n\n    // GameEngineã‚’å–å¾—ã¾ãŸã¯ä½œæˆ\n    let engine = gameEngines.get(roomId);\n    if (!engine) {\n      engine = new GameEngine();\n      gameEngines.set(roomId, engine);\n    }\n\n    // ãƒãƒ³ãƒ‰ã‚’é–‹å§‹\n    const success = engine.startHand(currentRoom);\n    if (!success) return;\n\n    // å…¨å“¡ã«ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã¨è‡ªåˆ†ã®ãƒãƒ³ãƒ‰ã‚’é€ä¿¡\n    for (const player of currentRoom.players) {\n      if (player) {\n        io.to(player.socketId).emit('game-started', {\n          room: sanitizeRoomForViewer(currentRoom, player.socketId),\n          yourHand: player.hand\n        });\n      }\n    }\n\n    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n    const activePlayer = currentRoom.players[currentRoom.activePlayerIndex];\n    if (activePlayer) {\n      emitYourTurn(roomId, currentRoom, engine, io, activePlayer);\n    }\n\n    console.log(`ğŸ® Auto-started game in room ${roomId}`);\n    logEvent('auto_start', { roomId, playerCount: readyPlayers.length });\n    incrementMetric('auto_start');\n  }, AUTO_START_DELAY_MS);\n\n  pendingStarts.set(roomId, timeout);\n}\n\n/**\n * ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚µãƒ‹ã‚¿ã‚¤ã‚ºï¼ˆä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®handã‚’éš ã™ï¼‰\n * @param room ãƒ«ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ\n * @param viewerSocketId é–²è¦§è€…ã®socketIdï¼ˆã“ã®äººã«ã¯è‡ªåˆ†ã®æ‰‹æœ­ãŒè¦‹ãˆã‚‹ï¼‰\n */\nfunction sanitizeRoomForViewer(room: any, viewerSocketId?: string): any {\n  return {\n    ...room,\n    players: room.players.map((p: any) => {\n      if (!p) return null;\n      const isOwnPlayer = viewerSocketId && p.socketId === viewerSocketId;\n\n      // Studç”¨: 4thã‚¹ãƒˆãƒªãƒ¼ãƒˆã®ã‚«ãƒ¼ãƒ‰ï¼ˆstudUpCards[1]ï¼‰ã¯ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã¯è¦‹ã›ãªã„\n      // è‡ªåˆ†ã«ã¯å…¨ã¦è¦‹ãˆã‚‹ã€ä»–è€…ã«ã¯ãƒ‰ã‚¢ã‚«ãƒ¼ãƒ‰(0)ã¨5th(2)ã€6th(3)ã®ã¿\n      let visibleUpCards = p.studUpCards || [];\n      if (!isOwnPlayer && visibleUpCards.length > 1) {\n        // 4thã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚«ãƒ¼ãƒ‰ï¼ˆindex 1ï¼‰ã‚’é™¤å¤–\n        visibleUpCards = visibleUpCards.filter((_: any, i: number) => i !== 1);\n      }\n\n      return {\n        ...p,\n        // è‡ªåˆ†ä»¥å¤–ã®handã¯éš ã™\n        hand: isOwnPlayer ? p.hand : null,\n        // studUpCardsã¯4thã‚¹ãƒˆãƒªãƒ¼ãƒˆä»¥å¤–ã‚’ä»–è€…ã«å…¬é–‹\n        studUpCards: visibleUpCards\n      };\n    })\n  };\n}\n\nfunction broadcastRoomState(roomId: string, room: any, io: Server) {\n  void io.in(`room:${roomId}`).fetchSockets()\n    .then(sockets => {\n      for (const sock of sockets) {\n        sock.emit('room-state-update', sanitizeRoomForViewer(room, sock.id));\n      }\n    })\n    .catch(error => {\n      console.error('âŒ Failed to broadcast room-state-update', {\n        roomId,\n        error: error instanceof Error ? error.message : error\n      });\n    });\n}\n\n// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: socketã‹ã‚‰roomIdã‚’å–å¾—\nfunction getRoomIdFromSocket(socket: any): string | null {\n  const rooms = Array.from(socket.rooms) as string[];\n  const roomEntry = rooms.find((r: string) => r.startsWith('room:'));\n  return roomEntry ? roomEntry.slice(5) : null;\n}\n\nfunction handleRoomExit(\n  socket: any,\n  roomId: string,\n  io: Server,\n  options: { leaveRoom?: boolean } = {}\n) {\n  const room = roomManager.getRoomById(roomId);\n  cleanupSocketSession(socket.id);\n  const leaveRoom = options.leaveRoom !== false;\n\n  if (!room) {\n    if (leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n    return;\n  }\n\n  const seatIndex = room.players.findIndex(p => p?.socketId === socket.id);\n  if (seatIndex === -1) {\n    if (leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n    return;\n  }\n\n  const player = room.players[seatIndex]!;\n  const isInHand = room.gameState.status !== 'WAITING';\n\n  if (isInHand) {\n    player.pendingLeave = true;\n    player.pendingSitOut = true;\n    player.pendingJoin = false;\n    player.waitingForBB = false;\n    player.disconnected = true;\n\n    const engine = gameEngines.get(roomId);\n    const isActivePlayer = room.activePlayerIndex === seatIndex;\n    let actionProcessed = false;\n\n    if (engine && isActivePlayer && player.status === 'ACTIVE') {\n      const result = engine.processAction(room, {\n        playerId: socket.id,\n        type: 'FOLD' as ActionType,\n        timestamp: Date.now()\n      });\n\n      if (result.success) {\n        processPostAction(roomId, room, engine, io);\n        actionProcessed = true;\n      } else {\n        player.status = 'FOLDED';\n      }\n    } else if (player.status === 'ACTIVE') {\n      player.status = 'FOLDED';\n    }\n\n    if (leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n    if (!actionProcessed) {\n      broadcastRoomState(roomId, room, io);\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n    }\n    return;\n  }\n\n  roomManager.standUp(roomId, socket.id);\n  if (leaveRoom) {\n    socket.leave(`room:${roomId}`);\n  }\n\n  const roomStillExists = roomManager.getRoomById(roomId);\n  if (roomStillExists) {\n    broadcastRoomState(roomId, roomStillExists, io);\n  } else {\n    gameEngines.delete(roomId);\n    roomActionInFlight.delete(roomId);\n    if (!leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n  }\n\n  io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n}\n\nconst app = express();\nconst isProduction = process.env.NODE_ENV === 'production';\n\n// CORSè¨­å®š: æœ¬ç•ªç’°å¢ƒã§ã¯åŒä¸€ã‚ªãƒªã‚¸ãƒ³ã€é–‹ç™ºç’°å¢ƒã§ã¯è¤‡æ•°ãƒãƒ¼ãƒˆè¨±å¯\nconst ALLOWED_ORIGINS: string[] = isProduction\n  ? [process.env.CLIENT_URL].filter((url): url is string => Boolean(url))\n  : [\n      'http://localhost:5173',\n      'http://localhost:5174',\n      'http://localhost:5175',\n      process.env.CLIENT_URL\n    ].filter((url): url is string => Boolean(url));\n\napp.use(cors({\n  origin: (origin, callback) => {\n    // originãŒãªã„å ´åˆï¼ˆåŒä¸€ã‚ªãƒªã‚¸ãƒ³ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼‰ã¾ãŸã¯è¨±å¯ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã‚‹å ´åˆã¯è¨±å¯\n    if (!origin || ALLOWED_ORIGINS.includes(origin) || isProduction) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true\n}));\n\n// JSON bodyãƒ‘ãƒ¼ã‚µãƒ¼\napp.use(express.json());\n\n// èªè¨¼APIãƒ«ãƒ¼ãƒˆ\napp.use('/api/auth', authRoutes);\n\n// ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆå…¨ç’°å¢ƒå…±é€šï¼‰\napp.get('/api/health', (_req, res) => {\n  res.json({ status: 'ok', message: 'Mix Poker Game Server is running' });\n});\n\n// æœ¬ç•ªç’°å¢ƒ: é™çš„ãƒ•ã‚¡ã‚¤ãƒ«é…ä¿¡\nif (isProduction) {\n  const clientDistPath = path.join(__dirname, '../../client/dist');\n  app.use(express.static(clientDistPath));\n\n  // APIä»¥å¤–ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯index.htmlã‚’è¿”ã™ï¼ˆSPAå¯¾å¿œï¼‰\n  // Express 5ã§ã¯ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã«åå‰ä»˜ããƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¿…è¦\n  app.get('/{*splat}', (req, res, next) => {\n    // Socket.IOã‚„APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯é™¤å¤–\n    if (req.path.startsWith('/socket.io') || req.path.startsWith('/api/')) {\n      return next();\n    }\n    res.sendFile(path.join(clientDistPath, 'index.html'));\n  });\n} else {\n  app.get('/', (req, res) => {\n    res.json({ status: 'ok', message: 'Mix Poker Game Server is running' });\n  });\n}\n\nconst httpServer = createServer(app);\n// Socket.ioã®è¨­å®š (CORSè¨±å¯)\nconst io = new Server(httpServer, {\n  cors: {\n    origin: ALLOWED_ORIGINS,\n    methods: [\"GET\", \"POST\"],\n    credentials: true\n  }\n});\n\n// Socket.IOèªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢\nio.use((socket, next) => {\n  const token = socket.handshake.auth?.token;\n  if (token) {\n    const user = verifyToken(token);\n    if (user) {\n      socket.data.user = user;\n      return next();\n    }\n  }\n  // èªè¨¼ãªã—ã§ã‚‚æ¥ç¶šã‚’è¨±å¯ï¼ˆã‚²ã‚¹ãƒˆå¯¾å¿œã®ä½™åœ°ï¼‰\n  // ãŸã ã—useræƒ…å ±ã¯null\n  socket.data.user = null;\n  next();\n});\n\nio.on('connection', (socket) => {\n  const user = socket.data.user;\n  console.log(`ğŸ”¥ Player connected! ID: ${socket.id}, User: ${user?.displayName || 'Guest'}`);\n\n  // ========== Room Management Events ==========\n\n  // éƒ¨å±‹å‚åŠ \n  socket.on('join-room', (data: JoinRoomRequest) => {\n    try {\n      const existingRoomId = getRoomIdFromSocket(socket);\n      if (existingRoomId && existingRoomId !== data.roomId) {\n        handleRoomExit(socket, existingRoomId, io);\n      }\n\n      const room = roomManager.getRoomById(data.roomId);\n\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      if (data.resumeToken) {\n        const existingPlayer = room.players.find(p => p?.resumeToken === data.resumeToken);\n        if (existingPlayer) {\n          const previousSocketId = existingPlayer.socketId;\n          if (previousSocketId !== socket.id) {\n            cleanupSocketSession(previousSocketId);\n            const oldSocket = io.sockets.sockets.get(previousSocketId);\n            if (oldSocket) {\n              oldSocket.leave(`room:${data.roomId}`);\n              oldSocket.emit('error', { message: 'Session replaced by reconnection' });\n              oldSocket.disconnect(true);\n            }\n          }\n\n          existingPlayer.socketId = socket.id;\n          existingPlayer.disconnected = false;\n          (socket.data as any).playerName = existingPlayer.name;\n          if (room.gameState.status === 'WAITING' && existingPlayer.status === 'SIT_OUT' && !existingPlayer.pendingSitOut) {\n            existingPlayer.status = 'ACTIVE';\n          } else if (room.gameState.status !== 'WAITING') {\n            existingPlayer.pendingJoin = true;\n          }\n\n          socket.join(`room:${data.roomId}`);\n          (socket.data as any).roomId = data.roomId;\n          socket.emit('room-joined', {\n            room: sanitizeRoomForViewer(room, socket.id),\n            yourSocketId: socket.id,\n            yourHand: existingPlayer.hand || null\n          });\n          logEvent('room_resumed', { roomId: data.roomId, playerName: existingPlayer.name });\n          incrementMetric('room_resumed');\n          broadcastRoomState(data.roomId, room, io);\n          return;\n        }\n      }\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’socket.dataã«ä¿å­˜ï¼ˆsit-downæ™‚ã«ä½¿ç”¨ï¼‰\n      (socket.data as any).playerName = data.playerName;\n\n      // Socket.IOã®ãƒ«ãƒ¼ãƒ ã«å‚åŠ \n      socket.join(`room:${data.roomId}`);\n      (socket.data as any).roomId = data.roomId;\n      (socket.data as any).roomId = data.roomId;\n\n      socket.emit('room-joined', {\n        room: sanitizeRoomForViewer(room, socket.id),\n        yourSocketId: socket.id,\n        yourHand: null\n      });\n\n      console.log(`ğŸšª ${data.playerName} joined room ${data.roomId}`);\n      logEvent('room_joined', { roomId: data.roomId, playerName: data.playerName });\n      incrementMetric('room_joined');\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // éƒ¨å±‹ãƒªã‚¹ãƒˆå–å¾—ï¼ˆãƒ­ãƒ“ãƒ¼ç”¨ï¼‰\n  socket.on('get-room-list', () => {\n    // ãƒ­ãƒ“ãƒ¼ã®Socket.IOãƒ«ãƒ¼ãƒ ã«å‚åŠ \n    socket.join('lobby');\n    socket.emit('room-list-update', roomManager.getAllRooms());\n  });\n\n  // éƒ¨å±‹é€€å‡º\n  socket.on('leave-room', () => {\n    const roomId = getRoomIdFromSocket(socket);\n    if (!roomId) return;\n    try {\n      handleRoomExit(socket, roomId, io, { leaveRoom: true });\n      if ((socket.data as any).roomId === roomId) {\n        delete (socket.data as any).roomId;\n      }\n    } catch (error) {\n      // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–\n    }\n  });\n\n  // ç€å¸­\n  socket.on('sit-down', (data: SitDownRequest) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // socket.dataã«playerNameã‚’ä¿å­˜ã—ã¦ãŠãï¼ˆjoin-roomæ™‚ã«è¨­å®šã™ã‚‹ã“ã¨ã‚’æƒ³å®šï¼‰\n      const playerName = (socket.data as any).playerName || 'Anonymous';\n      const variantConfig = getVariantConfig(room.gameState.gameVariant);\n      const isWaiting = room.gameState.status === 'WAITING';\n\n      // ç€å¸­ã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’ä½œæˆ\n      const player: RoomPlayer = {\n        socketId: socket.id,\n        name: playerName,\n        stack: data.buyIn,\n        bet: 0,\n        totalBet: 0,\n        status: (isWaiting ? 'ACTIVE' : 'SIT_OUT') as PlayerStatus,\n        hand: null,\n        resumeToken: data.resumeToken,\n        pendingJoin: !isWaiting,\n        waitingForBB: !isWaiting && variantConfig.hasButton,\n        disconnected: false\n      };\n\n      roomManager.sitDown(roomId, data.seatIndex, player);\n\n      console.log(`âœ… ${playerName} sat down at seat ${data.seatIndex}`);\n      logEvent('sit_down', { roomId, playerName, seatIndex: data.seatIndex });\n      incrementMetric('sit_down');\n\n      // ç€å¸­æˆåŠŸã‚’é€šçŸ¥ï¼ˆæœ¬äººï¼‰\n      socket.emit('sit-down-success', { seatIndex: data.seatIndex });\n\n      // éƒ¨å±‹å†…ã®å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n\n      // ãƒ­ãƒ“ãƒ¼ã«éƒ¨å±‹ãƒªã‚¹ãƒˆæ›´æ–°ã‚’é€šçŸ¥\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n\n    } catch (error: any) {\n      console.error(`âŒ Sit-down failed: ${error.message}`);\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ã‚¯ã‚¤ãƒƒã‚¯å‚åŠ ï¼ˆjoin-room + è‡ªå‹•ç€å¸­ã‚’1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ï¼‰\n  socket.on('quick-join', (data: { roomId: string; buyIn: number }) => {\n    try {\n      // æ—¢ã«åˆ¥ã®éƒ¨å±‹ã«ã„ã‚‹å ´åˆã¯é€€å‡º\n      const existingRoomId = getRoomIdFromSocket(socket);\n      if (existingRoomId && existingRoomId !== data.roomId) {\n        handleRoomExit(socket, existingRoomId, io);\n      }\n\n      const room = roomManager.getRoomById(data.roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ãƒã‚¤ã‚¤ãƒ³é¡ãƒã‚§ãƒƒã‚¯\n      const minBuyIn = room.config.buyInMin || room.config.bigBlind * 20;\n      const maxBuyIn = room.config.buyInMax || room.config.bigBlind * 100;\n      if (data.buyIn < minBuyIn || data.buyIn > maxBuyIn) {\n        socket.emit('error', { message: `Buy-in must be between ${minBuyIn} and ${maxBuyIn}` });\n        return;\n      }\n\n      // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—\n      const user = socket.data?.user;\n      const playerName = user?.displayName || 'Guest';\n\n      // æ—¢ã«ç€å¸­æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆsocket.idã¾ãŸã¯userIdï¼‰\n      const existingPlayerIndex = room.players.findIndex(p => {\n        if (!p) return false;\n        if (p.socketId === socket.id) return true;\n        if (user?.userId && p.userId === user.userId) return true;\n        return false;\n      });\n\n      if (existingPlayerIndex !== -1) {\n        // æ—¢å­˜ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‰Šé™¤ï¼ˆå¤ã„ã‚»ãƒƒã‚·ãƒ§ãƒ³ï¼‰\n        const oldPlayer = room.players[existingPlayerIndex]!;\n        console.log(`ğŸ”„ Removing old session for ${oldPlayer.name} (old: ${oldPlayer.socketId}, new: ${socket.id})`);\n\n        // ãƒãƒ³ãƒ‰ä¸­ã®å ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰å‡¦ç†\n        if (room.gameState.status !== 'WAITING') {\n          const engine = gameEngines.get(data.roomId);\n          if (engine && room.activePlayerIndex === existingPlayerIndex && oldPlayer.status === 'ACTIVE') {\n            engine.processAction(room, {\n              playerId: oldPlayer.socketId,\n              type: 'FOLD' as ActionType,\n              timestamp: Date.now()\n            });\n          }\n        }\n\n        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‰Šé™¤\n        room.players[existingPlayerIndex] = null;\n      }\n\n      // ç©ºå¸­ã‚’æ¢ã™\n      const seatIndex = findRandomEmptySeat(room.players);\n      if (seatIndex === null) {\n        socket.emit('error', { message: 'Room is full' });\n        return;\n      }\n\n      // socket.dataã«playerNameã‚’ä¿å­˜\n      (socket.data as any).playerName = playerName;\n\n      // Socket.IOã®ãƒ«ãƒ¼ãƒ ã«å‚åŠ \n      socket.join(`room:${data.roomId}`);\n      (socket.data as any).roomId = data.roomId;\n      // ãƒ­ãƒ“ãƒ¼ã‹ã‚‰é›¢è„±\n      socket.leave('lobby');\n\n      const variantConfig = getVariantConfig(room.gameState.gameVariant);\n      const isWaiting = room.gameState.status === 'WAITING';\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’ä½œæˆ\n      const player: RoomPlayer = {\n        socketId: socket.id,\n        name: playerName,\n        stack: data.buyIn,\n        bet: 0,\n        totalBet: 0,\n        status: (isWaiting ? 'ACTIVE' : 'SIT_OUT') as PlayerStatus,\n        hand: null,\n        pendingJoin: !isWaiting,\n        waitingForBB: !isWaiting && variantConfig.hasButton,\n        disconnected: false,\n        userId: user?.userId,\n        avatarIcon: user?.avatarIcon\n      };\n\n      roomManager.sitDown(data.roomId, seatIndex, player);\n\n      console.log(`âš¡ ${playerName} quick-joined room ${data.roomId} at seat ${seatIndex}`);\n      logEvent('quick_join', { roomId: data.roomId, playerName, seatIndex, buyIn: data.buyIn });\n      incrementMetric('quick_join');\n\n      // å‚åŠ æˆåŠŸã‚’é€šçŸ¥ï¼ˆæœ¬äººï¼‰\n      socket.emit('room-joined', {\n        room: sanitizeRoomForViewer(room, socket.id),\n        yourSocketId: socket.id,\n        yourHand: null\n      });\n      socket.emit('sit-down-success', { seatIndex });\n\n      // éƒ¨å±‹å†…ã®å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(data.roomId, room, io);\n\n      // ãƒ­ãƒ“ãƒ¼ã«éƒ¨å±‹ãƒªã‚¹ãƒˆæ›´æ–°ã‚’é€šçŸ¥\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n\n      // è‡ªå‹•ã‚²ãƒ¼ãƒ é–‹å§‹ãƒã‚§ãƒƒã‚¯\n      scheduleNextHand(data.roomId, io);\n\n    } catch (error: any) {\n      console.error(`âŒ Quick-join failed: ${error.message}`);\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒªãƒã‚¤ï¼ˆãƒãƒƒãƒ—è¿½åŠ ï¼‰\n  socket.on('rebuy', (data: { amount: number }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™\n      const player = room.players.find(p => p?.socketId === socket.id);\n      if (!player) {\n        socket.emit('error', { message: 'You are not seated' });\n        return;\n      }\n\n      // ã‚²ãƒ¼ãƒ ä¸­ã¯ãƒªãƒã‚¤ä¸å¯\n      if (room.gameState.status !== 'WAITING') {\n        socket.emit('error', { message: 'Cannot rebuy during a hand' });\n        return;\n      }\n\n      // é‡‘é¡ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³\n      const newStack = player.stack + data.amount;\n      const buyInMin = room.config.buyInMin ?? room.config.bigBlind * 20;\n      const buyInMax = room.config.buyInMax ?? room.config.bigBlind * 200;\n      if (newStack < buyInMin) {\n        socket.emit('error', { message: `Minimum buy-in is ${buyInMin}` });\n        return;\n      }\n      if (newStack > buyInMax) {\n        socket.emit('error', { message: `Maximum buy-in is ${buyInMax}` });\n        return;\n      }\n\n      // ãƒªãƒã‚¤å®Ÿè¡Œ\n      player.stack = newStack;\n      console.log(`ğŸ’° ${player.name} rebought for ${data.amount} (new stack: ${newStack})`);\n\n      // ãƒªãƒã‚¤æˆåŠŸã‚’é€šçŸ¥\n      socket.emit('rebuy-success', { amount: data.amount, newStack });\n\n      // éƒ¨å±‹å†…ã®å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n\n      // ã‚²ãƒ¼ãƒ é–‹å§‹ãƒã‚§ãƒƒã‚¯ï¼ˆãƒªãƒã‚¤å¾Œã«äººæ•°ãŒæƒã£ãŸå ´åˆï¼‰\n      scheduleNextHand(roomId, io);\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ========== Phase 3-B: Game Engine Events ==========\n\n  // ã‚¿ã‚¤ãƒ ãƒãƒ³ã‚¯ä½¿ç”¨\n  socket.on('use-timebank', () => {\n    try {\n      const timer = activeTimers.get(socket.id);\n      if (!timer) {\n        socket.emit('error', { message: 'No active timer' });\n        return;\n      }\n\n      const currentChips = playerTimeBanks.get(socket.id) || 0;\n      if (currentChips <= 0) {\n        socket.emit('error', { message: 'No time bank chips remaining' });\n        return;\n      }\n\n      // ã‚¿ã‚¤ãƒ ãƒãƒ³ã‚¯ãƒãƒƒãƒ—ã‚’æ¶ˆè²»ã—ã¦30ç§’è¿½åŠ \n      playerTimeBanks.set(socket.id, currentChips - 1);\n      timer.seconds += 30;\n\n      console.log(`â±ï¸ Time bank used by ${socket.id} (${currentChips - 1} chips remaining)`);\n\n      // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æ›´æ–°ã‚’é€šçŸ¥\n      socket.emit('timer-update', { seconds: timer.seconds });\n      socket.emit('timebank-update', { chips: currentChips - 1 });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n  socket.on('player-action', (data: { type: ActionType; amount?: number; actionToken?: string }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      const engine = gameEngines.get(roomId);\n      if (!engine) {\n        socket.emit('error', { message: 'Game not started' });\n        return;\n      }\n\n      if (roomActionInFlight.has(roomId)) {\n        socket.emit('action-invalid', { reason: 'Room is processing another action' });\n        return;\n      }\n\n      if (room.gameState.isDrawPhase) {\n        socket.emit('action-invalid', { reason: 'Draw phase in progress' });\n        logEvent('action_invalid', { roomId, playerId: socket.id, reason: 'Draw phase in progress' });\n        incrementMetric('action_invalid', { reason: 'draw_phase' });\n        return;\n      }\n\n      const now = Date.now();\n      const rate = actionRateLimit.get(socket.id);\n      if (!rate || now - rate.windowStart > ACTION_RATE_LIMIT_WINDOW_MS) {\n        actionRateLimit.set(socket.id, { count: 1, windowStart: now });\n      } else {\n        rate.count += 1;\n        if (rate.count > ACTION_RATE_LIMIT_MAX) {\n          const ip = socket.handshake.address;\n          console.warn(`âš ï¸ Rate limit: ${socket.id} (${ip}) ${rate.count}/${ACTION_RATE_LIMIT_WINDOW_MS}ms`);\n          socket.emit('action-invalid', { reason: 'Too many actions' });\n          logEvent('rate_limited', { roomId, playerId: socket.id, ip, count: rate.count });\n          incrementMetric('rate_limited');\n          return;\n        }\n      }\n\n      const token = data.actionToken;\n      const expectedToken = actionTokens.get(socket.id);\n      if (!token || !expectedToken || token !== expectedToken.token) {\n        socket.emit('action-invalid', { reason: 'Invalid action token' });\n        logEvent('action_invalid', { roomId, playerId: socket.id, reason: 'Invalid action token' });\n        incrementMetric('action_invalid', { reason: 'invalid_token' });\n        const stats = invalidActionCounts.get(socket.id);\n        if (!stats || now - stats.lastAt > 5000) {\n          invalidActionCounts.set(socket.id, { count: 1, lastAt: now });\n        } else {\n          stats.count += 1;\n          stats.lastAt = now;\n          if (stats.count >= 3) {\n            console.warn(`âš ï¸ Repeated invalid actions from ${socket.id} (${stats.count} in 5s)`);\n            logEvent('invalid_action_spam', { roomId, playerId: socket.id, count: stats.count });\n            incrementMetric('invalid_action_spam');\n          }\n        }\n        return;\n      }\n\n      if (Date.now() - expectedToken.issuedAt > ACTION_TOKEN_TTL_MS) {\n        actionTokens.delete(socket.id);\n        socket.emit('action-invalid', { reason: 'Action token expired' });\n        logEvent('action_invalid', { roomId, playerId: socket.id, reason: 'Action token expired' });\n        incrementMetric('action_invalid', { reason: 'token_expired' });\n        return;\n      }\n\n      if (actionInFlight.has(socket.id)) {\n        socket.emit('action-invalid', { reason: 'Action already in progress' });\n        return;\n      }\n\n      // ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢\n      clearPlayerTimer(socket.id);\n\n      actionInFlight.add(socket.id);\n      roomActionInFlight.add(roomId);\n      let result;\n      try {\n        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‡¦ç†\n        result = engine.processAction(room, {\n          playerId: socket.id,\n          type: data.type,\n          amount: data.amount,\n          timestamp: Date.now()\n        });\n      } finally {\n        actionInFlight.delete(socket.id);\n        roomActionInFlight.delete(roomId);\n      }\n\n      if (!result.success) {\n        socket.emit('action-invalid', { reason: result.error });\n        logEvent('action_invalid', { roomId, playerId: socket.id, reason: result.error });\n        incrementMetric('action_invalid', { reason: 'engine_reject' });\n        startPlayerTimer(roomId, socket.id, io);\n        return;\n      }\n      actionTokens.delete(socket.id);\n\n      // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\n      if (room.gameState.status === 'SHOWDOWN') {\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯\n        const activePlayers = room.players.filter(p =>\n          p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        );\n\n        // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆã®å ´åˆã€é…å»¶è¡¨ç¤º\n        if (room.gameState.isRunout && activePlayers.length >= 2) {\n          const runoutPhase = room.gameState.runoutPhase || 'PREFLOP';\n          const board = room.gameState.board;\n          const DELAY = 1500; // 1.5ç§’\n\n          console.log(`ğŸ¬ Starting all-in runout from ${runoutPhase}`);\n\n          // ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆé–‹å§‹ã‚’é€šçŸ¥\n          io.to(`room:${roomId}`).emit('runout-started', {\n            runoutPhase,\n            fullBoard: board\n          });\n\n          // ãƒ•ã‚§ãƒ¼ã‚ºã«å¿œã˜ã¦ãƒœãƒ¼ãƒ‰ã‚’æ®µéšçš„ã«å…¬é–‹\n          const scheduleRunout = async () => {\n            if (runoutPhase === 'PREFLOP') {\n              // Flop (æœ€åˆã®3æš)\n              await new Promise(r => setTimeout(r, DELAY));\n              io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 3), phase: 'FLOP' });\n\n              // Turn (4æšç›®)\n              await new Promise(r => setTimeout(r, DELAY));\n              io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 4), phase: 'TURN' });\n\n              // River (5æšç›®)\n              await new Promise(r => setTimeout(r, DELAY));\n              io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 5), phase: 'RIVER' });\n\n            } else if (runoutPhase === 'FLOP') {\n              // Turn\n              await new Promise(r => setTimeout(r, DELAY));\n              io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 4), phase: 'TURN' });\n\n              // River\n              await new Promise(r => setTimeout(r, DELAY));\n              io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 5), phase: 'RIVER' });\n\n            } else if (runoutPhase === 'TURN') {\n              // River only\n              await new Promise(r => setTimeout(r, DELAY));\n              io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 5), phase: 'RIVER' });\n            }\n\n            // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³å®Ÿè¡Œ\n            await new Promise(r => setTimeout(r, DELAY));\n\n            // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã‚’è¨ˆç®—\n            const calculatedPots = potManager.calculatePots(room.players);\n            room.gameState.pot = calculatedPots;\n            console.log(`ğŸ’° Pots calculated: Main=${calculatedPots.main}, Sides=${calculatedPots.side.map(s => s.amount).join(',')}`);\n\n            // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³å®Ÿè¡Œ\n            const showdownResult = showdownManager.executeShowdown(room);\n            io.to(`room:${roomId}`).emit('showdown-result', showdownResult);\n\n            // 7-2ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒŠã‚¹ãƒã‚§ãƒƒã‚¯\n            if (showdownResult.winners.length > 0) {\n              for (const winner of showdownResult.winners) {\n                const bonus = metaGameManager.checkSevenDeuce(room, winner.playerId, winner.hand);\n                if (bonus) {\n                  io.to(`room:${roomId}`).emit('seven-deuce-bonus', bonus);\n                  console.log(`ğŸ² 7-2 BONUS: ${winner.playerName} wins ${bonus.amount}`);\n                }\n              }\n            }\n\n            // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯\n            const rotation = rotationManager.checkRotation(room);\n            if (rotation.changed) {\n              console.log(`ğŸ”„ Next game: ${rotation.nextGame}`);\n              io.to(`room:${roomId}`).emit('next-game', {\n                nextGame: rotation.nextGame,\n                gamesList: room.rotation.gamesList\n              });\n            }\n\n            // ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆãƒ•ãƒ©ã‚°ã‚’ã‚¯ãƒªã‚¢\n            room.gameState.isRunout = false;\n            room.gameState.runoutPhase = undefined;\n            room.gameState.status = 'WAITING' as any;\n\n            broadcastRoomState(roomId, room, io);\n\n            // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³å¾Œã®é…å»¶ï¼ˆ1.5ç§’ï¼‰\n            setTimeout(() => {\n              if (cleanupPendingLeavers(roomId, io)) {\n                return;\n              }\n              // æ¬¡ã®ãƒãƒ³ãƒ‰ã‚’è‡ªå‹•é–‹å§‹\n              scheduleNextHand(roomId, io);\n            }, 1500);\n          };\n\n          // éåŒæœŸã§ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆã‚’å®Ÿè¡Œ\n          scheduleRunout();\n          return; // é€šå¸¸ã®ãƒ•ãƒ­ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—\n\n        } else {\n          // é€šå¸¸ã®ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ï¼ˆãƒ©ãƒ³ã‚¢ã‚¦ãƒˆãªã—ï¼‰\n          let showdownResult;\n          if (activePlayers.length === 1) {\n            // 1äººã—ã‹æ®‹ã£ã¦ã„ãªã„ï¼ˆä»–å…¨å“¡ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ï¼‰\n            showdownResult = showdownManager.awardToLastPlayer(room);\n          } else {\n            // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã‚’è¨ˆç®—\n            const calculatedPots = potManager.calculatePots(room.players);\n            room.gameState.pot = calculatedPots;\n            console.log(`ğŸ’° Pots calculated: Main=${calculatedPots.main}, Sides=${calculatedPots.side.map(s => s.amount).join(',')}`);\n\n            // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³å®Ÿè¡Œ\n            showdownResult = showdownManager.executeShowdown(room);\n          }\n\n          io.to(`room:${roomId}`).emit('showdown-result', showdownResult);\n\n          // 7-2ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒŠã‚¹ãƒã‚§ãƒƒã‚¯\n          if (showdownResult.winners.length > 0) {\n            for (const winner of showdownResult.winners) {\n              const bonus = metaGameManager.checkSevenDeuce(room, winner.playerId, winner.hand);\n              if (bonus) {\n                io.to(`room:${roomId}`).emit('seven-deuce-bonus', bonus);\n                console.log(`ğŸ² 7-2 BONUS: ${winner.playerName} wins ${bonus.amount}`);\n              }\n            }\n          }\n\n          // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯\n          const rotation = rotationManager.checkRotation(room);\n          if (rotation.changed) {\n            console.log(`ğŸ”„ Next game: ${rotation.nextGame}`);\n            io.to(`room:${roomId}`).emit('next-game', {\n              nextGame: rotation.nextGame,\n              gamesList: room.rotation.gamesList\n            });\n          }\n\n          room.gameState.status = 'WAITING' as any;\n\n          // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³å¾Œã®é…å»¶ï¼ˆ1.5ç§’ï¼‰\n          setTimeout(() => {\n            if (cleanupPendingLeavers(roomId, io)) {\n              return;\n            }\n            // æ¬¡ã®ãƒãƒ³ãƒ‰ã‚’è‡ªå‹•é–‹å§‹\n            scheduleNextHand(roomId, io);\n          }, 1500);\n        }\n      }\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€ä¿¡\n      broadcastRoomState(roomId, room, io);\n\n      // æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n      if (room.activePlayerIndex !== -1) {\n        const nextPlayer = room.players[room.activePlayerIndex];\n        if (nextPlayer) {\n          emitYourTurn(roomId, room, engine, io, nextPlayer);\n        }\n      }\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ‰ãƒ­ãƒ¼äº¤æ›ï¼ˆ2-7 Triple Draw, Badugiç”¨ï¼‰\n  socket.on('draw-exchange', (data: { discardIndexes: number[] }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      const engine = gameEngines.get(roomId);\n      if (!engine) {\n        socket.emit('error', { message: 'Game not started' });\n        return;\n      }\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ç¢ºèª\n      const player = room.players.find(p => p?.socketId === socket.id);\n      if (!player) {\n        socket.emit('error', { message: 'Player not found' });\n        return;\n      }\n\n      // Drawãƒ•ã‚§ãƒ¼ã‚ºã‹ç¢ºèªï¼ˆäº¤æ›ãƒ•ã‚§ãƒ¼ã‚ºã§ãªã‘ã‚Œã°ã‚¨ãƒ©ãƒ¼ï¼‰\n      const status = room.gameState.status;\n      const isDrawPhase = room.gameState.isDrawPhase;\n      if (!isDrawPhase || (status !== 'FIRST_DRAW' && status !== 'SECOND_DRAW' && status !== 'THIRD_DRAW')) {\n        socket.emit('error', { message: 'Not in draw exchange phase' });\n        return;\n      }\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ç¢ºèª\n      if (player.status !== 'ACTIVE' && player.status !== 'ALL_IN') {\n        socket.emit('error', { message: 'You cannot draw' });\n        return;\n      }\n\n      // æ—¢ã«äº¤æ›æ¸ˆã¿ã‹ç¢ºèª\n      const completedDraw = room.gameState.playersCompletedDraw || [];\n      if (completedDraw.includes(socket.id)) {\n        socket.emit('error', { message: 'You have already drawn this round' });\n        return;\n      }\n\n      const variantConfig = getVariantConfig(room.gameState.gameVariant);\n      const maxDrawCount = variantConfig.maxDrawCount ?? player.hand?.length ?? 0;\n      const discardIndexes = Array.isArray(data.discardIndexes) ? data.discardIndexes : [];\n      const uniqueIndexes = new Set<number>();\n      for (const idx of discardIndexes) {\n        if (!Number.isInteger(idx)) {\n          socket.emit('error', { message: 'Invalid discard index' });\n          return;\n        }\n        uniqueIndexes.add(idx);\n      }\n      if (discardIndexes.length !== uniqueIndexes.size) {\n        socket.emit('error', { message: 'Duplicate discard indexes' });\n        return;\n      }\n      if (discardIndexes.length > maxDrawCount) {\n        socket.emit('error', { message: `Too many cards to discard (max ${maxDrawCount})` });\n        return;\n      }\n      if (!player.hand || discardIndexes.some(idx => idx < 0 || idx >= player.hand!.length)) {\n        socket.emit('error', { message: 'Discard index out of range' });\n        return;\n      }\n\n      // ã‚«ãƒ¼ãƒ‰äº¤æ›ã‚’å®Ÿè¡Œ\n      const deck = engine.getDeck();\n      const dealer = new Dealer();\n      dealer.exchangeDrawCards(deck, player, discardIndexes);\n\n      // äº¤æ›æšæ•°ã‚’è¨˜éŒ²\n      player.drawDiscards = discardIndexes.length;\n\n      // ãƒ‰ãƒ­ãƒ¼å®Œäº†ã‚’ãƒãƒ¼ã‚¯\n      engine.markDrawComplete(room, socket.id);\n\n      console.log(`ğŸ”„ ${player.name} drew ${discardIndexes.length} cards`);\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ–°ã—ã„æ‰‹æœ­ã‚’é€ä¿¡\n      io.to(socket.id).emit('draw-complete', {\n        newHand: player.hand\n      });\n\n      // å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«äº¤æ›æšæ•°ã‚’é€šçŸ¥ï¼ˆæ‰‹æœ­ã¯è¦‹ã›ãªã„ï¼‰\n      io.to(`room:${roomId}`).emit('player-drew', {\n        playerId: socket.id,\n        playerName: player.name,\n        cardCount: discardIndexes.length\n      });\n\n      // å…¨å“¡å®Œäº†ã—ãŸã‹ãƒã‚§ãƒƒã‚¯\n      if (engine.checkDrawPhaseComplete(room)) {\n        // ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºã«ç§»è¡Œ\n        console.log(`âœ… All players completed draw - starting betting for ${room.gameState.status}`);\n\n        // å…¨å“¡ã«æ›´æ–°ã‚’é€ä¿¡\n        broadcastRoomState(roomId, room, io);\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n        if (room.activePlayerIndex !== -1) {\n          const nextPlayer = room.players[room.activePlayerIndex];\n          if (nextPlayer) {\n            emitYourTurn(roomId, room, engine, io, nextPlayer);\n          }\n        }\n      } else {\n        // ã¾ã å…¨å“¡å®Œäº†ã—ã¦ã„ãªã„å ´åˆã®ã¿çŠ¶æ…‹é€ä¿¡\n        broadcastRoomState(roomId, room, io);\n      }\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // çŠ¶æ…‹å†åŒæœŸ\n  socket.on('request-room-state', () => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) return;\n      const room = roomManager.getRoomById(roomId);\n      if (!room) return;\n      socket.emit('room-state-update', sanitizeRoomForViewer(room, socket.id));\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ========== ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«å¤‰æ›´ ==========\n\n  // ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ãƒ»ãƒã‚¤ã‚¤ãƒ³è¨­å®šå¤‰æ›´\n  socket.on('update-room-config', (data: {\n    smallBlind?: number;\n    bigBlind?: number;\n    buyInMin?: number;\n    buyInMax?: number;\n    timeLimit?: number;\n    studAnte?: number;\n  }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ã‚²ãƒ¼ãƒ ä¸­ã¯å¤‰æ›´ä¸å¯\n      if (room.gameState.status !== 'WAITING') {\n        socket.emit('error', { message: 'Cannot change config while game is in progress' });\n        return;\n      }\n\n      // è¨­å®šã‚’æ›´æ–°\n      if (data.smallBlind !== undefined) {\n        room.config.smallBlind = data.smallBlind;\n      }\n      if (data.bigBlind !== undefined) {\n        room.config.bigBlind = data.bigBlind;\n      }\n      if (data.buyInMin !== undefined) {\n        room.config.buyInMin = data.buyInMin;\n      }\n      if (data.buyInMax !== undefined) {\n        room.config.buyInMax = data.buyInMax;\n      }\n      if (data.timeLimit !== undefined) {\n        room.config.timeLimit = data.timeLimit;\n      }\n      if (data.studAnte !== undefined) {\n        room.config.studAnte = data.studAnte;\n      }\n\n      console.log(`âš™ï¸ Room ${roomId} config updated: SB=${room.config.smallBlind}, BB=${room.config.bigBlind}, Ante=${room.config.studAnte}`);\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n      io.to(`room:${roomId}`).emit('config-updated', { config: room.config });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ¡ã‚¿ã‚²ãƒ¼ãƒ ãƒˆã‚°ãƒ« (7-2ã‚²ãƒ¼ãƒ , Stand Up)\n  socket.on('toggle-meta-game', (data: { game: 'sevenDeuce' | 'standUp'; enabled: boolean }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // metaGameãŒæœªåˆæœŸåŒ–ã®å ´åˆã¯åˆæœŸåŒ–\n      if (!room.metaGame) {\n        room.metaGame = {\n          standUp: { isActive: false, remainingPlayers: [] },\n          sevenDeuce: false\n        };\n      }\n\n      if (data.game === 'sevenDeuce') {\n        room.metaGame.sevenDeuce = data.enabled;\n        console.log(`ğŸ² Room ${roomId}: 7-2 game ${data.enabled ? 'enabled' : 'disabled'}`);\n      } else if (data.game === 'standUp') {\n        room.metaGame.standUp.isActive = data.enabled;\n        if (data.enabled) {\n          // Stand Upé–‹å§‹æ™‚ã€å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’remainingPlayersã«è¿½åŠ \n          room.metaGame.standUp.remainingPlayers = room.players\n            .filter(p => p !== null)\n            .map(p => p!.socketId);\n        }\n        console.log(`ğŸ† Room ${roomId}: Stand Up game ${data.enabled ? 'enabled' : 'disabled'}`);\n      }\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n      io.to(`room:${roomId}`).emit('meta-game-updated', { metaGame: room.metaGame });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ã‚²ãƒ¼ãƒ ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š\n  socket.on('set-rotation', (data: {\n    enabled: boolean;\n    gamesList?: string[];\n    handsPerGame?: number;\n  }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã‚’æ›´æ–°\n      room.rotation.enabled = data.enabled;\n\n      if (data.gamesList !== undefined && data.gamesList.length > 0) {\n        room.rotation.gamesList = data.gamesList;\n        room.rotation.currentGameIndex = 0;\n        // æœ€åˆã®ã‚²ãƒ¼ãƒ ã‚’è¨­å®š\n        room.gameState.gameVariant = data.gamesList[0];\n      }\n\n      if (data.handsPerGame !== undefined) {\n        room.rotation.handsPerGame = data.handsPerGame;\n        rotationManager.setHandsPerGame(data.handsPerGame);\n      }\n\n      const gamesStr = room.rotation.gamesList.join(' â†’ ');\n      console.log(`ğŸ”„ Room ${roomId}: Rotation ${data.enabled ? 'enabled' : 'disabled'} [${gamesStr}]`);\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n      io.to(`room:${roomId}`).emit('rotation-updated', { rotation: room.rotation });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆå³æ™‚å¤‰æ›´ï¼ˆãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å¤–ï¼‰\n  const applyGameVariantChange = (variant: string) => {\n    const roomId = getRoomIdFromSocket(socket);\n    if (!roomId) {\n      socket.emit('error', { message: 'You are not in any room' });\n      return;\n    }\n\n    const room = roomManager.getRoomById(roomId);\n    if (!room) {\n      socket.emit('error', { message: 'Room not found' });\n      return;\n    }\n\n    if (room.gameState.status !== 'WAITING') {\n      socket.emit('error', { message: 'Cannot change game while hand is in progress' });\n      return;\n    }\n\n    const validVariants = ['NLH', 'PLO', 'PLO8', '7CS', '7CS8', 'RAZZ', '2-7_TD', 'BADUGI'];\n    if (!validVariants.includes(variant)) {\n      socket.emit('error', { message: `Invalid variant: ${variant}` });\n      return;\n    }\n\n    room.gameState.gameVariant = variant;\n    console.log(`ğŸ® Room ${roomId}: Game variant changed to ${variant}`);\n\n    broadcastRoomState(roomId, room, io);\n    io.to(`room:${roomId}`).emit('game-variant-changed', { variant });\n  };\n\n  socket.on('set-game-variant', (data: { variant: string }) => {\n    try {\n      applyGameVariantChange(data.variant);\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  socket.on('change-variant', (data: { variant: string }) => {\n    try {\n      applyGameVariantChange(data.variant);\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ‡ãƒãƒƒã‚°ç”¨: æ¬¡ã‚²ãƒ¼ãƒ ã¸å¼·åˆ¶åˆ‡æ›¿\n  socket.on('force-next-game', () => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      if (room.gameState.status !== 'WAITING') {\n        socket.emit('error', { message: 'Cannot change game while hand is in progress' });\n        return;\n      }\n\n      if (room.rotation.gamesList.length <= 1) {\n        socket.emit('error', { message: 'Rotation is not enabled' });\n        return;\n      }\n\n      const nextIndex = (room.rotation.currentGameIndex + 1) % room.rotation.gamesList.length;\n      const nextGame = room.rotation.gamesList[nextIndex];\n      room.rotation.currentGameIndex = nextIndex;\n      room.gameState.gameVariant = nextGame;\n\n      if (nextIndex === 0) {\n        room.rotation.orbitCount = (room.rotation.orbitCount || 0) + 1;\n      }\n\n      io.to(`room:${roomId}`).emit('next-game', {\n        nextGame,\n        gamesList: room.rotation.gamesList\n      });\n      broadcastRoomState(roomId, room, io);\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // é›¢å¸­\n  socket.on('leave-seat', () => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n      handleRoomExit(socket, roomId, io, { leaveRoom: false });\n      if ((socket.data as any).roomId === roomId) {\n        delete (socket.data as any).roomId;\n      }\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // åˆ‡æ–­ã—ãŸæ™‚\n  socket.on('disconnect', () => {\n    const roomId = (socket.data as any).roomId || getRoomIdFromSocket(socket);\n    if (!roomId) {\n      console.log('ğŸ‘‹ Player disconnected (not in any room):', socket.id);\n      return;\n    }\n    console.log(`ğŸ‘‹ Player disconnected: ${socket.id} from room ${roomId}`);\n    logEvent('disconnect', { playerId: socket.id });\n    incrementMetric('disconnect');\n\n    try {\n      handleRoomExit(socket, roomId, io);\n      delete (socket.data as any).roomId;\n    } catch (error) {\n      // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼ˆã™ã§ã«é›¢å¸­æ¸ˆã¿ã®å¯èƒ½æ€§ï¼‰\n    }\n\n    io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\nconst HOST = '0.0.0.0';\nhttpServer.listen(Number(PORT), HOST, () => {\n  console.log(`\\nğŸš€ Server is running on http://${HOST}:${PORT}`);\n\n  // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã‚’åˆæœŸåŒ–\n  roomManager.initializePresetRooms();\n});\n","usedDeprecatedRules":[]}]
