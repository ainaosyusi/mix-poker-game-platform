[{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/GameEngine.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'startHand' has too many lines (123). Maximum allowed is 100.","line":28,"column":5,"nodeType":"MethodDefinition","messageId":"exceed","endLine":150,"endColumn":6},{"ruleId":"complexity","severity":1,"message":"Method 'startHand' has a complexity of 21. Maximum allowed is 10.","line":28,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":28,"endColumn":14},{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'processAction' has too many lines (134). Maximum allowed is 100.","line":158,"column":5,"nodeType":"MethodDefinition","messageId":"exceed","endLine":291,"endColumn":6},{"ruleId":"complexity","severity":1,"message":"Method 'processAction' has a complexity of 32. Maximum allowed is 10.","line":158,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":158,"endColumn":18},{"ruleId":"complexity","severity":1,"message":"Method 'advanceAction' has a complexity of 15. Maximum allowed is 10.","line":296,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":296,"endColumn":26},{"ruleId":"complexity","severity":1,"message":"Method 'nextStreet' has a complexity of 12. Maximum allowed is 10.","line":396,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":396,"endColumn":15},{"ruleId":"complexity","severity":1,"message":"Method 'getValidActions' has a complexity of 11. Maximum allowed is 10.","line":684,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":684,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Phase 3-B: Game Engine\n * FSMï¼ˆçŠ¶æ…‹é·ç§»ãƒã‚·ãƒ³ï¼‰ã¨ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’ç®¡ç†\n * Phase 3-C: ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œã‚’è¿½åŠ \n */\n\nimport type { Room, Player, GamePhase, ActionType, PlayerAction } from './types.js';\nimport { Dealer } from './Dealer.js';\nimport { RotationManager } from './RotationManager.js';\nimport { getVariantConfig } from './gameVariants.js';\n\nexport class GameEngine {\n    private dealer: Dealer;\n    private rotationManager: RotationManager;\n    private deck: string[] = [];\n    private actionTimeout: number = 30000; // 30ç§’\n\n    constructor() {\n        this.dealer = new Dealer();\n        this.rotationManager = new RotationManager();\n    }\n\n    /**\n     * ãƒãƒ³ãƒ‰ã‚’é–‹å§‹\n     * @param room éƒ¨å±‹\n     * @returns æˆåŠŸæ™‚true\n     */\n    startHand(room: Room): boolean {\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’ãƒã‚§ãƒƒã‚¯\n        const activePlayers = this.getSeatedPlayers(room);\n        if (activePlayers.length < 2) {\n            console.log('âš ï¸ Need at least 2 players to start hand');\n            return false;\n        }\n\n        console.log(`\\nğŸ´ Starting new hand #${room.gameState.handNumber + 1}`);\n\n        // ãƒãƒ³ãƒ‰ç•ªå·ã‚’å¢—åŠ \n        room.gameState.handNumber = (room.gameState.handNumber || 0) + 1;\n\n        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ\n        for (const player of room.players) {\n            if (!player || player.stack <= 0) continue;\n\n            if (player.pendingSitOut) {\n                player.status = 'SIT_OUT';\n                player.pendingSitOut = false;\n                player.pendingJoin = false;\n                player.waitingForBB = false;\n            } else if (player.disconnected) {\n                player.status = 'SIT_OUT';\n            } else if (player.status === 'SIT_OUT') {\n                if (player.pendingJoin && !player.waitingForBB) {\n                    player.status = 'ACTIVE';\n                    player.pendingJoin = false;\n                }\n            } else {\n                player.status = 'ACTIVE';\n            }\n\n            player.hand = null;\n            player.bet = 0;\n            player.totalBet = 0;\n            if (player.studUpCards) player.studUpCards = [];\n        }\n\n        // ãƒãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ\n        room.gameState.pot = { main: 0, side: [] };\n        room.gameState.board = [];\n        room.gameState.currentBet = 0;\n        room.gameState.minRaise = room.config.bigBlind;\n        room.gameState.raisesThisRound = 0; // ãƒ¬ã‚¤ã‚ºã‚«ã‚¦ãƒ³ã‚¿ãƒªã‚»ãƒƒãƒˆ\n\n        // æœ€å¾Œã®ã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ\n        room.lastAggressorIndex = -1;\n\n        // ãƒ‡ãƒƒã‚­ã‚’ä½œæˆ\n        this.deck = this.dealer.createDeck();\n\n        // ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆå–å¾—\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        // ãƒœã‚¿ãƒ³ã‚’ç§»å‹•ï¼ˆãƒœã‚¿ãƒ³ã‚ã‚Šã‚²ãƒ¼ãƒ ã®ã¿ï¼‰\n        if (variantConfig.hasButton) {\n            this.dealer.moveButton(room);\n        }\n\n        // ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å¾´åï¼ˆãƒœã‚¿ãƒ³ã‚ã‚Šã‚²ãƒ¼ãƒ ã®ã¿ã€Studã¯ã‚¢ãƒ³ãƒ†ã‚£ï¼‰\n        let sbIndex = -1;\n        let bbIndex = -1;\n        if (variantConfig.hasButton) {\n            const blinds = this.dealer.collectBlinds(room);\n            sbIndex = blinds.sbIndex;\n            bbIndex = blinds.bbIndex;\n            room.gameState.currentBet = room.config.bigBlind;\n        }\n\n        // ãƒãƒªã‚¢ãƒ³ãƒˆã«å¿œã˜ãŸã‚«ãƒ¼ãƒ‰é…å¸ƒ\n        let bringInIndex = -1;\n        if (variantConfig.communityCardType === 'stud') {\n            // Stud: 3rd Street (2 down + 1 up)\n            this.dealer.dealStudInitial(this.deck, room.players);\n            room.gameState.status = 'THIRD_STREET' as any;\n            room.gameState.street = 0;\n\n            // Bring-Inåˆ¤å®šï¼ˆRazzã¯æœ€ã‚‚å¼·ã„ã‚«ãƒ¼ãƒ‰ãŒBring-Inï¼‰\n            const isRazz = room.gameState.gameVariant === 'RAZZ';\n            bringInIndex = this.dealer.determineBringIn(room.players, isRazz);\n\n            if (bringInIndex !== -1) {\n                // Bring-Iné¡: è¨­å®šå€¤ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°BB/5ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ\n                const bringInAmount = room.config.studAnte ?? Math.max(1, Math.floor(room.config.bigBlind / 5));\n                this.dealer.collectBringIn(room, bringInIndex, bringInAmount);\n                // Completeé¡ = Small Bet (BBé¡)\n                // 3rd-4th Street: Small Bet = BB\n                // 5th+ Street: Big Bet = 2*BB (getFixedBetSizeã§å‡¦ç†)\n                room.gameState.minRaise = room.config.bigBlind;\n                room.gameState.currentBet = bringInAmount;\n            }\n        } else if (variantConfig.hasDrawPhase) {\n            // Draw: 5æšé…å¸ƒï¼ˆBadugiã¯4æšï¼‰\n            this.dealer.dealHoleCards(this.deck, room.players, variantConfig.holeCardCount);\n            room.gameState.status = 'PREDRAW' as any;\n            room.gameState.street = 0;\n        } else {\n            // Flop games (NLH, PLO): ãƒ›ãƒ¼ãƒ«ã‚«ãƒ¼ãƒ‰é…å¸ƒ\n            this.dealer.dealHoleCards(this.deck, room.players, variantConfig.holeCardCount);\n            room.gameState.status = 'PREFLOP' as any;\n            room.gameState.street = 0;\n        }\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨­å®š\n        if (variantConfig.hasButton && bbIndex !== -1) {\n            // ãƒœã‚¿ãƒ³ã‚ã‚Šã‚²ãƒ¼ãƒ : BBã®æ¬¡ã‹ã‚‰\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, bbIndex);\n        } else if (bringInIndex !== -1) {\n            // Stud: Bring-Inã®æ¬¡ã‹ã‚‰ï¼ˆæ™‚è¨ˆå›ã‚Šï¼‰\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, bringInIndex);\n        } else {\n            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åº§å¸­0ã‹ã‚‰\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, -1);\n        }\n\n        // ã“ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã®é–‹å§‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨˜éŒ²\n        room.streetStarterIndex = room.activePlayerIndex;\n\n        console.log(`âœ… Hand started. Active player: seat ${room.activePlayerIndex}`);\n\n        return true;\n    }\n\n    /**\n     * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‡¦ç†\n     * @param room éƒ¨å±‹\n     * @param action ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n     * @returns å‡¦ç†çµæœ\n     */\n    processAction(room: Room, action: PlayerAction): { success: boolean; error?: string } {\n        const player = room.players.find(p => p?.socketId === action.playerId);\n\n        if (!player) {\n            return { success: false, error: 'Player not found' };\n        }\n\n        if (room.players[room.activePlayerIndex]?.socketId !== action.playerId) {\n            return { success: false, error: 'Not your turn' };\n        }\n\n        console.log(`ğŸ¯ ${player.name} -> ${action.type}${action.amount ? ` ${action.amount}` : ''}`);\n\n        switch (action.type) {\n            case 'FOLD':\n                player.status = 'FOLDED';\n                break;\n\n            case 'CHECK':\n                if (player.bet < room.gameState.currentBet) {\n                    return { success: false, error: 'Cannot check, must call or raise' };\n                }\n                break;\n\n            case 'CALL':\n                const callAmount = Math.min(room.gameState.currentBet - player.bet, player.stack);\n                player.stack -= callAmount;\n                player.bet += callAmount;\n                player.totalBet += callAmount;\n                room.gameState.pot.main += callAmount;\n                if (player.stack === 0) {\n                    player.status = 'ALL_IN';\n                }\n                break;\n\n            case 'BET':\n            case 'RAISE':\n                const betAmount = action.amount || 0;\n                if (!Number.isFinite(betAmount) || betAmount <= 0) {\n                    return { success: false, error: 'Invalid bet amount' };\n                }\n                const variantConfigBet = getVariantConfig(room.gameState.gameVariant);\n                const isAllInBet = betAmount >= player.stack;\n\n                // Fixed-Limit: ã‚­ãƒ£ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯ï¼ˆ5-bet cap = 4 raisesï¼‰\n                if (variantConfigBet.betStructure === 'fixed') {\n                    const capLimit = this.getCapLimit(room);\n                    if (room.gameState.raisesThisRound >= capLimit) {\n                        return { success: false, error: 'Betting is capped' };\n                    }\n                }\n\n                const minTotal = this.getMinBetTo(room, player);\n\n                const totalBet = player.bet + betAmount;\n\n                if (totalBet < minTotal && !isAllInBet) {\n                    return { success: false, error: `Minimum raise is ${minTotal}` };\n                }\n                if (betAmount > player.stack) {\n                    return { success: false, error: 'Not enough chips' };\n                }\n\n                // Pot-Limit: æœ€å¤§ãƒ™ãƒƒãƒˆé¡ãƒã‚§ãƒƒã‚¯\n                if (variantConfigBet.betStructure === 'pot-limit') {\n                    const maxPotBet = this.calculatePotLimitMax(room, player);\n                    if (totalBet > maxPotBet) {\n                        return { success: false, error: `Maximum bet is ${maxPotBet} (pot limit)` };\n                    }\n                }\n\n                const raiseSize = totalBet - room.gameState.currentBet;\n                const reopensAction = raiseSize >= room.gameState.minRaise;\n\n                player.stack -= betAmount;\n                player.bet = totalBet;\n                player.totalBet += betAmount;\n                room.gameState.pot.main += betAmount;\n                room.gameState.currentBet = totalBet;\n\n                if (reopensAction) {\n                    room.gameState.minRaise = raiseSize;\n                    // ã‚¢ã‚°ãƒ¬ãƒƒã‚·ãƒ–ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾Œã€ã“ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’é–‰ã˜ã‚‹\n                    room.streetStarterIndex = room.activePlayerIndex;\n                    if (variantConfigBet.betStructure === 'fixed') {\n                        room.gameState.raisesThisRound++;\n                    }\n                } else if (variantConfigBet.betStructure !== 'fixed') {\n                    // NL/PLã¯ã‚­ãƒ£ãƒƒãƒ—ç®¡ç†ã—ãªã„ãŸã‚ã‚«ã‚¦ãƒ³ãƒˆä¸è¦\n                }\n\n                // æœ€å¾Œã®ã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ã‚’è¨˜éŒ²ï¼ˆã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºç”¨ï¼‰\n                room.lastAggressorIndex = room.activePlayerIndex;\n\n                if (player.stack === 0) {\n                    player.status = 'ALL_IN';\n                }\n                break;\n\n            case 'ALL_IN':\n                const allInAmount = player.stack;\n                const newTotal = player.bet + allInAmount;\n                const raiseSizeAllIn = newTotal - room.gameState.currentBet;\n                const reopensAllIn = raiseSizeAllIn >= room.gameState.minRaise;\n\n                player.bet = newTotal;\n                player.totalBet += allInAmount;\n                player.stack = 0;\n                player.status = 'ALL_IN';\n                room.gameState.pot.main += allInAmount;\n\n                if (newTotal > room.gameState.currentBet) {\n                    room.gameState.currentBet = newTotal;\n                    if (reopensAllIn) {\n                        room.gameState.minRaise = raiseSizeAllIn;\n                        // ãƒ¬ã‚¤ã‚ºã‚’å«ã‚€ALL_INã®å ´åˆã€ã“ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’é–‰ã˜ã‚‹\n                        room.streetStarterIndex = room.activePlayerIndex;\n                    }\n                    // æœ€å¾Œã®ã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ã‚’è¨˜éŒ²\n                    room.lastAggressorIndex = room.activePlayerIndex;\n                    if (getVariantConfig(room.gameState.gameVariant).betStructure === 'fixed' && reopensAllIn) {\n                        room.gameState.raisesThisRound++;\n                    } else if (getVariantConfig(room.gameState.gameVariant).betStructure !== 'fixed') {\n                        room.gameState.raisesThisRound++;\n                    }\n                }\n                break;\n        }\n\n        // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç§»å‹•\n        this.advanceAction(room);\n\n        return { success: true };\n    }\n\n    /**\n     * æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é€²ã‚€ã€ã¾ãŸã¯ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’é€²ã‚ã‚‹\n     */\n    private advanceAction(room: Room): void {\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆFOLDED/ALL_INä»¥å¤–ï¼‰ã‚’å–å¾—\n        const actionablePlayers = room.players.filter(p =>\n            p !== null && p.status === 'ACTIVE'\n        );\n\n        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ALL INãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n        const allInPlayers = room.players.filter(p =>\n            p !== null && p.status === 'ALL_IN'\n        );\n\n        const remainingPlayers = room.players.filter(p =>\n            p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        );\n\n        // 1äººä»¥ä¸‹ãªã‚‰çµ‚äº†\n        if (remainingPlayers.length <= 1) {\n            this.endHand(room);\n            return;\n        }\n\n        // å…¨å“¡ALL INã®å ´åˆã€è‡ªå‹•çš„ã«ãƒªãƒãƒ¼ã¾ã§é€²ã‚ã¦ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³\n        if (actionablePlayers.length === 0 && allInPlayers.length >= 2) {\n            console.log('ğŸ’¥ All players ALL IN - auto-dealing to showdown');\n            // ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆæƒ…å ±ã‚’è¨˜éŒ²ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤ºã«ä½¿ç”¨ï¼‰\n            room.gameState.isRunout = true;\n            room.gameState.runoutPhase = room.gameState.status;\n            this.dealToShowdown(room);\n            this.endHand(room);\n            return;\n        }\n\n        // 1äººã ã‘ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§ä»–ãŒALL-INã®å ´åˆã€ãã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚³ãƒ¼ãƒ«ã—ãŸã‚‰ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆ\n        // (ç›¸æ‰‹ãŒã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ã§ã‚·ãƒ§ãƒ¼ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã®å ´åˆãªã©)\n        if (actionablePlayers.length === 1 && allInPlayers.length >= 1) {\n            const activePlayer = actionablePlayers[0]!;\n            // å…¨å“¡ã®ãƒ™ãƒƒãƒˆãŒæƒã£ã¦ã„ã‚‹å ´åˆã€ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆã¸\n            const allBetsMatched = activePlayer.bet >= room.gameState.currentBet;\n            if (allBetsMatched) {\n                console.log('ğŸ’¥ One active player matched all-in bet - running out');\n                room.gameState.isRunout = true;\n                room.gameState.runoutPhase = room.gameState.status;\n                this.dealToShowdown(room);\n                this.endHand(room);\n                return;\n            }\n        }\n\n        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ0äººã®å ´åˆï¼ˆå…¨å“¡ALL_INã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ï¼‰\n        // æ®‹ã‚Šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ1äººä»¥ä¸‹ãªã‚‰çµ‚äº†ï¼ˆå‹è€…ç¢ºå®šï¼‰\n        if (actionablePlayers.length === 0) {\n            // 1äººã®ALL_INãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆã¯ãã®ã¾ã¾çµ‚äº†\n            this.endHand(room);\n            return;\n        }\n\n        // å…¨å“¡ã®ãƒ™ãƒƒãƒˆãŒæƒã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\n        const allBetsEqual = actionablePlayers.every(p =>\n            p!.bet === room.gameState.currentBet || p!.stack === 0\n        );\n\n        // æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™\n        const nextIndex = this.dealer.getNextActivePlayer(room, room.activePlayerIndex);\n\n        // streetStarterãŒã¾ã ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‹ãƒã‚§ãƒƒã‚¯\n        const streetStarter = room.players[room.streetStarterIndex];\n        const streetStarterIsActive = streetStarter?.status === 'ACTIVE';\n\n        // ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†åˆ¤å®š\n        let roundComplete = false;\n\n        if (allBetsEqual) {\n            if (streetStarterIsActive) {\n                // é€šå¸¸ã‚±ãƒ¼ã‚¹: streetStarterã«æˆ»ã£ãŸã‚‰å®Œäº†\n                roundComplete = nextIndex === room.streetStarterIndex;\n            } else {\n                // streetStarterãŒALL_INã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã®å ´åˆ\n                // å…¨å“¡ã®ãƒ™ãƒƒãƒˆãŒæƒã£ã¦ã„ã‚Œã°ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒä¸€å‘¨ã—ãŸã¨ã¿ãªã™\n                // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨åŒã˜ï¼ˆ1äººã ã‘ï¼‰ã‹ã€-1ãªã‚‰å®Œäº†\n                roundComplete = nextIndex === -1 ||\n                    nextIndex === room.activePlayerIndex ||\n                    actionablePlayers.length === 1;\n            }\n        }\n\n        if (roundComplete) {\n            // æ¬¡ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã¸\n            this.nextStreet(room);\n        } else if (nextIndex === -1) {\n            // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„\n            this.endHand(room);\n        } else {\n            // æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸\n            room.activePlayerIndex = nextIndex;\n        }\n    }\n\n    /**\n     * æ¬¡ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã«é€²ã‚€\n     */\n    nextStreet(room: Room): void {\n        // ãƒ™ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ\n        for (const player of room.players) {\n            if (player) {\n                player.bet = 0;\n            }\n        }\n        room.gameState.currentBet = 0;\n        room.gameState.raisesThisRound = 0; // ãƒ¬ã‚¤ã‚ºã‚«ã‚¦ãƒ³ã‚¿ãƒªã‚»ãƒƒãƒˆ\n\n        const phase = room.gameState.status;\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        // ã‚²ãƒ¼ãƒ ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œ\n        if (variantConfig.communityCardType === 'stud') {\n            this.nextStudStreet(room, phase);\n        } else if (variantConfig.hasDrawPhase) {\n            this.nextDrawStreet(room, phase);\n        } else {\n            this.nextFlopStreet(room, phase);\n        }\n\n        // ã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œå¾Œã€å†åº¦ALL INãƒã‚§ãƒƒã‚¯\n        const actionablePlayers = room.players.filter(p =>\n            p !== null && p.status === 'ACTIVE'\n        );\n\n        const allInPlayers = room.players.filter(p =>\n            p !== null && p.status === 'ALL_IN'\n        );\n\n        // SHOWDOWNã«åˆ°é”ã—ãŸå ´åˆã¯ãƒªã‚¿ãƒ¼ãƒ³\n        if (room.gameState.status === 'SHOWDOWN') {\n            return;\n        }\n\n        room.gameState.minRaise = variantConfig.betStructure === 'fixed'\n            ? this.getFixedBetSize(room)\n            : room.config.bigBlind;\n\n        // å…¨å“¡ALL INãªã‚‰è‡ªå‹•çš„ã«æ¬¡ã¸é€²ã‚€\n        if (actionablePlayers.length === 0 && allInPlayers.length >= 2) {\n            console.log('ğŸ’¥ All players still ALL IN - continuing auto-deal');\n            this.nextStreet(room);\n            return;\n        }\n\n        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¯èƒ½ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒ1äººã§ã€ç›¸æ‰‹ãŒå…¨å“¡ALL-INã®å ´åˆ\n        // ãã®1äººã¯èª°ã«ã‚‚å¯¾æŠ—ã§ããªã„ã®ã§ã€ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆã§æ®‹ã‚Šã®ã‚«ãƒ¼ãƒ‰ã‚’é…ã‚‹\n        if (actionablePlayers.length === 1 && allInPlayers.length >= 1) {\n            console.log('ğŸ’¥ Only one active player vs all-in - running out');\n            // ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆæƒ…å ±ã‚’è¨˜éŒ²ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãŒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¡¨ç¤ºã«ä½¿ç”¨ï¼‰\n            room.gameState.isRunout = true;\n            room.gameState.runoutPhase = room.gameState.status;\n            this.dealToShowdown(room);\n            this.endHand(room);\n            return;\n        }\n\n        // ãƒœã‚¿ãƒ³ã®æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰é–‹å§‹ï¼ˆStudã¯åˆ¥ãƒ­ã‚¸ãƒƒã‚¯ï¼‰\n        if (variantConfig.hasButton) {\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, room.dealerBtnIndex);\n        } else {\n            // Stud: æœ€å¼·/æœ€å¼±ã®ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã‚’æŒã¤ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰\n            const isRazz = room.gameState.gameVariant === 'RAZZ';\n            room.activePlayerIndex = this.dealer.getStudActionStartIndex(room, isRazz);\n        }\n        // æ–°ã—ã„ã‚¹ãƒˆãƒªãƒ¼ãƒˆã®é–‹å§‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨˜éŒ²\n        room.streetStarterIndex = room.activePlayerIndex;\n    }\n\n    /**\n     * Flopç³»ã‚²ãƒ¼ãƒ ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œï¼ˆãƒ‡ãƒ¼ã‚¿é§†å‹•ï¼‰\n     * boardPatternã«åŸºã¥ã„ã¦ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ã‚’é…å¸ƒ\n     */\n    private nextFlopStreet(room: Room, phase: any): void {\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n        const boardPattern = variantConfig.boardPattern || [3, 1, 1];\n        // ãƒ•ã‚§ãƒ¼ã‚ºåã®é…åˆ—ï¼ˆstreet indexã«å¯¾å¿œï¼‰\n        const FLOP_PHASES = ['PREFLOP', 'FLOP', 'TURN', 'RIVER', 'OCEAN'];\n\n        const currentStreet = room.gameState.street;\n        const nextStreet = currentStreet + 1;\n\n        // å…¨ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ãŒé…å¸ƒæ¸ˆã¿ â†’ ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³\n        if (nextStreet > boardPattern.length) {\n            room.gameState.status = 'SHOWDOWN' as any;\n            room.gameState.street = nextStreet;\n            this.endHand(room);\n            return;\n        }\n\n        // æ¬¡ã®ãƒ•ã‚§ãƒ¼ã‚ºã«é€²è¡Œ\n        const nextPhase = FLOP_PHASES[nextStreet] || 'SHOWDOWN';\n        room.gameState.status = nextPhase as any;\n        room.gameState.street = nextStreet;\n\n        // ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ã‚’é…å¸ƒ\n        const cardCount = boardPattern[nextStreet - 1]; // boardPattern[0]=flop, [1]=turn, [2]=river, [3]=ocean\n        const newCards = this.dealer.dealBoardCards(this.deck, cardCount);\n        room.gameState.board.push(...newCards);\n\n        console.log(`ğŸƒ ${nextPhase}: ${newCards.join(' ')} (board: ${room.gameState.board.join(' ')})`);\n    }\n\n    /**\n     * Studç³»ã‚²ãƒ¼ãƒ ï¼ˆ7CS, RAZZï¼‰ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œ\n     */\n    private nextStudStreet(room: Room, phase: any): void {\n        switch (phase) {\n            case 'PREFLOP': // ä¾¿å®œä¸ŠPREFLOPã¨ã—ã¦é–‹å§‹\n            case 'THIRD_STREET':\n                room.gameState.status = 'FOURTH_STREET' as any;\n                this.dealer.dealStudStreet(this.deck, room.players, false);\n                room.gameState.street = 1;\n                console.log(`ğŸ´ 4th Street dealt`);\n                break;\n\n            case 'FOURTH_STREET':\n                room.gameState.status = 'FIFTH_STREET' as any;\n                this.dealer.dealStudStreet(this.deck, room.players, false);\n                room.gameState.street = 2;\n                console.log(`ğŸ´ 5th Street dealt`);\n                break;\n\n            case 'FIFTH_STREET':\n                room.gameState.status = 'SIXTH_STREET' as any;\n                this.dealer.dealStudStreet(this.deck, room.players, false);\n                room.gameState.street = 3;\n                console.log(`ğŸ´ 6th Street dealt`);\n                break;\n\n            case 'SIXTH_STREET':\n                room.gameState.status = 'SEVENTH_STREET' as any;\n                this.dealer.dealStudStreet(this.deck, room.players, true); // æœ€å¾Œã¯ãƒ€ã‚¦ãƒ³ã‚«ãƒ¼ãƒ‰\n                room.gameState.street = 4;\n                console.log(`ğŸ´ 7th Street dealt (down card)`);\n                break;\n\n            case 'SEVENTH_STREET':\n                room.gameState.status = 'SHOWDOWN' as any;\n                room.gameState.street = 5;\n                this.endHand(room);\n                break;\n        }\n    }\n\n    /**\n     * Drawç³»ã‚²ãƒ¼ãƒ ï¼ˆ2-7 TD, Badugiï¼‰ã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆé€²è¡Œ\n     * ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°å®Œäº†å¾Œã€ãƒ‰ãƒ­ãƒ¼äº¤æ›ãƒ•ã‚§ãƒ¼ã‚ºã«å…¥ã‚‹\n     */\n    private nextDrawStreet(room: Room, phase: any): void {\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n        const drawRounds = variantConfig.drawRounds || 3; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ãƒˆãƒªãƒ—ãƒ«ãƒ‰ãƒ­ãƒ¼\n        const DRAW_PHASES = ['PREDRAW', 'FIRST_DRAW', 'SECOND_DRAW', 'THIRD_DRAW'];\n\n        const currentStreet = room.gameState.street;\n        // PREFLOP/PREDRAWã¯street 0\n        const nextStreet = (phase === 'PREFLOP' || phase === 'PREDRAW') ? 1 : currentStreet + 1;\n\n        if (nextStreet > drawRounds) {\n            // å…¨ãƒ‰ãƒ­ãƒ¼ãƒ©ã‚¦ãƒ³ãƒ‰å®Œäº† â†’ ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³\n            room.gameState.status = 'SHOWDOWN' as any;\n            room.gameState.street = nextStreet;\n            room.gameState.isDrawPhase = false;\n            this.endHand(room);\n            return;\n        }\n\n        // æ¬¡ã®ãƒ‰ãƒ­ãƒ¼äº¤æ›ãƒ•ã‚§ãƒ¼ã‚ºã¸\n        const nextPhase = DRAW_PHASES[nextStreet];\n        room.gameState.status = nextPhase as any;\n        room.gameState.street = nextStreet;\n        room.gameState.isDrawPhase = true;\n        room.gameState.playersCompletedDraw = [];\n        this.autoCompleteAllInDraws(room);\n        console.log(`ğŸ”„ ${nextPhase} exchange phase - waiting for players to draw`);\n    }\n\n    /**\n     * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒãƒ‰ãƒ­ãƒ¼äº¤æ›ã‚’å®Œäº†ã—ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹\n     * å…¨å“¡å®Œäº†ã—ãŸã‚‰ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºã«ç§»è¡Œ\n     */\n    checkDrawPhaseComplete(room: Room): boolean {\n        if (!room.gameState.isDrawPhase) return false;\n\n        // FOLDEDä»¥å¤–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n        const activePlayers = room.players.filter(p =>\n            p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        );\n\n        const completedDraw = room.gameState.playersCompletedDraw || [];\n\n        // å…¨å“¡å®Œäº†ã—ãŸã‹ãƒã‚§ãƒƒã‚¯\n        const allCompleted = activePlayers.every(p =>\n            completedDraw.includes(p!.socketId)\n        );\n\n        if (allCompleted) {\n            // ãƒ‰ãƒ­ãƒ¼äº¤æ›å®Œäº† â†’ ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºã¸\n            room.gameState.isDrawPhase = false;\n            room.gameState.playersCompletedDraw = [];\n\n            // ãƒ™ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ\n            for (const player of room.players) {\n                if (player) {\n                    player.bet = 0;\n                }\n            }\n            room.gameState.currentBet = 0;\n            const variantConfig = getVariantConfig(room.gameState.gameVariant);\n            room.gameState.minRaise = variantConfig.betStructure === 'fixed'\n                ? this.getFixedBetSize(room)\n                : room.config.bigBlind;\n            room.gameState.raisesThisRound = 0;\n\n            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨­å®šï¼ˆãƒœã‚¿ãƒ³ã®æ¬¡ã‹ã‚‰ï¼‰\n            room.activePlayerIndex = this.dealer.getNextActivePlayer(room, room.dealerBtnIndex);\n            room.streetStarterIndex = room.activePlayerIndex;\n\n            console.log(`âœ… Draw exchange complete - starting betting round`);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * ãƒ‰ãƒ­ãƒ¼ãƒ•ã‚§ãƒ¼ã‚ºé–‹å§‹æ™‚ã«ALL_INãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è‡ªå‹•çš„ã«å®Œäº†ã¨ã—ã¦ãƒãƒ¼ã‚¯\n     * ï¼ˆALL_INãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã‚«ãƒ¼ãƒ‰ã‚’äº¤æ›ã§ããªã„ãŸã‚ã€0æšäº¤æ›ã¨ã—ã¦æ‰±ã†ï¼‰\n     */\n    autoCompleteAllInDraws(room: Room): void {\n        if (!room.gameState.isDrawPhase) return;\n\n        const allInPlayers = room.players.filter(p =>\n            p !== null && p.status === 'ALL_IN'\n        );\n\n        for (const player of allInPlayers) {\n            if (player) {\n                this.markDrawComplete(room, player.socketId);\n                player.drawDiscards = 0; // ã‚¹ã‚¿ãƒ³ãƒ‰ãƒ‘ãƒƒãƒˆ\n                console.log(`ğŸ”„ ${player.name} auto-stands pat (ALL_IN)`);\n            }\n        }\n    }\n\n    /**\n     * ãƒ‰ãƒ­ãƒ¼äº¤æ›ã‚’å®Œäº†ã¨ã—ã¦ãƒãƒ¼ã‚¯\n     */\n    markDrawComplete(room: Room, playerId: string): void {\n        if (!room.gameState.playersCompletedDraw) {\n            room.gameState.playersCompletedDraw = [];\n        }\n        if (!room.gameState.playersCompletedDraw.includes(playerId)) {\n            room.gameState.playersCompletedDraw.push(playerId);\n        }\n    }\n\n    /**\n     * ãƒãƒ³ãƒ‰çµ‚äº†å‡¦ç†\n     */\n    endHand(room: Room): void {\n        console.log(`\\nğŸ Hand #${room.gameState.handNumber} ended`);\n\n        // çŠ¶æ…‹ã‚’SHOWDOWNã«è¨­å®šï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé€šçŸ¥ç”¨ï¼‰\n        room.gameState.status = 'SHOWDOWN' as any;\n        room.activePlayerIndex = -1;\n    }\n\n    /**\n     * ç€å¸­ä¸­ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n     */\n    getSeatedPlayers(room: Room): Player[] {\n        return room.players.filter(p =>\n            p !== null &&\n            p.stack > 0 &&\n            (p.status === 'ACTIVE' || p.waitingForBB)\n        ) as Player[];\n    }\n\n    /**\n     * ç¾åœ¨ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æœ‰åŠ¹ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å–å¾—\n     * ãƒãƒ¼ã‚«ãƒ¼ãƒ«ãƒ¼ãƒ«:\n     * - ãƒ™ãƒƒãƒˆãŒãªã„ï¼ˆãƒã‚§ãƒƒã‚¯å¯èƒ½ï¼‰æ™‚ã¯FOLDã§ããªã„\n     * - ãƒ™ãƒƒãƒˆã«ç›´é¢ã—ã¦ã„ã‚‹æ™‚ã®ã¿FOLDå¯èƒ½\n     * - Fixed-Limit: ã‚­ãƒ£ãƒƒãƒ—ã«é”ã—ãŸã‚‰ãƒ¬ã‚¤ã‚ºä¸å¯\n     */\n    getValidActions(room: Room, playerId: string): ActionType[] {\n        const player = room.players.find(p => p?.socketId === playerId);\n        if (!player) return [];\n\n        const actions: ActionType[] = [];\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        // ä»–ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆACTIVEçŠ¶æ…‹ã®ã¿ï¼‰ã‚’å–å¾—\n        const otherActivePlayers = room.players.filter(p =>\n            p !== null && p.socketId !== playerId && p.status === 'ACTIVE'\n        );\n\n        // ã‚³ãƒ¼ãƒ«é¡ã‚’è¨ˆç®—\n        const callAmount = Math.max(0, room.gameState.currentBet - player.bet);\n        const wouldCallAllIn = callAmount >= player.stack;\n\n        if (player.bet >= room.gameState.currentBet) {\n            // ãƒ™ãƒƒãƒˆãŒãªã„ï¼ˆã¾ãŸã¯æ—¢ã«ã‚³ãƒ¼ãƒ«æ¸ˆã¿ï¼‰â†’ ãƒã‚§ãƒƒã‚¯å¯èƒ½ã€ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ä¸å¯\n            actions.push('CHECK');\n        } else {\n            // ãƒ™ãƒƒãƒˆã«ç›´é¢ â†’ ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã¾ãŸã¯ã‚³ãƒ¼ãƒ«\n            actions.push('FOLD');\n            actions.push('CALL');\n        }\n\n        // BET/RAISEã®å¯å¦åˆ¤å®š\n        const canAffordRaise = player.stack > callAmount;\n\n        // Fixed-Limit: ã‚­ãƒ£ãƒƒãƒ—ãƒã‚§ãƒƒã‚¯\n        const isCapped = variantConfig.betStructure === 'fixed' &&\n            room.gameState.raisesThisRound >= this.getCapLimit(room);\n\n        // ä»–ã«ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ãªã„å ´åˆï¼ˆå…¨å“¡ALL-INã¾ãŸã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ï¼‰ã€ãƒ¬ã‚¤ã‚ºä¸å¯\n        const canRaise = canAffordRaise && !isCapped && otherActivePlayers.length > 0;\n\n        if (canRaise) {\n            if (room.gameState.currentBet === 0) {\n                actions.push('BET');\n            } else {\n                actions.push('RAISE');\n            }\n        }\n\n        // ALL-IN: No-Limitã®ã¿ã€ã‹ã¤ã‚³ãƒ¼ãƒ«ãŒALL-INã«ãªã‚‰ãªã„å ´åˆã®ã¿è¡¨ç¤º\n        // ï¼ˆã‚³ãƒ¼ãƒ«ãŒALL-INã«ãªã‚‹å ´åˆã¯ã€CALLã‚’é¸ã¹ã°ALL-INã«ãªã‚‹ï¼‰\n        if (variantConfig.betStructure === 'no-limit' && !wouldCallAllIn && player.stack > 0) {\n            actions.push('ALL_IN');\n        }\n\n        return actions;\n    }\n\n    /**\n     * ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°æƒ…å ±ã‚’å–å¾—ï¼ˆã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”¨ï¼‰\n     * minBet, maxBet, betStructure ãªã©ã‚’è¿”ã™\n     */\n    getBettingInfo(room: Room, playerId: string): {\n        minBet: number;\n        maxBet: number;\n        betStructure: string;\n        isCapped: boolean;\n        raisesRemaining: number;\n        fixedBetSize?: number;\n    } {\n        const player = room.players.find(p => p?.socketId === playerId);\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        if (!player) {\n            return {\n                minBet: 0,\n                maxBet: 0,\n                betStructure: variantConfig.betStructure,\n                isCapped: false,\n                raisesRemaining: 0\n            };\n        }\n\n        const callAmount = Math.max(0, room.gameState.currentBet - player.bet);\n        const minBetTo = this.getMinBetTo(room, player);\n\n        // æœ€å¤§ãƒ™ãƒƒãƒˆé¡ã®è¨ˆç®—\n        let maxBetTo: number;\n        let fixedBetSize: number | undefined;\n\n        switch (variantConfig.betStructure) {\n            case 'pot-limit':\n                maxBetTo = Math.min(\n                    this.calculatePotLimitMax(room, player),\n                    player.stack + player.bet\n                );\n                break;\n\n            case 'fixed':\n                // Fixed-Limit: Small Bet or Big Bet\n                fixedBetSize = this.getFixedBetSize(room);\n                maxBetTo = room.gameState.currentBet + fixedBetSize;\n                // ã‚¹ã‚¿ãƒƒã‚¯ãŒè¶³ã‚Šãªã„å ´åˆã¯èª¿æ•´\n                maxBetTo = Math.min(maxBetTo, player.stack + player.bet);\n                break;\n\n            default: // no-limit\n                maxBetTo = player.stack + player.bet;\n                break;\n        }\n\n        const capLimit = this.getCapLimit(room);\n        const isCapped = variantConfig.betStructure === 'fixed' &&\n            room.gameState.raisesThisRound >= capLimit;\n        const raisesRemaining = Math.max(0, capLimit - room.gameState.raisesThisRound);\n\n        return {\n            minBet: minBetTo,\n            maxBet: maxBetTo,\n            betStructure: variantConfig.betStructure,\n            isCapped,\n            raisesRemaining,\n            fixedBetSize\n        };\n    }\n\n    /**\n     * æœ€å°ãƒ™ãƒƒãƒˆ/ãƒ¬ã‚¤ã‚ºã®ã€ŒTOã€å€¤ã‚’å–å¾—\n     */\n    private getMinBetTo(room: Room, player: Player): number {\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n        if (variantConfig.betStructure === 'fixed') {\n            const fixedBetSize = this.getFixedBetSize(room);\n            return room.gameState.currentBet === 0\n                ? fixedBetSize\n                : room.gameState.currentBet + fixedBetSize;\n        }\n\n        return room.gameState.currentBet === 0\n            ? room.gameState.minRaise\n            : room.gameState.currentBet + room.gameState.minRaise;\n    }\n\n    /**\n     * Pot-Limitã®æœ€å¤§ãƒ™ãƒƒãƒˆé¡ã‚’è¨ˆç®—\n     * è¨ˆç®—å¼: MaxBetTo = CurrentPot + (AmountToCall * 2)\n     *\n     * Note: pot.main ã«ã¯æ—¢ã«å…¨ã¦ã®ãƒ™ãƒƒãƒˆï¼ˆãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å«ã‚€ï¼‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹ãŸã‚ã€\n     * player.bet ã‚’è¿½åŠ ã™ã‚‹ã¨äºŒé‡ã‚«ã‚¦ãƒ³ãƒˆã«ãªã‚‹ã€‚\n     */\n    private calculatePotLimitMax(room: Room, player: Player): number {\n        // ç¾åœ¨ã®ãƒãƒƒãƒˆï¼ˆãƒ¡ã‚¤ãƒ³ + ã‚µã‚¤ãƒ‰ï¼‰\n        // pot.main ã«ã¯æ—¢ã«ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ã‚„ä»Šãƒ©ã‚¦ãƒ³ãƒ‰ã®ãƒ™ãƒƒãƒˆãŒå«ã¾ã‚Œã¦ã„ã‚‹\n        let currentPot = room.gameState.pot.main;\n        for (const sidePot of room.gameState.pot.side) {\n            currentPot += sidePot.amount;\n        }\n\n        // ã‚³ãƒ¼ãƒ«é¡\n        const amountToCall = Math.max(0, room.gameState.currentBet - player.bet);\n\n        // Pot-Limitè¨ˆç®—: ã‚³ãƒ¼ãƒ«å¾Œã®ä»®æƒ³ãƒãƒƒãƒˆã¾ã§ãƒ¬ã‚¤ã‚ºå¯èƒ½\n        // ã‚³ãƒ¼ãƒ«å¾Œã®ãƒãƒƒãƒˆ = currentPot + amountToCall\n        // æœ€å¤§ãƒ¬ã‚¤ã‚º = ã‚³ãƒ¼ãƒ«å¾Œã®ãƒãƒƒãƒˆ\n        // MaxBetTo = amountToCall + (currentPot + amountToCall) = currentPot + 2*amountToCall\n        const maxBetTo = currentPot + (amountToCall * 2);\n\n        return maxBetTo;\n    }\n\n    /**\n     * Fixed-Limitã®ãƒ™ãƒƒãƒˆã‚µã‚¤ã‚ºã‚’å–å¾—\n     * Small Bet: Preflop, Flop (ã¾ãŸã¯ Stud 3rd-4th Street)\n     * Big Bet: Turn, River (ã¾ãŸã¯ Stud 5th-7th Street)\n     */\n    private getFixedBetSize(room: Room): number {\n        const smallBet = room.config.bigBlind; // Small Bet = BBé¡\n        const bigBet = smallBet * 2;           // Big Bet = 2x Small Bet\n\n        const phase = room.gameState.status;\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        // Studç³»: 5th Streetä»¥é™ã¯Big Bet\n        if (variantConfig.communityCardType === 'stud') {\n            if (phase === 'FIFTH_STREET' || phase === 'SIXTH_STREET' || phase === 'SEVENTH_STREET') {\n                return bigBet;\n            }\n            return smallBet;\n        }\n\n        // Drawç³»: å¾ŒåŠã®ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã¯Big Bet\n        if (variantConfig.hasDrawPhase) {\n            const drawRounds = variantConfig.drawRounds || 3;\n            // ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰æ•° = drawRounds + 1 (predraw + å„ãƒ‰ãƒ­ãƒ¼å¾Œ)\n            // Big Betã¯å¾ŒåŠã‹ã‚‰: Math.ceil((drawRounds+1) / 2)\n            // 3ãƒ©ã‚¦ãƒ³ãƒ‰: street 2,3 = Big Bet (SECOND_DRAW, THIRD_DRAW)\n            const bigBetStartStreet = Math.ceil((drawRounds + 1) / 2);\n            if (room.gameState.street >= bigBetStartStreet) {\n                return bigBet;\n            }\n            return smallBet;\n        }\n\n        // Flopç³»: å¾ŒåŠã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã¯Big Bet\n        // æ¨™æº–[3,1,1]: street 2(Turn),3(River) = Big Bet\n        // Ocean[3,1,1,1]: street 2(Turn),3(River),4(Ocean) = Big Bet\n        if (room.gameState.street >= 2) {\n            return bigBet;\n        }\n\n        return smallBet;\n    }\n\n    /**\n     * Fixed-Limitã®ã‚­ãƒ£ãƒƒãƒ—ï¼ˆãƒ¬ã‚¤ã‚ºä¸Šé™å›æ•°ï¼‰ã‚’å–å¾—\n     * é€šå¸¸: 4å›ï¼ˆ5-bet capï¼‰\n     * Heads-Up: ç„¡åˆ¶é™ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰\n     */\n    private getCapLimit(room: Room): number {\n        // Heads-Upï¼ˆ2äººï¼‰ã®å ´åˆã¯ç„¡åˆ¶é™ã‚’è¨±å¯ã™ã‚‹ã‚ªãƒ—ã‚·ãƒ§ãƒ³\n        // ç¾åœ¨ã¯ç°¡æ˜“ç‰ˆã¨ã—ã¦å¸¸ã«4å›ã¨ã™ã‚‹\n        const activePlayers = room.players.filter(p =>\n            p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        ).length;\n\n        // Heads-Upä¾‹å¤–: ç„¡åˆ¶é™ï¼ˆå¤§ããªæ•°ã‚’è¿”ã™ï¼‰\n        // TODO: è¨­å®šã§ ON/OFF å¯èƒ½ã«ã™ã‚‹\n        if (activePlayers === 2) {\n            return 99; // äº‹å®Ÿä¸Šç„¡åˆ¶é™\n        }\n\n        return 4; // 5-bet cap (1 bet + 4 raises)\n    }\n\n    /**\n     * ãƒ‡ãƒƒã‚­ã¸ã®å‚ç…§ã‚’å–å¾—ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰\n     */\n    getDeck(): string[] {\n        return this.deck;\n    }\n\n    /**\n     * ALL INæ™‚ã«æ®‹ã‚Šã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’è‡ªå‹•ã§é…ã‚‹\n     */\n    private dealToShowdown(room: Room): void {\n        const phase = room.gameState.status;\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n\n        if (variantConfig.communityCardType === 'stud') {\n            // Stud: æ®‹ã‚Šã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’é…ã‚‹\n            this.dealStudToShowdown(room, phase);\n        } else if (variantConfig.hasDrawPhase) {\n            // Draw: ã‚«ãƒ¼ãƒ‰äº¤æ›ãªã—ã§ãã®ã¾ã¾ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³\n            console.log(`ğŸ”„ Auto-Showdown: No more draws`);\n            room.gameState.status = 'SHOWDOWN' as any;\n        } else {\n            // Flop games: ãƒœãƒ¼ãƒ‰ã‚’å®Œæˆã•ã›ã‚‹\n            this.dealFlopToShowdown(room, phase);\n        }\n    }\n\n    /**\n     * Flopç³»ã‚²ãƒ¼ãƒ ã®ã‚ªãƒ¼ãƒˆãƒ‡ã‚£ãƒ¼ãƒ«ï¼ˆå…¨ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰ã‚’ä¸€æ°—ã«é…å¸ƒï¼‰\n     * boardPatternã«åŸºã¥ã„ã¦ãƒ‡ãƒ¼ã‚¿é§†å‹•\n     */\n    private dealFlopToShowdown(room: Room, phase: any): void {\n        const variantConfig = getVariantConfig(room.gameState.gameVariant);\n        const boardPattern = variantConfig.boardPattern || [3, 1, 1];\n        const FLOP_PHASES = ['PREFLOP', 'FLOP', 'TURN', 'RIVER', 'OCEAN'];\n\n        const currentStreet = room.gameState.street;\n\n        // æ®‹ã‚Šã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’å…¨ã¦é…å¸ƒ\n        for (let streetIdx = currentStreet + 1; streetIdx <= boardPattern.length; streetIdx++) {\n            const cardCount = boardPattern[streetIdx - 1];\n            const newCards = this.dealer.dealBoardCards(this.deck, cardCount);\n            room.gameState.board.push(...newCards);\n            const phaseName = FLOP_PHASES[streetIdx] || `Street${streetIdx}`;\n            console.log(`ğŸƒ Auto-${phaseName}: ${newCards.join(' ')}`);\n        }\n\n        // æœ€å¾Œã®ãƒ•ã‚§ãƒ¼ã‚ºã«çŠ¶æ…‹ã‚’è¨­å®š\n        const lastStreet = boardPattern.length;\n        const lastPhase = FLOP_PHASES[lastStreet] || 'RIVER';\n        if (currentStreet < lastStreet) {\n            room.gameState.status = lastPhase as any;\n            room.gameState.street = lastStreet;\n        }\n    }\n\n    /**\n     * Studç³»ã‚²ãƒ¼ãƒ ã®ã‚ªãƒ¼ãƒˆãƒ‡ã‚£ãƒ¼ãƒ«\n     */\n    private dealStudToShowdown(room: Room, phase: any): void {\n        const phases = ['THIRD_STREET', 'FOURTH_STREET', 'FIFTH_STREET', 'SIXTH_STREET', 'SEVENTH_STREET'];\n        let currentIdx = phases.indexOf(phase);\n\n        // 3rd Street (PREFLOP)ã‹ã‚‰å§‹ã¾ã‚‹å ´åˆ\n        if (currentIdx === -1 && phase === 'PREFLOP') {\n            currentIdx = 0;\n        }\n\n        // æ®‹ã‚Šã®ã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚’é…ã‚‹\n        while (currentIdx < 4) { // 7th Streetã¾ã§\n            currentIdx++;\n            if (currentIdx <= 3) {\n                // 4th-6th Street: up card\n                this.dealer.dealStudStreet(this.deck, room.players, false);\n                console.log(`ğŸ´ Auto-${phases[currentIdx]}`);\n            } else if (currentIdx === 4) {\n                // 7th Street: down card\n                this.dealer.dealStudStreet(this.deck, room.players, true);\n                console.log(`ğŸ´ Auto-7th Street (down)`);\n            }\n        }\n\n        room.gameState.status = 'SEVENTH_STREET' as any;\n    }\n}\n","usedDeprecatedRules":[]}]
