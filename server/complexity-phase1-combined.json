[{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/ShowdownManager.ts","messages":[{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'executeHiLoShowdown' has too many lines (155). Maximum allowed is 100.","line":425,"column":5,"nodeType":"MethodDefinition","messageId":"exceed","endLine":579,"endColumn":6},{"ruleId":"complexity","severity":1,"message":"Method 'executeHiLoShowdown' has a complexity of 11. Maximum allowed is 10.","line":425,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":425,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Phase 3-B: Showdown Manager\n * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³æ™‚ã®å‹è€…åˆ¤å®šã¨ãƒãƒƒãƒˆåˆ†é…\n */\n\nimport type { Room, Player, PotState } from './types.js';\nimport {\n    evaluateHand,\n    compareHands,\n    evaluateLowHand8OrBetter,\n    evaluateRazzHand,\n    evaluateBadugiHand,\n    evaluateDeuceSeven,\n    compareLowHands,\n    compareBadugiHands,\n    compareDeuceSeven\n} from './handEvaluator.js';\nimport { PotManager } from './PotManager.js';\nimport { getVariantConfig } from './gameVariants.js';\n\n// ã‚«ãƒ¼ãƒ‰æ–‡å­—åˆ—ã‚’Cardã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›\ninterface Card {\n    rank: string;\n    suit: string;\n}\n\nfunction parseCard(cardStr: string): Card {\n    // ã‚«ãƒ¼ãƒ‰æ–‡å­—åˆ—ã¯ \"AS\", \"KH\", \"TD\" ãªã©ã®å½¢å¼\n    // Tã¯10ã‚’è¡¨ã™\n    const rank = cardStr[0] === 'T' ? '10' : cardStr[0];\n    const suit = cardStr[1];\n    return { rank, suit };\n}\n\nfunction parseCards(cards: string[]): Card[] {\n    return cards.map(parseCard);\n}\n\n/**\n * é…åˆ—ã‹ã‚‰nå€‹ã®è¦ç´ ã®çµ„ã¿åˆã‚ã›ã‚’ç”Ÿæˆ\n * @param arr å…ƒã®é…åˆ—\n * @param n é¸æŠã™ã‚‹è¦ç´ æ•°\n * @returns nå€‹ã®è¦ç´ ã®çµ„ã¿åˆã‚ã›ã®é…åˆ—\n */\nfunction combinations<T>(arr: T[], n: number): T[][] {\n    if (n === 0) return [[]];\n    if (n > arr.length) return [];\n\n    const result: T[][] = [];\n\n    function helper(start: number, current: T[]) {\n        if (current.length === n) {\n            result.push([...current]);\n            return;\n        }\n\n        for (let i = start; i <= arr.length - (n - current.length); i++) {\n            current.push(arr[i]);\n            helper(i + 1, current);\n            current.pop();\n        }\n    }\n\n    helper(0, []);\n    return result;\n}\n\n// 7æšã‹ã‚‰æœ€å¼·ã®5æšã‚’é¸ã¶\nfunction getBestFiveCards(cards: Card[]): Card[] {\n    if (cards.length <= 5) return cards;\n\n    // ã™ã¹ã¦ã®5æšã®çµ„ã¿åˆã‚ã›ã‚’è©¦ã™\n    let bestHand = cards.slice(0, 5);\n    let bestRank = evaluateHand(bestHand);\n\n    for (const hand of combinations(cards, 5)) {\n        const rank = evaluateHand(hand);\n        if (rank.rank > bestRank.rank) {\n            bestHand = hand;\n            bestRank = rank;\n        } else if (rank.rank === bestRank.rank) {\n            // åŒã˜å½¹ã®å ´åˆã€é«˜ä½ã‚«ãƒ¼ãƒ‰ã§æ¯”è¼ƒ\n            const comparison = compareHands(hand, bestHand);\n            if (comparison > 0) {\n                bestHand = hand;\n                bestRank = rank;\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// PLOç”¨: æ‰‹æœ­ã‹ã‚‰2æšã€ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšã‚’ä½¿ç”¨ã—ã¦æœ€å¼·ã®5æšã‚’é¸ã¶\nfunction getBestPLOFiveCards(holeCards: Card[], boardCards: Card[]): Card[] {\n    if (holeCards.length < 2 || boardCards.length < 3) {\n        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é€šå¸¸ã®è©•ä¾¡\n        return getBestFiveCards([...holeCards, ...boardCards]);\n    }\n\n    let bestHand = [...holeCards.slice(0, 2), ...boardCards.slice(0, 3)];\n    let bestRank = evaluateHand(bestHand);\n\n    // æ‰‹æœ­ã‹ã‚‰2æšé¸ã¶çµ„ã¿åˆã‚ã› (C(4,2) = 6é€šã‚Šã€ã¾ãŸã¯ C(n,2))\n    const holeCombos = combinations(holeCards, 2);\n    // ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšé¸ã¶çµ„ã¿åˆã‚ã› (C(5,3) = 10é€šã‚Š)\n    const boardCombos = combinations(boardCards, 3);\n\n    for (const holeCombo of holeCombos) {\n        for (const boardCombo of boardCombos) {\n            const hand = [...holeCombo, ...boardCombo];\n            const rank = evaluateHand(hand);\n            if (rank.rank > bestRank.rank) {\n                bestHand = hand;\n                bestRank = rank;\n            } else if (rank.rank === bestRank.rank) {\n                const comparison = compareHands(hand, bestHand);\n                if (comparison > 0) {\n                    bestHand = hand;\n                    bestRank = rank;\n                }\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// PLO8ç”¨: æ‰‹æœ­ã‹ã‚‰2æšã€ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšã‚’ä½¿ç”¨ã—ã¦æœ€å¼·ã®ãƒ­ãƒ¼ãƒãƒ³ãƒ‰5æšã‚’é¸ã¶\nfunction getBestPLOLowFiveCards(holeCards: Card[], boardCards: Card[]): Card[] | null {\n    if (holeCards.length < 2 || boardCards.length < 3) {\n        return null;\n    }\n\n    let bestHand: Card[] | null = null;\n    let bestLow = evaluateLowHand8OrBetter([]);\n\n    // æ‰‹æœ­ã‹ã‚‰2æšé¸ã¶çµ„ã¿åˆã‚ã›\n    const holeCombos = combinations(holeCards, 2);\n    // ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšé¸ã¶çµ„ã¿åˆã‚ã›\n    const boardCombos = combinations(boardCards, 3);\n\n    for (const holeCombo of holeCombos) {\n        for (const boardCombo of boardCombos) {\n            const hand = [...holeCombo, ...boardCombo];\n            const lowResult = evaluateLowHand8OrBetter(hand);\n            if (lowResult.valid) {\n                if (!bestHand || compareLowHands(lowResult, bestLow) > 0) {\n                    bestHand = hand;\n                    bestLow = lowResult;\n                }\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// 7æšã‹ã‚‰æœ€å¼·ã®ãƒ­ãƒ¼ãƒãƒ³ãƒ‰5æšã‚’é¸ã¶ï¼ˆ8-or-betterï¼‰\nfunction getBestLowFiveCards(cards: Card[]): Card[] | null {\n    if (cards.length < 5) return null;\n\n    let bestHand: Card[] | null = null;\n    let bestLow = evaluateLowHand8OrBetter([]);\n\n    // ã™ã¹ã¦ã®5æšã®çµ„ã¿åˆã‚ã›ã‚’è©¦ã™\n    for (const hand of combinations(cards, 5)) {\n        const lowResult = evaluateLowHand8OrBetter(hand);\n        if (lowResult.valid) {\n            if (!bestHand || compareLowHands(lowResult, bestLow) > 0) {\n                bestHand = hand;\n                bestLow = lowResult;\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// Razzç”¨: 7æšã‹ã‚‰æœ€å¼·ã®ãƒ­ãƒ¼ãƒãƒ³ãƒ‰5æšã‚’é¸ã¶\nfunction getBestRazzFiveCards(cards: Card[]): Card[] {\n    if (cards.length <= 5) return cards;\n\n    let bestHand = cards.slice(0, 5);\n    let bestLow = evaluateRazzHand(bestHand);\n\n    for (const hand of combinations(cards, 5)) {\n        const lowResult = evaluateRazzHand(hand);\n        if (compareLowHands(lowResult, bestLow) > 0) {\n            bestHand = hand;\n            bestLow = lowResult;\n        }\n    }\n\n    return bestHand;\n}\n\nexport interface ShowdownResult {\n    winners: {\n        playerId: string;\n        playerName: string;\n        hand: string[];\n        handRank: string;\n        amount: number;\n    }[];\n    allHands: {\n        playerId: string;\n        playerName: string;\n        hand: string[] | null;  // nullã®å ´åˆã¯ãƒãƒƒã‚¯ï¼ˆéè¡¨ç¤ºï¼‰\n        handRank: string;\n        isMucked?: boolean;     // ãƒãƒƒã‚¯ã•ã‚ŒãŸã‹ã©ã†ã‹\n    }[];\n}\n\nexport class ShowdownManager {\n    private potManager: PotManager;\n\n    constructor() {\n        this.potManager = new PotManager();\n    }\n\n    /**\n     * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã‚’æ±ºå®š\n     * - ãƒ©ã‚¹ãƒˆã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ãŒã„ã‚‹å ´åˆ: ã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ã‹ã‚‰æ™‚è¨ˆå›ã‚Š\n     * - ã„ãªã„å ´åˆï¼ˆå…¨å“¡ãƒã‚§ãƒƒã‚¯ï¼‰: ãƒœã‚¿ãƒ³ã®å·¦ï¼ˆSBä½ç½®ï¼‰ã‹ã‚‰æ™‚è¨ˆå›ã‚Š\n     */\n    private getShowdownOrder(room: Room, players: Player[]): Player[] {\n        const maxPlayers = room.config.maxPlayers;\n        const lastAggressorIdx = room.lastAggressorIndex;\n        const buttonIdx = room.dealerBtnIndex;\n\n        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®seatIndexã‚’å–å¾—\n        const playerSeats = players.map(p => {\n            const seatIdx = room.players.findIndex(rp => rp?.socketId === p.socketId);\n            return { player: p, seatIndex: seatIdx };\n        });\n\n        let startIndex: number;\n        if (lastAggressorIdx !== -1 && room.players[lastAggressorIdx]) {\n            // ãƒ©ã‚¹ãƒˆã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ãŒã„ã‚‹å ´åˆã€ãã®äººã‹ã‚‰é–‹å§‹\n            startIndex = lastAggressorIdx;\n        } else {\n            // å…¨å“¡ãƒã‚§ãƒƒã‚¯ã®å ´åˆã€ãƒœã‚¿ãƒ³ã®æ¬¡ï¼ˆSBä½ç½®ï¼‰ã‹ã‚‰é–‹å§‹\n            startIndex = (buttonIdx + 1) % maxPlayers;\n        }\n\n        // startIndexã‹ã‚‰æ™‚è¨ˆå›ã‚Šã«ã‚½ãƒ¼ãƒˆ\n        playerSeats.sort((a, b) => {\n            const distA = (a.seatIndex - startIndex + maxPlayers) % maxPlayers;\n            const distB = (b.seatIndex - startIndex + maxPlayers) % maxPlayers;\n            return distA - distB;\n        });\n\n        return playerSeats.map(ps => ps.player);\n    }\n\n    /**\n     * ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\n     */\n    private hasAllInPlayer(room: Room): boolean {\n        return room.players.some(p => p !== null && p.status === 'ALL_IN');\n    }\n\n    /**\n     * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ã‚’å®Ÿè¡Œã—ã€å‹è€…ã‚’æ±ºå®šã—ã¦ãƒãƒƒãƒˆã‚’åˆ†é…\n     * ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆã«å¿œã˜ãŸè©•ä¾¡ã‚’è¡Œã†\n     */\n    executeShowdown(room: Room): ShowdownResult {\n        const board = room.gameState.board;\n        const variant = room.gameState.gameVariant;\n        const variantConfig = getVariantConfig(variant);\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n        const showdownPlayers = room.players.filter(p =>\n            p !== null &&\n            (p.status === 'ACTIVE' || p.status === 'ALL_IN') &&\n            p.hand !== null\n        ) as Player[];\n\n        if (showdownPlayers.length === 0) {\n            return { winners: [], allHands: [] };\n        }\n\n        // ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆã«å¿œã˜ãŸè©•ä¾¡\n        switch (variantConfig.handEvaluation) {\n            case 'highlow':\n                return this.executeHiLoShowdown(room, showdownPlayers, board);\n            case 'razz':\n                return this.executeRazzShowdown(room, showdownPlayers, board);\n            case 'badugi':\n                return this.executeBadugiShowdown(room, showdownPlayers);\n            case '2-7':\n                return this.executeDeuce7Showdown(room, showdownPlayers);\n            default:\n                return this.executeHighShowdown(room, showdownPlayers, board);\n        }\n    }\n\n    /**\n     * ãƒã‚¤ãƒãƒ³ãƒ‰ã®ã¿ã®è©•ä¾¡ï¼ˆNLH, PLOç­‰ï¼‰\n     */\n    private executeHighShowdown(room: Room, players: Player[], board: string[]): ShowdownResult {\n        const variant = room.gameState.gameVariant;\n        const variantConfig = getVariantConfig(variant);\n        const useOmahaSelection = variantConfig.holeCardsForSelection !== undefined;\n        const isAllInShowdown = this.hasAllInPlayer(room);\n\n        // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã‚’æ±ºå®š\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        // å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹å½¹ã‚’è©•ä¾¡\n        const evaluations = orderedPlayers.map(player => {\n            const holeCards = parseCards(player.hand!);\n            const boardCards = parseCards(board);\n\n            // Omahaç³»: æ‰‹æœ­ã‹ã‚‰å¿…ãšNæšä½¿ç”¨ + ãƒœãƒ¼ãƒ‰3æšã®çµ„ã¿åˆã‚ã›\n            // Hold'emç³»: å…¨ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€å¼·ã®5æš\n            const bestFive = useOmahaSelection\n                ? getBestPLOFiveCards(holeCards, boardCards)\n                : getBestFiveCards([...holeCards, ...boardCards]);\n\n            const handResult = evaluateHand(bestFive);\n\n            return {\n                player,\n                bestFive,\n                handResult,\n                handRank: handResult.name\n            };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œã®ãƒãƒƒãƒˆåˆ†é…ï¼ˆå‹è€…ã®æ±ºå®šï¼‰\n        const winners = this.distributeToWinnersWithSidePots(room, evaluations, compareHands);\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n\n        if (isAllInShowdown) {\n            // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ã®å ´åˆ: å…¨å“¡å¼·åˆ¶ã‚ªãƒ¼ãƒ—ãƒ³ï¼ˆå…±è¬€é˜²æ­¢ï¼‰\n            // ãƒãƒ³ãƒ‰ã¯ã‚³ãƒ”ãƒ¼ã—ã¦å‚ç…§å•é¡Œã‚’é˜²ã\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n            console.log(`ğŸ† All-In Showdown: All hands revealed`);\n        } else {\n            // é€šå¸¸ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³: é †åºã«å¾“ã£ã¦Show/Muckåˆ¤å®š\n            allHands = this.determineShowMuck(evaluations, winnerIds, compareHands);\n        }\n\n        console.log(`ğŸ† Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã«å¾“ã£ã¦Show/Muckã‚’åˆ¤å®š\n     * - 1ç•ªæ‰‹: å¿…ãšShow\n     * - 2ç•ªæ‰‹ä»¥é™: ç¾åœ¨ã®ãƒ™ã‚¹ãƒˆã‚ˆã‚Šå¼·ã„ã‹åŒã˜ãªã‚‰Showã€å¼±ã‘ã‚Œã°Muck\n     */\n    private determineShowMuck<T extends { player: Player; bestFive: Card[]; handRank: string }>(\n        evaluations: T[],\n        winnerIds: Set<string>,\n        compareFunc: (a: Card[], b: Card[]) => number\n    ): ShowdownResult['allHands'] {\n        let currentBestFive: Card[] | null = null;\n\n        return evaluations.map((e, index) => {\n            // 1ç•ªæ‰‹ã¯å¿…ãšShow\n            if (index === 0) {\n                currentBestFive = e.bestFive;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            }\n\n            // 2ç•ªæ‰‹ä»¥é™: ç¾åœ¨ã®ãƒ™ã‚¹ãƒˆã¨æ¯”è¼ƒ\n            const comparison = compareFunc(e.bestFive, currentBestFive!);\n\n            if (comparison > 0) {\n                // å‹ã£ã¦ã„ã‚‹ â†’ Show & ãƒ™ã‚¹ãƒˆæ›´æ–°\n                currentBestFive = e.bestFive;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else if (comparison === 0) {\n                // å¼•ãåˆ†ã‘ â†’ Showï¼ˆãƒãƒƒãƒˆåˆ†å‰²ã®æ¨©åˆ©ï¼‰\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else {\n                // è² ã‘ã¦ã„ã‚‹ â†’ Muck\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: null,\n                    handRank: 'Mucked',\n                    isMucked: true\n                };\n            }\n        });\n    }\n\n    /**\n     * Hi-Loè©•ä¾¡ï¼ˆPLO8, 7CS8ç­‰ï¼‰\n     * ãƒãƒƒãƒˆã‚’ãƒã‚¤ã¨ãƒ­ãƒ¼ã§åŠåˆ†ãšã¤åˆ†ã‘ã‚‹\n     * æ³¨: Hi-Loã§ã¯ã€Highã¾ãŸã¯Lowã®ã„ãšã‚Œã‹ã§å‹ã¦ã‚‹å ´åˆã«Showã€‚ä¸¡æ–¹ã§è² ã‘ã‚‹å ´åˆã®ã¿Muckã€‚\n     */\n    private executeHiLoShowdown(room: Room, players: Player[], board: string[]): ShowdownResult {\n        const variant = room.gameState.gameVariant;\n        const variantConfig = getVariantConfig(variant);\n        const useOmahaSelection = variantConfig.holeCardsForSelection !== undefined;\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        // ãƒã‚¤ãƒãƒ³ãƒ‰è©•ä¾¡ï¼ˆã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã§è©•ä¾¡ï¼‰\n        const highEvaluations = orderedPlayers.map(player => {\n            const holeCards = parseCards(player.hand!);\n            const boardCards = parseCards(board);\n\n            // Omahaç³»: æ‰‹æœ­ã‹ã‚‰å¿…ãšNæšä½¿ç”¨ + ãƒœãƒ¼ãƒ‰3æšã®çµ„ã¿åˆã‚ã›\n            // Studç³»: å…¨ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€å¼·ã®5æš\n            const bestFive = useOmahaSelection\n                ? getBestPLOFiveCards(holeCards, boardCards)\n                : getBestFiveCards([...holeCards, ...boardCards]);\n\n            const handResult = evaluateHand(bestFive);\n            return { player, bestFive, handResult, handRank: handResult.name };\n        });\n\n        // ãƒ­ãƒ¼ãƒãƒ³ãƒ‰è©•ä¾¡\n        const lowEvaluations = orderedPlayers.map(player => {\n            const holeCards = parseCards(player.hand!);\n            const boardCards = parseCards(board);\n\n            // Omahaç³»: æ‰‹æœ­ã‹ã‚‰å¿…ãšNæšä½¿ç”¨ + ãƒœãƒ¼ãƒ‰3æšã®çµ„ã¿åˆã‚ã›\n            // Studç³»: å…¨ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€å¼·ã®5æš\n            const bestLowFive = useOmahaSelection\n                ? getBestPLOLowFiveCards(holeCards, boardCards)\n                : getBestLowFiveCards([...holeCards, ...boardCards]);\n\n            const lowResult = bestLowFive ? evaluateLowHand8OrBetter(bestLowFive) : { valid: false, cards: [], name: 'No Low' };\n            return { player, bestLowFive, lowResult, handRank: lowResult.name };\n        }).filter(e => e.lowResult.valid);\n\n        const winnersMap = new Map<string, { player: Player; amount: number; highRank?: string; lowRank?: string }>();\n\n        const addWinnings = (player: Player, amount: number, side: 'high' | 'low', handRank: string) => {\n            if (amount <= 0) return;\n            const existing = winnersMap.get(player.socketId);\n            if (existing) {\n                existing.amount += amount;\n                if (side === 'high') existing.highRank = handRank;\n                if (side === 'low') existing.lowRank = handRank;\n            } else {\n                winnersMap.set(player.socketId, {\n                    player,\n                    amount,\n                    highRank: side === 'high' ? handRank : undefined,\n                    lowRank: side === 'low' ? handRank : undefined\n                });\n            }\n        };\n\n        const allEligibleIds = highEvaluations.map(e => e.player.socketId);\n        const potSlices = [\n            { amount: room.gameState.pot.main, eligiblePlayers: allEligibleIds },\n            ...room.gameState.pot.side.map(p => ({ amount: p.amount, eligiblePlayers: p.eligiblePlayers }))\n        ];\n\n        for (const pot of potSlices) {\n            if (pot.amount <= 0) continue;\n\n            const eligibleHigh = highEvaluations.filter(e =>\n                pot.eligiblePlayers.includes(e.player.socketId)\n            );\n            if (eligibleHigh.length === 0) continue;\n\n            let bestHighEval = eligibleHigh[0];\n            for (const e of eligibleHigh) {\n                if (compareHands(e.bestFive, bestHighEval.bestFive) > 0) {\n                    bestHighEval = e;\n                }\n            }\n            const highWinners = eligibleHigh.filter(e =>\n                compareHands(e.bestFive, bestHighEval.bestFive) === 0\n            );\n\n            const eligibleLow = lowEvaluations.filter(e =>\n                pot.eligiblePlayers.includes(e.player.socketId)\n            );\n\n            const hasLowWinner = eligibleLow.length > 0;\n            const highPot = hasLowWinner ? Math.floor(pot.amount / 2) : pot.amount;\n            const lowPot = hasLowWinner ? pot.amount - highPot : 0;\n\n            const highShare = Math.floor(highPot / highWinners.length);\n            const highRemainder = highPot % highWinners.length;\n            highWinners.forEach((w, i) => {\n                const amount = highShare + (i < highRemainder ? 1 : 0);\n                w.player.stack += amount;\n                addWinnings(w.player, amount, 'high', w.handRank);\n            });\n\n            if (hasLowWinner) {\n                let bestLowEval = eligibleLow[0];\n                for (const e of eligibleLow) {\n                    if (compareLowHands(e.lowResult, bestLowEval.lowResult) > 0) {\n                        bestLowEval = e;\n                    }\n                }\n                const lowWinners = eligibleLow.filter(e =>\n                    compareLowHands(e.lowResult, bestLowEval.lowResult) === 0\n                );\n\n                const lowShare = Math.floor(lowPot / lowWinners.length);\n                const lowRemainder = lowPot % lowWinners.length;\n                lowWinners.forEach((w, i) => {\n                    const amount = lowShare + (i < lowRemainder ? 1 : 0);\n                    w.player.stack += amount;\n                    addWinnings(w.player, amount, 'low', w.handRank);\n                });\n            }\n        }\n\n        room.gameState.pot = { main: 0, side: [] };\n\n        const winners: ShowdownResult['winners'] = Array.from(winnersMap.values()).map(w => {\n            const rankParts: string[] = [];\n            if (w.highRank) rankParts.push(`High: ${w.highRank}`);\n            if (w.lowRank) rankParts.push(`Low: ${w.lowRank}`);\n            return {\n                playerId: w.player.socketId,\n                playerName: w.player.name,\n                hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: rankParts.join(' / '),\n                amount: w.amount\n            };\n        });\n\n        // å‹è€…ã®IDã‚»ãƒƒãƒˆ\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        const allHands = highEvaluations.map(e => {\n            const isWinner = winnerIds.has(e.player.socketId);\n            const lowEval = lowEvaluations.find(le => le.player.socketId === e.player.socketId);\n            const rankStr = isWinner || isAllInShowdown\n                ? (lowEval ? `High: ${e.handRank} / Low: ${lowEval.handRank}` : `High: ${e.handRank}`)\n                : 'Mucked';\n            return {\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: (isWinner || isAllInShowdown) ? [...e.player.hand!] : null,  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: rankStr,\n                isMucked: !(isWinner || isAllInShowdown)\n            };\n        });\n\n        console.log(`ğŸ† Hi-Lo Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * Razzè©•ä¾¡ï¼ˆæœ€ã‚‚ä½ã„ãƒãƒ³ãƒ‰ãŒå‹ã¡ï¼‰\n     */\n    private executeRazzShowdown(room: Room, players: Player[], board: string[]): ShowdownResult {\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        const evaluations = orderedPlayers.map(player => {\n            const allCards = parseCards([...player.hand!, ...board]);\n            const bestFive = getBestRazzFiveCards(allCards);\n            const handResult = evaluateRazzHand(bestFive);\n            return { player, bestFive, handResult, handRank: handResult.name };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œ: handResultã‚’ä½¿ã£ãŸæ¯”è¼ƒ\n        const winners = this.distributeWithHandResultComparison(\n            room,\n            evaluations,\n            (a, b) => compareLowHands(a.handResult, b.handResult)\n        );\n\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n        if (isAllInShowdown) {\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n        } else {\n            allHands = this.determineShowMuckWithHandResult(\n                evaluations,\n                winnerIds,\n                (a, b) => compareLowHands(a.handResult, b.handResult)\n            );\n        }\n\n        console.log(`ğŸ† Razz Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * Badugiè©•ä¾¡\n     */\n    private executeBadugiShowdown(room: Room, players: Player[]): ShowdownResult {\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        const evaluations = orderedPlayers.map(player => {\n            const cards = parseCards(player.hand!);\n            const handResult = evaluateBadugiHand(cards);\n            return { player, handResult, handRank: handResult.name };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œ\n        const winners = this.distributeWithHandResultComparison(\n            room,\n            evaluations,\n            (a, b) => compareBadugiHands(a.handResult, b.handResult)\n        );\n\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n        if (isAllInShowdown) {\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n        } else {\n            allHands = this.determineShowMuckWithHandResult(\n                evaluations,\n                winnerIds,\n                (a, b) => compareBadugiHands(a.handResult, b.handResult)\n            );\n        }\n\n        console.log(`ğŸ† Badugi Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * 2-7 Lowballè©•ä¾¡\n     */\n    private executeDeuce7Showdown(room: Room, players: Player[]): ShowdownResult {\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        const evaluations = orderedPlayers.map(player => {\n            const cards = parseCards(player.hand!);\n            const handResult = evaluateDeuceSeven(cards);\n            return { player, handResult, handRank: handResult.name };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œ\n        const winners = this.distributeWithHandResultComparison(\n            room,\n            evaluations,\n            (a, b) => compareDeuceSeven(a.handResult, b.handResult)\n        );\n\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n        if (isAllInShowdown) {\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n        } else {\n            allHands = this.determineShowMuckWithHandResult(\n                evaluations,\n                winnerIds,\n                (a, b) => compareDeuceSeven(a.handResult, b.handResult)\n            );\n        }\n\n        console.log(`ğŸ† 2-7 Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * handResultãƒ™ãƒ¼ã‚¹ã®Show/Muckåˆ¤å®šï¼ˆRazz, Badugi, 2-7ç”¨ï¼‰\n     */\n    private determineShowMuckWithHandResult<T extends { player: Player; handResult: any; handRank: string }>(\n        evaluations: T[],\n        winnerIds: Set<string>,\n        compareFunc: (a: T, b: T) => number\n    ): ShowdownResult['allHands'] {\n        let currentBest: T | null = null;\n\n        return evaluations.map((e, index) => {\n            // 1ç•ªæ‰‹ã¯å¿…ãšShow\n            if (index === 0) {\n                currentBest = e;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            }\n\n            // 2ç•ªæ‰‹ä»¥é™: ç¾åœ¨ã®ãƒ™ã‚¹ãƒˆã¨æ¯”è¼ƒ\n            const comparison = compareFunc(e, currentBest!);\n\n            if (comparison > 0) {\n                // å‹ã£ã¦ã„ã‚‹ â†’ Show & ãƒ™ã‚¹ãƒˆæ›´æ–°\n                currentBest = e;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else if (comparison === 0) {\n                // å¼•ãåˆ†ã‘ â†’ Show\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else {\n                // è² ã‘ã¦ã„ã‚‹ â†’ Muck\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: null,\n                    handRank: 'Mucked',\n                    isMucked: true\n                };\n            }\n        });\n    }\n\n    /**\n     * æ±ç”¨çš„ãªã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œåˆ†é…ï¼ˆhandResultã‚’ä½¿ã†æ¯”è¼ƒç”¨ï¼‰\n     */\n    private distributeWithHandResultComparison<T extends { player: Player; handRank: string }>(\n        room: Room,\n        allEvaluations: T[],\n        compareFunc: (a: T, b: T) => number\n    ): ShowdownResult['winners'] {\n        const winnersMap = new Map<string, { player: Player; handRank: string; amount: number }>();\n\n        // ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆã®åˆ†é…\n        if (room.gameState.pot.main > 0 && allEvaluations.length > 0) {\n            let bestEval = allEvaluations[0];\n            for (const e of allEvaluations) {\n                if (compareFunc(e, bestEval) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            const mainWinners = allEvaluations.filter(e => compareFunc(e, bestEval) === 0);\n            const share = Math.floor(room.gameState.pot.main / mainWinners.length);\n            const remainder = room.gameState.pot.main % mainWinners.length;\n\n            mainWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n                winnersMap.set(w.player.socketId, {\n                    player: w.player,\n                    handRank: w.handRank,\n                    amount\n                });\n            });\n        }\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã®åˆ†é…\n        for (const sidePot of room.gameState.pot.side) {\n            if (sidePot.amount <= 0) continue;\n\n            const eligibleEvaluations = allEvaluations.filter(e =>\n                sidePot.eligiblePlayers.includes(e.player.socketId)\n            );\n            if (eligibleEvaluations.length === 0) continue;\n\n            let bestEval = eligibleEvaluations[0];\n            for (const e of eligibleEvaluations) {\n                if (compareFunc(e, bestEval) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            const sideWinners = eligibleEvaluations.filter(e => compareFunc(e, bestEval) === 0);\n            const share = Math.floor(sidePot.amount / sideWinners.length);\n            const remainder = sidePot.amount % sideWinners.length;\n\n            sideWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n\n                const existing = winnersMap.get(w.player.socketId);\n                if (existing) {\n                    existing.amount += amount;\n                } else {\n                    winnersMap.set(w.player.socketId, {\n                        player: w.player,\n                        handRank: w.handRank,\n                        amount\n                    });\n                }\n            });\n        }\n\n        room.gameState.pot = { main: 0, side: [] };\n\n        return Array.from(winnersMap.values()).map(w => ({\n            playerId: w.player.socketId,\n            playerName: w.player.name,\n            hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n            handRank: w.handRank,\n            amount: w.amount\n        }));\n    }\n\n    /**\n     * ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œã®ãƒãƒƒãƒˆåˆ†é…\n     * å„ãƒãƒƒãƒˆã”ã¨ã«å‚åŠ è³‡æ ¼ã®ã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­ã‹ã‚‰å‹è€…ã‚’æ±ºå®š\n     */\n    private distributeToWinnersWithSidePots(\n        room: Room,\n        allEvaluations: { player: Player; bestFive: Card[]; handRank: string }[],\n        compareFunc: (a: Card[], b: Card[]) => number\n    ): ShowdownResult['winners'] {\n        const winnersMap = new Map<string, { player: Player; handRank: string; amount: number }>();\n\n        // å…¨å‚åŠ è€…ã®ã‚½ã‚±ãƒƒãƒˆIDï¼ˆãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆè³‡æ ¼è€…ï¼‰\n        const allPlayerIds = allEvaluations.map(e => e.player.socketId);\n\n        // ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆã®åˆ†é…\n        if (room.gameState.pot.main > 0) {\n            // å…¨å“¡ã®ä¸­ã‹ã‚‰æœ€å¼·ã®ãƒãƒ³ãƒ‰ã‚’è¦‹ã¤ã‘ã‚‹\n            let bestEval = allEvaluations[0];\n            for (const e of allEvaluations) {\n                if (compareFunc(e.bestFive, bestEval.bestFive) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            // åŒç€å‹è€…ã‚’è¦‹ã¤ã‘ã‚‹\n            const mainWinners = allEvaluations.filter(e =>\n                compareFunc(e.bestFive, bestEval.bestFive) === 0\n            );\n\n            const share = Math.floor(room.gameState.pot.main / mainWinners.length);\n            const remainder = room.gameState.pot.main % mainWinners.length;\n\n            mainWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n\n                winnersMap.set(w.player.socketId, {\n                    player: w.player,\n                    handRank: w.handRank,\n                    amount\n                });\n            });\n        }\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã®åˆ†é…\n        for (const sidePot of room.gameState.pot.side) {\n            if (sidePot.amount <= 0) continue;\n\n            // ã“ã®ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã«å‚åŠ è³‡æ ¼ã®ã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è©•ä¾¡ã®ã¿\n            const eligibleEvaluations = allEvaluations.filter(e =>\n                sidePot.eligiblePlayers.includes(e.player.socketId)\n            );\n\n            if (eligibleEvaluations.length === 0) continue;\n\n            // å‚åŠ è³‡æ ¼è€…ã®ä¸­ã‹ã‚‰æœ€å¼·ã®ãƒãƒ³ãƒ‰ã‚’è¦‹ã¤ã‘ã‚‹\n            let bestEval = eligibleEvaluations[0];\n            for (const e of eligibleEvaluations) {\n                if (compareFunc(e.bestFive, bestEval.bestFive) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            // åŒç€å‹è€…ã‚’è¦‹ã¤ã‘ã‚‹\n            const sideWinners = eligibleEvaluations.filter(e =>\n                compareFunc(e.bestFive, bestEval.bestFive) === 0\n            );\n\n            const share = Math.floor(sidePot.amount / sideWinners.length);\n            const remainder = sidePot.amount % sideWinners.length;\n\n            sideWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n\n                const existing = winnersMap.get(w.player.socketId);\n                if (existing) {\n                    existing.amount += amount;\n                } else {\n                    winnersMap.set(w.player.socketId, {\n                        player: w.player,\n                        handRank: w.handRank,\n                        amount\n                    });\n                }\n            });\n        }\n\n        room.gameState.pot = { main: 0, side: [] };\n\n        return Array.from(winnersMap.values()).map(w => ({\n            playerId: w.player.socketId,\n            playerName: w.player.name,\n            hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n            handRank: w.handRank,\n            amount: w.amount\n        }));\n    }\n\n    /**\n     * å‹è€…ã¸ã®ãƒãƒƒãƒˆåˆ†é…å…±é€šå‡¦ç†ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰\n     */\n    private distributeToWinners(room: Room, winningPlayers: any[]): ShowdownResult['winners'] {\n        const totalPot = room.gameState.pot.main +\n            room.gameState.pot.side.reduce((sum, s) => sum + s.amount, 0);\n\n        const share = Math.floor(totalPot / winningPlayers.length);\n        const remainder = totalPot % winningPlayers.length;\n\n        const winners = winningPlayers.map((w, i) => {\n            const amount = share + (i < remainder ? 1 : 0);\n            w.player.stack += amount;\n            return {\n                playerId: w.player.socketId,\n                playerName: w.player.name,\n                hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: w.handRank,\n                amount\n            };\n        });\n\n        room.gameState.pot = { main: 0, side: [] };\n        return winners;\n    }\n\n    /**\n     * 1äººã‚’é™¤ã„ã¦å…¨å“¡ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã—ãŸå ´åˆã®å‡¦ç†\n     * ä¸æˆ¦å‹ã®ãŸã‚ã€å‹è€…ã®ãƒãƒ³ãƒ‰ã¯è¡¨ç¤ºã—ãªã„ï¼ˆMuckæ‰±ã„ï¼‰\n     */\n    awardToLastPlayer(room: Room): ShowdownResult {\n        const lastPlayer = room.players.find(p =>\n            p !== null &&\n            (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        ) as Player | undefined;\n\n        if (!lastPlayer) {\n            return { winners: [], allHands: [] };\n        }\n\n        const totalPot = room.gameState.pot.main +\n            room.gameState.pot.side.reduce((sum, s) => sum + s.amount, 0);\n\n        lastPlayer.stack += totalPot;\n        room.gameState.pot = { main: 0, side: [] };\n\n        console.log(`ğŸ† ${lastPlayer.name} wins ${totalPot} (others folded)`);\n\n        // ä¸æˆ¦å‹: å‹è€…ã®ãƒãƒ³ãƒ‰ã¯è¡¨ç¤ºã—ãªã„ï¼ˆhand: nullï¼‰\n        // ãƒãƒ¼ã‚«ãƒ¼ãƒ«ãƒ¼ãƒ«: ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ã«é€²ã‚“ã§ã„ãªã„ãŸã‚ã€ãƒãƒ³ãƒ‰ã‚’è¦‹ã›ã‚‹ç¾©å‹™ã¯ãªã„\n        return {\n            winners: [{\n                playerId: lastPlayer.socketId,\n                playerName: lastPlayer.name,\n                hand: [],  // ç©ºé…åˆ— = ãƒãƒ³ãƒ‰éè¡¨ç¤º\n                handRank: 'Uncontested',\n                amount: totalPot\n            }],\n            allHands: []\n        };\n    }\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/index.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Function 'processPostAction' has a complexity of 11. Maximum allowed is 10.","line":211,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":211,"endColumn":27},{"ruleId":"complexity","severity":1,"message":"Function 'handleRoomExit' has a complexity of 17. Maximum allowed is 10.","line":402,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":402,"endColumn":24},{"ruleId":"complexity","severity":1,"message":"Function 'validateDrawExchangeRequest' has a complexity of 23. Maximum allowed is 10.","line":749,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":749,"endColumn":37},{"ruleId":"max-lines-per-function","severity":1,"message":"Arrow function has too many lines (731). Maximum allowed is 100.","line":949,"column":21,"nodeType":"ArrowFunctionExpression","messageId":"exceed","endLine":1679,"endColumn":2},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 14. Maximum allowed is 10.","line":956,"column":50,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":956,"endColumn":52},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":977,"column":13,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":981,"endColumn":14},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 11. Maximum allowed is 10.","line":1406,"column":6,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":1406,"endColumn":8}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import express from 'express';\nimport { randomUUID } from 'crypto';\nimport { createServer } from 'http';\nimport { Server } from 'socket.io';\nimport cors from 'cors';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\n\n// ESMç”¨ã®__dirnameå–å¾—\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nimport { evaluateHand, compareHands } from './handEvaluator.js';\nimport { roomManager } from './RoomManager.js';\nimport { GameEngine } from './GameEngine.js';\nimport { ShowdownManager } from './ShowdownManager.js';\nimport { ActionValidator } from './ActionValidator.js';\nimport { Dealer } from './Dealer.js';\nimport type {\n  JoinRoomRequest,\n  SitDownRequest,\n  Player as RoomPlayer,\n  PlayerStatus,\n  ActionType\n} from './types.js';\nimport { RotationManager } from './RotationManager.js';\nimport { MetaGameManager } from './MetaGameManager.js';\nimport { PotManager } from './PotManager.js';\nimport { getVariantConfig } from './gameVariants.js';\nimport { logEvent, incrementMetric } from './logger.js';\nimport authRoutes from './auth/authRoutes.js';\nimport { verifyToken } from './auth/authService.js';\nimport { findRandomEmptySeat } from './autoSeating.js';\n\n// Phase 3-B: ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆéƒ¨å±‹ã”ã¨ã«ç®¡ç†ï¼‰\nconst gameEngines: Map<string, GameEngine> = new Map();\nconst showdownManager = new ShowdownManager();\nconst actionValidator = new ActionValidator();\nconst metaGameManager = new MetaGameManager();\nconst rotationManager = new RotationManager();\nconst potManager = new PotManager();\nconst actionTokens: Map<string, { token: string; issuedAt: number }> = new Map(); // playerId -> token meta\nconst actionInFlight: Set<string> = new Set(); // playerId in progress\nconst roomActionInFlight: Set<string> = new Set(); // roomId in progress\nconst invalidActionCounts: Map<string, { count: number; lastAt: number }> = new Map();\nconst actionRateLimit: Map<string, { count: number; windowStart: number }> = new Map();\n\n// ã‚¿ã‚¤ãƒãƒ¼ç®¡ç†\ninterface PlayerTimer {\n  roomId: string;\n  playerId: string;\n  seconds: number;\n  intervalId: NodeJS.Timeout;\n  timeBankChips: number;\n}\nconst activeTimers: Map<string, PlayerTimer> = new Map(); // playerId -> timer\nconst playerTimeBanks: Map<string, number> = new Map(); // playerId -> chips\n\nconst MAX_TIMER_SECONDS = 30;\nconst INITIAL_TIMEBANK_CHIPS = 5;\nconst HAND_END_DELAY_MS = 2000;\nconst AUTO_START_DELAY_MS = 2000;\nconst ACTION_TOKEN_TTL_MS = 35000;\nconst ACTION_RATE_LIMIT_WINDOW_MS = 2000;\nconst ACTION_RATE_LIMIT_MAX = 6;\n\n// è‡ªå‹•ã‚²ãƒ¼ãƒ é–‹å§‹ç®¡ç†\nconst pendingStarts: Map<string, NodeJS.Timeout> = new Map();\n\nfunction cleanupSocketSession(socketId: string) {\n  clearPlayerTimer(socketId);\n  actionTokens.delete(socketId);\n  actionInFlight.delete(socketId);\n  invalidActionCounts.delete(socketId);\n  actionRateLimit.delete(socketId);\n  playerTimeBanks.delete(socketId);\n}\n\nfunction cleanupPendingLeavers(roomId: string, io: Server): boolean {\n  const room = roomManager.getRoomById(roomId);\n  if (!room) return true;\n\n  let removed = false;\n  room.players.forEach((player, index) => {\n    if (player?.pendingLeave) {\n      cleanupSocketSession(player.socketId);\n      room.players[index] = null;\n      removed = true;\n    }\n  });\n\n  if (removed) {\n    const allEmpty = room.players.every(p => p === null);\n    if (allEmpty && !room.isPreset) {\n      roomManager.deleteRoom(roomId);\n      gameEngines.delete(roomId);\n      roomActionInFlight.delete(roomId);\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n      return true;\n    }\n    io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n  }\n\n  return false;\n}\n\n// ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹é–¢æ•°\nfunction startPlayerTimer(roomId: string, playerId: string, io: Server) {\n  // æ—¢å­˜ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢\n  clearPlayerTimer(playerId);\n\n  // ã‚¿ã‚¤ãƒ ãƒãƒ³ã‚¯åˆæœŸåŒ–ï¼ˆåˆå›ã®ã¿ï¼‰\n  if (!playerTimeBanks.has(playerId)) {\n    playerTimeBanks.set(playerId, INITIAL_TIMEBANK_CHIPS);\n  }\n\n  const timer: PlayerTimer = {\n    roomId,\n    playerId,\n    seconds: MAX_TIMER_SECONDS,\n    intervalId: setInterval(() => {\n      const t = activeTimers.get(playerId);\n      if (!t) return;\n\n      t.seconds--;\n\n      // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°ã‚’é€ä¿¡\n      io.to(playerId).emit('timer-update', { seconds: t.seconds });\n\n      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®è‡ªå‹•ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n      if (t.seconds <= 0) {\n        clearPlayerTimer(playerId);\n        handleTimerTimeout(roomId, playerId, io);\n      }\n    }, 1000),\n    timeBankChips: playerTimeBanks.get(playerId) || INITIAL_TIMEBANK_CHIPS\n  };\n\n  activeTimers.set(playerId, timer);\n}\n\n// ã‚¿ã‚¤ãƒãƒ¼ã‚¯ãƒªã‚¢é–¢æ•°\nfunction clearPlayerTimer(playerId: string) {\n  const timer = activeTimers.get(playerId);\n  if (timer) {\n    clearInterval(timer.intervalId);\n    activeTimers.delete(playerId);\n  }\n}\n\n// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã®è‡ªå‹•ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\nfunction handleTimerTimeout(roomId: string, playerId: string, io: Server) {\n  const room = roomManager.getRoomById(roomId);\n  if (!room) return;\n\n  const engine = gameEngines.get(roomId);\n  if (!engine) return;\n\n  const player = room.players.find(p => p?.socketId === playerId);\n  if (!player) return;\n\n  actionTokens.delete(playerId);\n\n  // ãƒã‚§ãƒƒã‚¯å¯èƒ½ãªã‚‰ãƒã‚§ãƒƒã‚¯ã€ãã†ã§ãªã‘ã‚Œã°ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰\n  const validActions = engine.getValidActions(room, playerId);\n  const actionType: ActionType = validActions.includes('CHECK') ? 'CHECK' : 'FOLD';\n\n  console.log(`â° Timer timeout for ${player.name} - Auto ${actionType}`);\n\n  const result = engine.processAction(room, {\n    playerId,\n    type: actionType,\n    timestamp: Date.now()\n  });\n\n  if (result.success) {\n    // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯ç­‰ã®å‡¦ç†ã¯ player-action ã¨åŒæ§˜ã«è¡Œã†\n    processPostAction(roomId, room, engine, io);\n  }\n}\n\nfunction issueActionToken(playerId: string): string {\n  const token = randomUUID();\n  actionTokens.set(playerId, { token, issuedAt: Date.now() });\n  return token;\n}\n\nfunction emitYourTurn(roomId: string, room: any, engine: GameEngine, io: Server, player: any) {\n  const validActions = engine.getValidActions(room, player.socketId);\n  const bettingInfo = engine.getBettingInfo(room, player.socketId);\n  const actionToken = issueActionToken(player.socketId);\n  io.to(player.socketId).emit('your-turn', {\n    validActions,\n    currentBet: room.gameState.currentBet,\n    minRaise: bettingInfo.minBet,\n    maxBet: bettingInfo.maxBet,\n    betStructure: bettingInfo.betStructure,\n    isCapped: bettingInfo.isCapped,\n    raisesRemaining: bettingInfo.raisesRemaining,\n    fixedBetSize: bettingInfo.fixedBetSize,\n    timeout: MAX_TIMER_SECONDS * 1000,\n    actionToken\n  });\n\n  startPlayerTimer(roomId, player.socketId, io);\n\n  const timeBankChips = playerTimeBanks.get(player.socketId) || INITIAL_TIMEBANK_CHIPS;\n  io.to(player.socketId).emit('timebank-update', { chips: timeBankChips });\n}\n\n// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å¾Œã®å…±é€šå‡¦ç†\nfunction processPostAction(roomId: string, room: any, engine: GameEngine, io: Server) {\n  // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\n  if (room.gameState.status === 'SHOWDOWN') {\n    const activePlayers = room.players.filter((p: any) =>\n      p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n    );\n\n    if (room.gameState.isRunout && activePlayers.length >= 2) {\n      // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ãƒ©ãƒ³ã‚¢ã‚¦ãƒˆã®å‡¦ç†ã¯æ—¢å­˜ã®ã‚³ãƒ¼ãƒ‰ã«ä»»ã›ã‚‹\n      return;\n    }\n\n    let showdownResult;\n    if (activePlayers.length === 1) {\n      showdownResult = showdownManager.awardToLastPlayer(room);\n    } else {\n      const calculatedPots = potManager.calculatePots(room.players);\n      room.gameState.pot = calculatedPots;\n      showdownResult = showdownManager.executeShowdown(room);\n    }\n\n    io.to(`room:${roomId}`).emit('showdown-result', showdownResult);\n\n    // 7-2ãƒœãƒ¼ãƒŠã‚¹ãƒã‚§ãƒƒã‚¯\n    if (showdownResult.winners.length > 0) {\n      for (const winner of showdownResult.winners) {\n        const bonus = metaGameManager.checkSevenDeuce(room, winner.playerId, winner.hand);\n        if (bonus) {\n          io.to(`room:${roomId}`).emit('seven-deuce-bonus', bonus);\n        }\n      }\n    }\n\n    // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯\n    const rotation = rotationManager.checkRotation(room);\n    if (rotation.changed) {\n      io.to(`room:${roomId}`).emit('next-game', {\n        nextGame: rotation.nextGame,\n        gamesList: room.rotation.gamesList\n      });\n    }\n\n    room.gameState.status = 'WAITING' as any;\n\n    // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³å¾Œã®é…å»¶ï¼ˆ1.5ç§’ï¼‰\n    setTimeout(() => {\n      if (cleanupPendingLeavers(roomId, io)) {\n        return;\n      }\n      // æ¬¡ã®ãƒãƒ³ãƒ‰ã‚’è‡ªå‹•é–‹å§‹\n      scheduleNextHand(roomId, io);\n    }, 1500);\n  }\n\n  // å…¨å“¡ã«æ›´æ–°ã‚’é€ä¿¡\n  broadcastRoomState(roomId, room, io);\n\n  // æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n  if (room.activePlayerIndex !== -1) {\n    const nextPlayer = room.players[room.activePlayerIndex];\n    if (nextPlayer) {\n      emitYourTurn(roomId, room, engine, io, nextPlayer);\n    }\n  }\n}\n\n/**\n * è‡ªå‹•ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ©ãƒ¼\n * 2äººä»¥ä¸Šã®ACTIVEãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ã¦WAITINGçŠ¶æ…‹ãªã‚‰ã€è‡ªå‹•ã§ãƒãƒ³ãƒ‰ã‚’é–‹å§‹\n */\nfunction scheduleNextHand(roomId: string, io: Server) {\n  // æ—¢å­˜ã®ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«\n  const existing = pendingStarts.get(roomId);\n  if (existing) {\n    clearTimeout(existing);\n    pendingStarts.delete(roomId);\n  }\n\n  const room = roomManager.getRoomById(roomId);\n  if (!room) return;\n\n  // WAITINGçŠ¶æ…‹ã§ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„\n  if (room.gameState.status !== 'WAITING') return;\n\n  // ACTIVEãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’ç¢ºèªï¼ˆpendingJoinã‚„SIT_OUTã¯é™¤ãï¼‰\n  const activePlayers = room.players.filter(p =>\n    p !== null && p.status !== 'SIT_OUT' && !p.pendingJoin && !p.pendingSitOut && !p.pendingLeave\n  );\n\n  if (activePlayers.length < 2) return;\n\n  const timeout = setTimeout(() => {\n    pendingStarts.delete(roomId);\n\n    const currentRoom = roomManager.getRoomById(roomId);\n    if (!currentRoom || currentRoom.gameState.status !== 'WAITING') return;\n\n    // å†åº¦ACTIVEãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’ãƒã‚§ãƒƒã‚¯\n    const readyPlayers = currentRoom.players.filter(p =>\n      p !== null && p.status !== 'SIT_OUT' && !p.pendingJoin && !p.pendingSitOut && !p.pendingLeave\n    );\n    if (readyPlayers.length < 2) return;\n\n    // GameEngineã‚’å–å¾—ã¾ãŸã¯ä½œæˆ\n    let engine = gameEngines.get(roomId);\n    if (!engine) {\n      engine = new GameEngine();\n      gameEngines.set(roomId, engine);\n    }\n\n    // ãƒãƒ³ãƒ‰ã‚’é–‹å§‹\n    const success = engine.startHand(currentRoom);\n    if (!success) return;\n\n    // å…¨å“¡ã«ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã¨è‡ªåˆ†ã®ãƒãƒ³ãƒ‰ã‚’é€ä¿¡\n    for (const player of currentRoom.players) {\n      if (player) {\n        io.to(player.socketId).emit('game-started', {\n          room: sanitizeRoomForViewer(currentRoom, player.socketId),\n          yourHand: player.hand\n        });\n      }\n    }\n\n    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n    const activePlayer = currentRoom.players[currentRoom.activePlayerIndex];\n    if (activePlayer) {\n      emitYourTurn(roomId, currentRoom, engine, io, activePlayer);\n    }\n\n    console.log(`ğŸ® Auto-started game in room ${roomId}`);\n    logEvent('auto_start', { roomId, playerCount: readyPlayers.length });\n    incrementMetric('auto_start');\n  }, AUTO_START_DELAY_MS);\n\n  pendingStarts.set(roomId, timeout);\n}\n\n/**\n * ãƒ«ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿ã‚’ã‚µãƒ‹ã‚¿ã‚¤ã‚ºï¼ˆä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®handã‚’éš ã™ï¼‰\n * @param room ãƒ«ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ\n * @param viewerSocketId é–²è¦§è€…ã®socketIdï¼ˆã“ã®äººã«ã¯è‡ªåˆ†ã®æ‰‹æœ­ãŒè¦‹ãˆã‚‹ï¼‰\n */\nfunction sanitizeRoomForViewer(room: any, viewerSocketId?: string): any {\n  return {\n    ...room,\n    players: room.players.map((p: any) => {\n      if (!p) return null;\n      const isOwnPlayer = viewerSocketId && p.socketId === viewerSocketId;\n\n      // Studç”¨: 4thã‚¹ãƒˆãƒªãƒ¼ãƒˆã®ã‚«ãƒ¼ãƒ‰ï¼ˆstudUpCards[1]ï¼‰ã¯ä»–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã¯è¦‹ã›ãªã„\n      // è‡ªåˆ†ã«ã¯å…¨ã¦è¦‹ãˆã‚‹ã€ä»–è€…ã«ã¯ãƒ‰ã‚¢ã‚«ãƒ¼ãƒ‰(0)ã¨5th(2)ã€6th(3)ã®ã¿\n      let visibleUpCards = p.studUpCards || [];\n      if (!isOwnPlayer && visibleUpCards.length > 1) {\n        // 4thã‚¹ãƒˆãƒªãƒ¼ãƒˆã‚«ãƒ¼ãƒ‰ï¼ˆindex 1ï¼‰ã‚’é™¤å¤–\n        visibleUpCards = visibleUpCards.filter((_: any, i: number) => i !== 1);\n      }\n\n      return {\n        ...p,\n        // è‡ªåˆ†ä»¥å¤–ã®handã¯éš ã™\n        hand: isOwnPlayer ? p.hand : null,\n        // studUpCardsã¯4thã‚¹ãƒˆãƒªãƒ¼ãƒˆä»¥å¤–ã‚’ä»–è€…ã«å…¬é–‹\n        studUpCards: visibleUpCards\n      };\n    })\n  };\n}\n\nfunction broadcastRoomState(roomId: string, room: any, io: Server) {\n  void io.in(`room:${roomId}`).fetchSockets()\n    .then(sockets => {\n      for (const sock of sockets) {\n        sock.emit('room-state-update', sanitizeRoomForViewer(room, sock.id));\n      }\n    })\n    .catch(error => {\n      console.error('âŒ Failed to broadcast room-state-update', {\n        roomId,\n        error: error instanceof Error ? error.message : error\n      });\n    });\n}\n\n// ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°: socketã‹ã‚‰roomIdã‚’å–å¾—\nfunction getRoomIdFromSocket(socket: any): string | null {\n  const rooms = Array.from(socket.rooms) as string[];\n  const roomEntry = rooms.find((r: string) => r.startsWith('room:'));\n  return roomEntry ? roomEntry.slice(5) : null;\n}\n\nfunction handleRoomExit(\n  socket: any,\n  roomId: string,\n  io: Server,\n  options: { leaveRoom?: boolean } = {}\n) {\n  const room = roomManager.getRoomById(roomId);\n  cleanupSocketSession(socket.id);\n  const leaveRoom = options.leaveRoom !== false;\n\n  if (!room) {\n    if (leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n    return;\n  }\n\n  const seatIndex = room.players.findIndex(p => p?.socketId === socket.id);\n  if (seatIndex === -1) {\n    if (leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n    return;\n  }\n\n  const player = room.players[seatIndex]!;\n  const isInHand = room.gameState.status !== 'WAITING';\n\n  if (isInHand) {\n    player.pendingLeave = true;\n    player.pendingSitOut = true;\n    player.pendingJoin = false;\n    player.waitingForBB = false;\n    player.disconnected = true;\n\n    const engine = gameEngines.get(roomId);\n    const isActivePlayer = room.activePlayerIndex === seatIndex;\n    let actionProcessed = false;\n\n    if (engine && isActivePlayer && player.status === 'ACTIVE') {\n      const result = engine.processAction(room, {\n        playerId: socket.id,\n        type: 'FOLD' as ActionType,\n        timestamp: Date.now()\n      });\n\n      if (result.success) {\n        processPostAction(roomId, room, engine, io);\n        actionProcessed = true;\n      } else {\n        player.status = 'FOLDED';\n      }\n    } else if (player.status === 'ACTIVE') {\n      player.status = 'FOLDED';\n    }\n\n    if (leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n    if (!actionProcessed) {\n      broadcastRoomState(roomId, room, io);\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n    }\n    return;\n  }\n\n  roomManager.standUp(roomId, socket.id);\n  if (leaveRoom) {\n    socket.leave(`room:${roomId}`);\n  }\n\n  const roomStillExists = roomManager.getRoomById(roomId);\n  if (roomStillExists) {\n    broadcastRoomState(roomId, roomStillExists, io);\n  } else {\n    gameEngines.delete(roomId);\n    roomActionInFlight.delete(roomId);\n    if (!leaveRoom) {\n      socket.leave(`room:${roomId}`);\n    }\n  }\n\n  io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n}\n\nfunction getRoomIdOrError(socket: any): string | null {\n  const roomId = getRoomIdFromSocket(socket);\n  if (!roomId) {\n    socket.emit('error', { message: 'You are not in any room' });\n    return null;\n  }\n  return roomId;\n}\n\nfunction getRoomOrError(roomId: string, socket: any) {\n  const room = roomManager.getRoomById(roomId);\n  if (!room) {\n    socket.emit('error', { message: 'Room not found' });\n    return null;\n  }\n  return room;\n}\n\nfunction getEngineOrError(roomId: string, socket: any) {\n  const engine = gameEngines.get(roomId);\n  if (!engine) {\n    socket.emit('error', { message: 'Game not started' });\n    return null;\n  }\n  return engine;\n}\n\nfunction checkActionRateLimit(socket: any, roomId: string, now: number): boolean {\n  const rate = actionRateLimit.get(socket.id);\n  if (!rate || now - rate.windowStart > ACTION_RATE_LIMIT_WINDOW_MS) {\n    actionRateLimit.set(socket.id, { count: 1, windowStart: now });\n    return true;\n  }\n\n  rate.count += 1;\n  if (rate.count > ACTION_RATE_LIMIT_MAX) {\n    const ip = socket.handshake.address;\n    console.warn(`âš ï¸ Rate limit: ${socket.id} (${ip}) ${rate.count}/${ACTION_RATE_LIMIT_WINDOW_MS}ms`);\n    socket.emit('action-invalid', { reason: 'Too many actions' });\n    logEvent('rate_limited', { roomId, playerId: socket.id, ip, count: rate.count });\n    incrementMetric('rate_limited');\n    return false;\n  }\n\n  return true;\n}\n\nfunction validateActionToken(socket: any, roomId: string, token: string | undefined, now: number): boolean {\n  const expectedToken = actionTokens.get(socket.id);\n  if (!token || !expectedToken || token !== expectedToken.token) {\n    socket.emit('action-invalid', { reason: 'Invalid action token' });\n    logEvent('action_invalid', { roomId, playerId: socket.id, reason: 'Invalid action token' });\n    incrementMetric('action_invalid', { reason: 'invalid_token' });\n    const stats = invalidActionCounts.get(socket.id);\n    if (!stats || now - stats.lastAt > 5000) {\n      invalidActionCounts.set(socket.id, { count: 1, lastAt: now });\n    } else {\n      stats.count += 1;\n      stats.lastAt = now;\n      if (stats.count >= 3) {\n        console.warn(`âš ï¸ Repeated invalid actions from ${socket.id} (${stats.count} in 5s)`);\n        logEvent('invalid_action_spam', { roomId, playerId: socket.id, count: stats.count });\n        incrementMetric('invalid_action_spam');\n      }\n    }\n    return false;\n  }\n\n  if (now - expectedToken.issuedAt > ACTION_TOKEN_TTL_MS) {\n    actionTokens.delete(socket.id);\n    socket.emit('action-invalid', { reason: 'Action token expired' });\n    logEvent('action_invalid', { roomId, playerId: socket.id, reason: 'Action token expired' });\n    incrementMetric('action_invalid', { reason: 'token_expired' });\n    return false;\n  }\n\n  return true;\n}\n\nfunction validatePlayerActionRequest(\n  socket: any,\n  data: { type: ActionType; amount?: number; actionToken?: string }\n): { roomId: string; room: any; engine: GameEngine } | null {\n  const roomId = getRoomIdOrError(socket);\n  if (!roomId) return null;\n  const room = getRoomOrError(roomId, socket);\n  if (!room) return null;\n  const engine = getEngineOrError(roomId, socket);\n  if (!engine) return null;\n\n  if (roomActionInFlight.has(roomId)) {\n    socket.emit('action-invalid', { reason: 'Room is processing another action' });\n    return null;\n  }\n\n  if (room.gameState.isDrawPhase) {\n    socket.emit('action-invalid', { reason: 'Draw phase in progress' });\n    logEvent('action_invalid', { roomId, playerId: socket.id, reason: 'Draw phase in progress' });\n    incrementMetric('action_invalid', { reason: 'draw_phase' });\n    return null;\n  }\n\n  const now = Date.now();\n  if (!checkActionRateLimit(socket, roomId, now)) {\n    return null;\n  }\n  if (!validateActionToken(socket, roomId, data.actionToken, now)) {\n    return null;\n  }\n\n  if (actionInFlight.has(socket.id)) {\n    socket.emit('action-invalid', { reason: 'Action already in progress' });\n    return null;\n  }\n\n  return { roomId, room, engine };\n}\n\nfunction handleAllInRunout(roomId: string, room: any, io: Server) {\n  const runoutPhase = room.gameState.runoutPhase || 'PREFLOP';\n  const board = room.gameState.board;\n  const DELAY = 1500; // 1.5ç§’\n\n  console.log(`ğŸ¬ Starting all-in runout from ${runoutPhase}`);\n\n  io.to(`room:${roomId}`).emit('runout-started', {\n    runoutPhase,\n    fullBoard: board\n  });\n\n  const scheduleRunout = async () => {\n    if (runoutPhase === 'PREFLOP') {\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 3), phase: 'FLOP' });\n\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 4), phase: 'TURN' });\n\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 5), phase: 'RIVER' });\n\n    } else if (runoutPhase === 'FLOP') {\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 4), phase: 'TURN' });\n\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 5), phase: 'RIVER' });\n\n    } else if (runoutPhase === 'TURN') {\n      await new Promise(r => setTimeout(r, DELAY));\n      io.to(`room:${roomId}`).emit('runout-board', { board: board.slice(0, 5), phase: 'RIVER' });\n    }\n\n    await new Promise(r => setTimeout(r, DELAY));\n\n    const calculatedPots = potManager.calculatePots(room.players);\n    room.gameState.pot = calculatedPots;\n    console.log(`ğŸ’° Pots calculated: Main=${calculatedPots.main}, Sides=${calculatedPots.side.map(s => s.amount).join(',')}`);\n\n    const showdownResult = showdownManager.executeShowdown(room);\n    io.to(`room:${roomId}`).emit('showdown-result', showdownResult);\n\n    if (showdownResult.winners.length > 0) {\n      for (const winner of showdownResult.winners) {\n        const bonus = metaGameManager.checkSevenDeuce(room, winner.playerId, winner.hand);\n        if (bonus) {\n          io.to(`room:${roomId}`).emit('seven-deuce-bonus', bonus);\n          console.log(`ğŸ² 7-2 BONUS: ${winner.playerName} wins ${bonus.amount}`);\n        }\n      }\n    }\n\n    const rotation = rotationManager.checkRotation(room);\n    if (rotation.changed) {\n      console.log(`ğŸ”„ Next game: ${rotation.nextGame}`);\n      io.to(`room:${roomId}`).emit('next-game', {\n        nextGame: rotation.nextGame,\n        gamesList: room.rotation.gamesList\n      });\n    }\n\n    room.gameState.isRunout = false;\n    room.gameState.runoutPhase = undefined;\n    room.gameState.status = 'WAITING' as any;\n\n    broadcastRoomState(roomId, room, io);\n\n    setTimeout(() => {\n      if (cleanupPendingLeavers(roomId, io)) {\n        return;\n      }\n      scheduleNextHand(roomId, io);\n    }, 1500);\n  };\n\n  scheduleRunout();\n}\n\nfunction handleNormalShowdown(roomId: string, room: any, io: Server) {\n  let showdownResult;\n  const activePlayers = room.players.filter(p =>\n    p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n  );\n\n  if (activePlayers.length === 1) {\n    showdownResult = showdownManager.awardToLastPlayer(room);\n  } else {\n    const calculatedPots = potManager.calculatePots(room.players);\n    room.gameState.pot = calculatedPots;\n    console.log(`ğŸ’° Pots calculated: Main=${calculatedPots.main}, Sides=${calculatedPots.side.map(s => s.amount).join(',')}`);\n    showdownResult = showdownManager.executeShowdown(room);\n  }\n\n  io.to(`room:${roomId}`).emit('showdown-result', showdownResult);\n\n  if (showdownResult.winners.length > 0) {\n    for (const winner of showdownResult.winners) {\n      const bonus = metaGameManager.checkSevenDeuce(room, winner.playerId, winner.hand);\n      if (bonus) {\n        io.to(`room:${roomId}`).emit('seven-deuce-bonus', bonus);\n        console.log(`ğŸ² 7-2 BONUS: ${winner.playerName} wins ${bonus.amount}`);\n      }\n    }\n  }\n\n  const rotation = rotationManager.checkRotation(room);\n  if (rotation.changed) {\n    console.log(`ğŸ”„ Next game: ${rotation.nextGame}`);\n    io.to(`room:${roomId}`).emit('next-game', {\n      nextGame: rotation.nextGame,\n      gamesList: room.rotation.gamesList\n    });\n  }\n\n  room.gameState.status = 'WAITING' as any;\n\n  setTimeout(() => {\n    if (cleanupPendingLeavers(roomId, io)) {\n      return;\n    }\n    scheduleNextHand(roomId, io);\n  }, 1500);\n}\n\nfunction maybeHandleShowdown(roomId: string, room: any, io: Server): boolean {\n  if (room.gameState.status !== 'SHOWDOWN') {\n    return false;\n  }\n\n  const activePlayers = room.players.filter(p =>\n    p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n  );\n\n  if (room.gameState.isRunout && activePlayers.length >= 2) {\n    handleAllInRunout(roomId, room, io);\n    return true;\n  }\n\n  handleNormalShowdown(roomId, room, io);\n  return false;\n}\n\nfunction validateDrawExchangeRequest(\n  socket: any,\n  data: { discardIndexes: number[] }\n): { roomId: string; room: any; engine: GameEngine; player: RoomPlayer; discardIndexes: number[] } | null {\n  const roomId = getRoomIdOrError(socket);\n  if (!roomId) return null;\n  const room = getRoomOrError(roomId, socket);\n  if (!room) return null;\n  const engine = getEngineOrError(roomId, socket);\n  if (!engine) return null;\n\n  const player = room.players.find(p => p?.socketId === socket.id);\n  if (!player) {\n    socket.emit('error', { message: 'Player not found' });\n    return null;\n  }\n\n  const status = room.gameState.status;\n  const isDrawPhase = room.gameState.isDrawPhase;\n  if (!isDrawPhase || (status !== 'FIRST_DRAW' && status !== 'SECOND_DRAW' && status !== 'THIRD_DRAW')) {\n    socket.emit('error', { message: 'Not in draw exchange phase' });\n    return null;\n  }\n\n  if (player.status !== 'ACTIVE' && player.status !== 'ALL_IN') {\n    socket.emit('error', { message: 'You cannot draw' });\n    return null;\n  }\n\n  const completedDraw = room.gameState.playersCompletedDraw || [];\n  if (completedDraw.includes(socket.id)) {\n    socket.emit('error', { message: 'You have already drawn this round' });\n    return null;\n  }\n\n  const variantConfig = getVariantConfig(room.gameState.gameVariant);\n  const maxDrawCount = variantConfig.maxDrawCount ?? player.hand?.length ?? 0;\n  const discardIndexes = Array.isArray(data.discardIndexes) ? data.discardIndexes : [];\n  const uniqueIndexes = new Set<number>();\n  for (const idx of discardIndexes) {\n    if (!Number.isInteger(idx)) {\n      socket.emit('error', { message: 'Invalid discard index' });\n      return null;\n    }\n    uniqueIndexes.add(idx);\n  }\n  if (discardIndexes.length !== uniqueIndexes.size) {\n    socket.emit('error', { message: 'Duplicate discard indexes' });\n    return null;\n  }\n  if (discardIndexes.length > maxDrawCount) {\n    socket.emit('error', { message: `Too many cards to discard (max ${maxDrawCount})` });\n    return null;\n  }\n  if (!player.hand || discardIndexes.some(idx => idx < 0 || idx >= player.hand.length)) {\n    socket.emit('error', { message: 'Discard index out of range' });\n    return null;\n  }\n\n  return { roomId, room, engine, player, discardIndexes };\n}\n\nfunction validateQuickJoinBuyIn(room: any, buyIn: number, socket: any): boolean {\n  const minBuyIn = room.config.buyInMin || room.config.bigBlind * 20;\n  const maxBuyIn = room.config.buyInMax || room.config.bigBlind * 100;\n  if (buyIn < minBuyIn || buyIn > maxBuyIn) {\n    socket.emit('error', { message: `Buy-in must be between ${minBuyIn} and ${maxBuyIn}` });\n    return false;\n  }\n  return true;\n}\n\nfunction removeExistingPlayerSession(room: any, socket: any, user: any, roomId: string) {\n  const existingPlayerIndex = room.players.findIndex(p => {\n    if (!p) return false;\n    if (p.socketId === socket.id) return true;\n    if (user?.userId && p.userId === user.userId) return true;\n    return false;\n  });\n\n  if (existingPlayerIndex === -1) return;\n\n  const oldPlayer = room.players[existingPlayerIndex]!;\n  console.log(`ğŸ”„ Removing old session for ${oldPlayer.name} (old: ${oldPlayer.socketId}, new: ${socket.id})`);\n\n  if (room.gameState.status !== 'WAITING') {\n    const engine = gameEngines.get(roomId);\n    if (engine && room.activePlayerIndex === existingPlayerIndex && oldPlayer.status === 'ACTIVE') {\n      engine.processAction(room, {\n        playerId: oldPlayer.socketId,\n        type: 'FOLD' as ActionType,\n        timestamp: Date.now()\n      });\n    }\n  }\n\n  room.players[existingPlayerIndex] = null;\n}\n\nfunction createQuickJoinPlayer(socket: any, user: any, room: any, buyIn: number): RoomPlayer {\n  const variantConfig = getVariantConfig(room.gameState.gameVariant);\n  const isWaiting = room.gameState.status === 'WAITING';\n  return {\n    socketId: socket.id,\n    name: user?.displayName || 'Guest',\n    stack: buyIn,\n    bet: 0,\n    totalBet: 0,\n    status: (isWaiting ? 'ACTIVE' : 'SIT_OUT') as PlayerStatus,\n    hand: null,\n    pendingJoin: !isWaiting,\n    waitingForBB: !isWaiting && variantConfig.hasButton,\n    disconnected: false,\n    userId: user?.userId,\n    avatarIcon: user?.avatarIcon\n  };\n}\n\nconst app = express();\nconst isProduction = process.env.NODE_ENV === 'production';\n\n// CORSè¨­å®š: æœ¬ç•ªç’°å¢ƒã§ã¯åŒä¸€ã‚ªãƒªã‚¸ãƒ³ã€é–‹ç™ºç’°å¢ƒã§ã¯è¤‡æ•°ãƒãƒ¼ãƒˆè¨±å¯\nconst ALLOWED_ORIGINS: string[] = isProduction\n  ? [process.env.CLIENT_URL].filter((url): url is string => Boolean(url))\n  : [\n      'http://localhost:5173',\n      'http://localhost:5174',\n      'http://localhost:5175',\n      process.env.CLIENT_URL\n    ].filter((url): url is string => Boolean(url));\n\napp.use(cors({\n  origin: (origin, callback) => {\n    // originãŒãªã„å ´åˆï¼ˆåŒä¸€ã‚ªãƒªã‚¸ãƒ³ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼‰ã¾ãŸã¯è¨±å¯ãƒªã‚¹ãƒˆã«å«ã¾ã‚Œã‚‹å ´åˆã¯è¨±å¯\n    if (!origin || ALLOWED_ORIGINS.includes(origin) || isProduction) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true\n}));\n\n// JSON bodyãƒ‘ãƒ¼ã‚µãƒ¼\napp.use(express.json());\n\n// èªè¨¼APIãƒ«ãƒ¼ãƒˆ\napp.use('/api/auth', authRoutes);\n\n// ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ç”¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆå…¨ç’°å¢ƒå…±é€šï¼‰\napp.get('/api/health', (_req, res) => {\n  res.json({ status: 'ok', message: 'Mix Poker Game Server is running' });\n});\n\n// æœ¬ç•ªç’°å¢ƒ: é™çš„ãƒ•ã‚¡ã‚¤ãƒ«é…ä¿¡\nif (isProduction) {\n  const clientDistPath = path.join(__dirname, '../../client/dist');\n  app.use(express.static(clientDistPath));\n\n  // APIä»¥å¤–ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯index.htmlã‚’è¿”ã™ï¼ˆSPAå¯¾å¿œï¼‰\n  // Express 5ã§ã¯ãƒ¯ã‚¤ãƒ«ãƒ‰ã‚«ãƒ¼ãƒ‰ã«åå‰ä»˜ããƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒå¿…è¦\n  app.get('/{*splat}', (req, res, next) => {\n    // Socket.IOã‚„APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯é™¤å¤–\n    if (req.path.startsWith('/socket.io') || req.path.startsWith('/api/')) {\n      return next();\n    }\n    res.sendFile(path.join(clientDistPath, 'index.html'));\n  });\n} else {\n  app.get('/', (req, res) => {\n    res.json({ status: 'ok', message: 'Mix Poker Game Server is running' });\n  });\n}\n\nconst httpServer = createServer(app);\n// Socket.ioã®è¨­å®š (CORSè¨±å¯)\nconst io = new Server(httpServer, {\n  cors: {\n    origin: ALLOWED_ORIGINS,\n    methods: [\"GET\", \"POST\"],\n    credentials: true\n  }\n});\n\n// Socket.IOèªè¨¼ãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢\nio.use((socket, next) => {\n  const token = socket.handshake.auth?.token;\n  if (token) {\n    const user = verifyToken(token);\n    if (user) {\n      socket.data.user = user;\n      return next();\n    }\n  }\n  // èªè¨¼ãªã—ã§ã‚‚æ¥ç¶šã‚’è¨±å¯ï¼ˆã‚²ã‚¹ãƒˆå¯¾å¿œã®ä½™åœ°ï¼‰\n  // ãŸã ã—useræƒ…å ±ã¯null\n  socket.data.user = null;\n  next();\n});\n\nio.on('connection', (socket) => {\n  const user = socket.data.user;\n  console.log(`ğŸ”¥ Player connected! ID: ${socket.id}, User: ${user?.displayName || 'Guest'}`);\n\n  // ========== Room Management Events ==========\n\n  // éƒ¨å±‹å‚åŠ \n  socket.on('join-room', (data: JoinRoomRequest) => {\n    try {\n      const existingRoomId = getRoomIdFromSocket(socket);\n      if (existingRoomId && existingRoomId !== data.roomId) {\n        handleRoomExit(socket, existingRoomId, io);\n      }\n\n      const room = roomManager.getRoomById(data.roomId);\n\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      if (data.resumeToken) {\n        const existingPlayer = room.players.find(p => p?.resumeToken === data.resumeToken);\n        if (existingPlayer) {\n          const previousSocketId = existingPlayer.socketId;\n          if (previousSocketId !== socket.id) {\n            cleanupSocketSession(previousSocketId);\n            const oldSocket = io.sockets.sockets.get(previousSocketId);\n            if (oldSocket) {\n              oldSocket.leave(`room:${data.roomId}`);\n              oldSocket.emit('error', { message: 'Session replaced by reconnection' });\n              oldSocket.disconnect(true);\n            }\n          }\n\n          existingPlayer.socketId = socket.id;\n          existingPlayer.disconnected = false;\n          (socket.data as any).playerName = existingPlayer.name;\n          if (room.gameState.status === 'WAITING' && existingPlayer.status === 'SIT_OUT' && !existingPlayer.pendingSitOut) {\n            existingPlayer.status = 'ACTIVE';\n          } else if (room.gameState.status !== 'WAITING') {\n            existingPlayer.pendingJoin = true;\n          }\n\n          socket.join(`room:${data.roomId}`);\n          (socket.data as any).roomId = data.roomId;\n          socket.emit('room-joined', {\n            room: sanitizeRoomForViewer(room, socket.id),\n            yourSocketId: socket.id,\n            yourHand: existingPlayer.hand || null\n          });\n          logEvent('room_resumed', { roomId: data.roomId, playerName: existingPlayer.name });\n          incrementMetric('room_resumed');\n          broadcastRoomState(data.roomId, room, io);\n          return;\n        }\n      }\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åã‚’socket.dataã«ä¿å­˜ï¼ˆsit-downæ™‚ã«ä½¿ç”¨ï¼‰\n      (socket.data as any).playerName = data.playerName;\n\n      // Socket.IOã®ãƒ«ãƒ¼ãƒ ã«å‚åŠ \n      socket.join(`room:${data.roomId}`);\n      (socket.data as any).roomId = data.roomId;\n      (socket.data as any).roomId = data.roomId;\n\n      socket.emit('room-joined', {\n        room: sanitizeRoomForViewer(room, socket.id),\n        yourSocketId: socket.id,\n        yourHand: null\n      });\n\n      console.log(`ğŸšª ${data.playerName} joined room ${data.roomId}`);\n      logEvent('room_joined', { roomId: data.roomId, playerName: data.playerName });\n      incrementMetric('room_joined');\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // éƒ¨å±‹ãƒªã‚¹ãƒˆå–å¾—ï¼ˆãƒ­ãƒ“ãƒ¼ç”¨ï¼‰\n  socket.on('get-room-list', () => {\n    // ãƒ­ãƒ“ãƒ¼ã®Socket.IOãƒ«ãƒ¼ãƒ ã«å‚åŠ \n    socket.join('lobby');\n    socket.emit('room-list-update', roomManager.getAllRooms());\n  });\n\n  // éƒ¨å±‹é€€å‡º\n  socket.on('leave-room', () => {\n    const roomId = getRoomIdFromSocket(socket);\n    if (!roomId) return;\n    try {\n      handleRoomExit(socket, roomId, io, { leaveRoom: true });\n      if ((socket.data as any).roomId === roomId) {\n        delete (socket.data as any).roomId;\n      }\n    } catch (error) {\n      // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–\n    }\n  });\n\n  // ç€å¸­\n  socket.on('sit-down', (data: SitDownRequest) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // socket.dataã«playerNameã‚’ä¿å­˜ã—ã¦ãŠãï¼ˆjoin-roomæ™‚ã«è¨­å®šã™ã‚‹ã“ã¨ã‚’æƒ³å®šï¼‰\n      const playerName = (socket.data as any).playerName || 'Anonymous';\n      const variantConfig = getVariantConfig(room.gameState.gameVariant);\n      const isWaiting = room.gameState.status === 'WAITING';\n\n      // ç€å¸­ã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’ä½œæˆ\n      const player: RoomPlayer = {\n        socketId: socket.id,\n        name: playerName,\n        stack: data.buyIn,\n        bet: 0,\n        totalBet: 0,\n        status: (isWaiting ? 'ACTIVE' : 'SIT_OUT') as PlayerStatus,\n        hand: null,\n        resumeToken: data.resumeToken,\n        pendingJoin: !isWaiting,\n        waitingForBB: !isWaiting && variantConfig.hasButton,\n        disconnected: false\n      };\n\n      roomManager.sitDown(roomId, data.seatIndex, player);\n\n      console.log(`âœ… ${playerName} sat down at seat ${data.seatIndex}`);\n      logEvent('sit_down', { roomId, playerName, seatIndex: data.seatIndex });\n      incrementMetric('sit_down');\n\n      // ç€å¸­æˆåŠŸã‚’é€šçŸ¥ï¼ˆæœ¬äººï¼‰\n      socket.emit('sit-down-success', { seatIndex: data.seatIndex });\n\n      // éƒ¨å±‹å†…ã®å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n\n      // ãƒ­ãƒ“ãƒ¼ã«éƒ¨å±‹ãƒªã‚¹ãƒˆæ›´æ–°ã‚’é€šçŸ¥\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n\n    } catch (error: any) {\n      console.error(`âŒ Sit-down failed: ${error.message}`);\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ã‚¯ã‚¤ãƒƒã‚¯å‚åŠ ï¼ˆjoin-room + è‡ªå‹•ç€å¸­ã‚’1ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã§ï¼‰\n  socket.on('quick-join', (data: { roomId: string; buyIn: number }) => {\n    try {\n      // æ—¢ã«åˆ¥ã®éƒ¨å±‹ã«ã„ã‚‹å ´åˆã¯é€€å‡º\n      const existingRoomId = getRoomIdFromSocket(socket);\n      if (existingRoomId && existingRoomId !== data.roomId) {\n        handleRoomExit(socket, existingRoomId, io);\n      }\n\n      const room = roomManager.getRoomById(data.roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ãƒã‚¤ã‚¤ãƒ³é¡ãƒã‚§ãƒƒã‚¯\n      if (!validateQuickJoinBuyIn(room, data.buyIn, socket)) {\n        return;\n      }\n\n      // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’å–å¾—\n      const user = socket.data?.user;\n      const playerName = user?.displayName || 'Guest';\n\n      removeExistingPlayerSession(room, socket, user, data.roomId);\n\n      // ç©ºå¸­ã‚’æ¢ã™\n      const seatIndex = findRandomEmptySeat(room.players);\n      if (seatIndex === null) {\n        socket.emit('error', { message: 'Room is full' });\n        return;\n      }\n\n      // socket.dataã«playerNameã‚’ä¿å­˜\n      (socket.data as any).playerName = playerName;\n\n      // Socket.IOã®ãƒ«ãƒ¼ãƒ ã«å‚åŠ \n      socket.join(`room:${data.roomId}`);\n      (socket.data as any).roomId = data.roomId;\n      // ãƒ­ãƒ“ãƒ¼ã‹ã‚‰é›¢è„±\n      socket.leave('lobby');\n\n      const player = createQuickJoinPlayer(socket, user, room, data.buyIn);\n\n      roomManager.sitDown(data.roomId, seatIndex, player);\n\n      console.log(`âš¡ ${playerName} quick-joined room ${data.roomId} at seat ${seatIndex}`);\n      logEvent('quick_join', { roomId: data.roomId, playerName, seatIndex, buyIn: data.buyIn });\n      incrementMetric('quick_join');\n\n      // å‚åŠ æˆåŠŸã‚’é€šçŸ¥ï¼ˆæœ¬äººï¼‰\n      socket.emit('room-joined', {\n        room: sanitizeRoomForViewer(room, socket.id),\n        yourSocketId: socket.id,\n        yourHand: null\n      });\n      socket.emit('sit-down-success', { seatIndex });\n\n      // éƒ¨å±‹å†…ã®å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(data.roomId, room, io);\n\n      // ãƒ­ãƒ“ãƒ¼ã«éƒ¨å±‹ãƒªã‚¹ãƒˆæ›´æ–°ã‚’é€šçŸ¥\n      io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n\n      // è‡ªå‹•ã‚²ãƒ¼ãƒ é–‹å§‹ãƒã‚§ãƒƒã‚¯\n      scheduleNextHand(data.roomId, io);\n\n    } catch (error: any) {\n      console.error(`âŒ Quick-join failed: ${error.message}`);\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒªãƒã‚¤ï¼ˆãƒãƒƒãƒ—è¿½åŠ ï¼‰\n  socket.on('rebuy', (data: { amount: number }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ¢ã™\n      const player = room.players.find(p => p?.socketId === socket.id);\n      if (!player) {\n        socket.emit('error', { message: 'You are not seated' });\n        return;\n      }\n\n      // ã‚²ãƒ¼ãƒ ä¸­ã¯ãƒªãƒã‚¤ä¸å¯\n      if (room.gameState.status !== 'WAITING') {\n        socket.emit('error', { message: 'Cannot rebuy during a hand' });\n        return;\n      }\n\n      // é‡‘é¡ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³\n      const newStack = player.stack + data.amount;\n      const buyInMin = room.config.buyInMin ?? room.config.bigBlind * 20;\n      const buyInMax = room.config.buyInMax ?? room.config.bigBlind * 200;\n      if (newStack < buyInMin) {\n        socket.emit('error', { message: `Minimum buy-in is ${buyInMin}` });\n        return;\n      }\n      if (newStack > buyInMax) {\n        socket.emit('error', { message: `Maximum buy-in is ${buyInMax}` });\n        return;\n      }\n\n      // ãƒªãƒã‚¤å®Ÿè¡Œ\n      player.stack = newStack;\n      console.log(`ğŸ’° ${player.name} rebought for ${data.amount} (new stack: ${newStack})`);\n\n      // ãƒªãƒã‚¤æˆåŠŸã‚’é€šçŸ¥\n      socket.emit('rebuy-success', { amount: data.amount, newStack });\n\n      // éƒ¨å±‹å†…ã®å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n\n      // ã‚²ãƒ¼ãƒ é–‹å§‹ãƒã‚§ãƒƒã‚¯ï¼ˆãƒªãƒã‚¤å¾Œã«äººæ•°ãŒæƒã£ãŸå ´åˆï¼‰\n      scheduleNextHand(roomId, io);\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ========== Phase 3-B: Game Engine Events ==========\n\n  // ã‚¿ã‚¤ãƒ ãƒãƒ³ã‚¯ä½¿ç”¨\n  socket.on('use-timebank', () => {\n    try {\n      const timer = activeTimers.get(socket.id);\n      if (!timer) {\n        socket.emit('error', { message: 'No active timer' });\n        return;\n      }\n\n      const currentChips = playerTimeBanks.get(socket.id) || 0;\n      if (currentChips <= 0) {\n        socket.emit('error', { message: 'No time bank chips remaining' });\n        return;\n      }\n\n      // ã‚¿ã‚¤ãƒ ãƒãƒ³ã‚¯ãƒãƒƒãƒ—ã‚’æ¶ˆè²»ã—ã¦30ç§’è¿½åŠ \n      playerTimeBanks.set(socket.id, currentChips - 1);\n      timer.seconds += 30;\n\n      console.log(`â±ï¸ Time bank used by ${socket.id} (${currentChips - 1} chips remaining)`);\n\n      // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«æ›´æ–°ã‚’é€šçŸ¥\n      socket.emit('timer-update', { seconds: timer.seconds });\n      socket.emit('timebank-update', { chips: currentChips - 1 });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³\n  socket.on('player-action', (data: { type: ActionType; amount?: number; actionToken?: string }) => {\n    try {\n      const context = validatePlayerActionRequest(socket, data);\n      if (!context) return;\n      const { roomId, room, engine } = context;\n\n      // ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢\n      clearPlayerTimer(socket.id);\n\n      actionInFlight.add(socket.id);\n      roomActionInFlight.add(roomId);\n      let result;\n      try {\n        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‡¦ç†\n        result = engine.processAction(room, {\n          playerId: socket.id,\n          type: data.type,\n          amount: data.amount,\n          timestamp: Date.now()\n        });\n      } finally {\n        actionInFlight.delete(socket.id);\n        roomActionInFlight.delete(roomId);\n      }\n\n      if (!result.success) {\n        socket.emit('action-invalid', { reason: result.error });\n        logEvent('action_invalid', { roomId, playerId: socket.id, reason: result.error });\n        incrementMetric('action_invalid', { reason: 'engine_reject' });\n        startPlayerTimer(roomId, socket.id, io);\n        return;\n      }\n      actionTokens.delete(socket.id);\n\n      // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯\n      if (maybeHandleShowdown(roomId, room, io)) {\n        return;\n      }\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€ä¿¡\n      broadcastRoomState(roomId, room, io);\n\n      // æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n      if (room.activePlayerIndex !== -1) {\n        const nextPlayer = room.players[room.activePlayerIndex];\n        if (nextPlayer) {\n          emitYourTurn(roomId, room, engine, io, nextPlayer);\n        }\n      }\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ‰ãƒ­ãƒ¼äº¤æ›ï¼ˆ2-7 Triple Draw, Badugiç”¨ï¼‰\n  socket.on('draw-exchange', (data: { discardIndexes: number[] }) => {\n    try {\n      const context = validateDrawExchangeRequest(socket, data);\n      if (!context) return;\n      const { roomId, room, engine, player, discardIndexes } = context;\n\n      // ã‚«ãƒ¼ãƒ‰äº¤æ›ã‚’å®Ÿè¡Œ\n      const deck = engine.getDeck();\n      const dealer = new Dealer();\n      dealer.exchangeDrawCards(deck, player, discardIndexes);\n\n      // äº¤æ›æšæ•°ã‚’è¨˜éŒ²\n      player.drawDiscards = discardIndexes.length;\n\n      // ãƒ‰ãƒ­ãƒ¼å®Œäº†ã‚’ãƒãƒ¼ã‚¯\n      engine.markDrawComplete(room, socket.id);\n\n      console.log(`ğŸ”„ ${player.name} drew ${discardIndexes.length} cards`);\n\n      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«æ–°ã—ã„æ‰‹æœ­ã‚’é€ä¿¡\n      io.to(socket.id).emit('draw-complete', {\n        newHand: player.hand\n      });\n\n      // å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«äº¤æ›æšæ•°ã‚’é€šçŸ¥ï¼ˆæ‰‹æœ­ã¯è¦‹ã›ãªã„ï¼‰\n      io.to(`room:${roomId}`).emit('player-drew', {\n        playerId: socket.id,\n        playerName: player.name,\n        cardCount: discardIndexes.length\n      });\n\n      // å…¨å“¡å®Œäº†ã—ãŸã‹ãƒã‚§ãƒƒã‚¯\n      if (engine.checkDrawPhaseComplete(room)) {\n        // ãƒ™ãƒƒãƒ†ã‚£ãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚ºã«ç§»è¡Œ\n        console.log(`âœ… All players completed draw - starting betting for ${room.gameState.status}`);\n\n        // å…¨å“¡ã«æ›´æ–°ã‚’é€ä¿¡\n        broadcastRoomState(roomId, room, io);\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¡Œå‹•ã‚’ä¿ƒã™\n        if (room.activePlayerIndex !== -1) {\n          const nextPlayer = room.players[room.activePlayerIndex];\n          if (nextPlayer) {\n            emitYourTurn(roomId, room, engine, io, nextPlayer);\n          }\n        }\n      } else {\n        // ã¾ã å…¨å“¡å®Œäº†ã—ã¦ã„ãªã„å ´åˆã®ã¿çŠ¶æ…‹é€ä¿¡\n        broadcastRoomState(roomId, room, io);\n      }\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // çŠ¶æ…‹å†åŒæœŸ\n  socket.on('request-room-state', () => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) return;\n      const room = roomManager.getRoomById(roomId);\n      if (!room) return;\n      socket.emit('room-state-update', sanitizeRoomForViewer(room, socket.id));\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ========== ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«å¤‰æ›´ ==========\n\n  // ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ãƒ»ãƒã‚¤ã‚¤ãƒ³è¨­å®šå¤‰æ›´\n  socket.on('update-room-config', (data: {\n    smallBlind?: number;\n    bigBlind?: number;\n    buyInMin?: number;\n    buyInMax?: number;\n    timeLimit?: number;\n    studAnte?: number;\n  }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ã‚²ãƒ¼ãƒ ä¸­ã¯å¤‰æ›´ä¸å¯\n      if (room.gameState.status !== 'WAITING') {\n        socket.emit('error', { message: 'Cannot change config while game is in progress' });\n        return;\n      }\n\n      // è¨­å®šã‚’æ›´æ–°\n      if (data.smallBlind !== undefined) {\n        room.config.smallBlind = data.smallBlind;\n      }\n      if (data.bigBlind !== undefined) {\n        room.config.bigBlind = data.bigBlind;\n      }\n      if (data.buyInMin !== undefined) {\n        room.config.buyInMin = data.buyInMin;\n      }\n      if (data.buyInMax !== undefined) {\n        room.config.buyInMax = data.buyInMax;\n      }\n      if (data.timeLimit !== undefined) {\n        room.config.timeLimit = data.timeLimit;\n      }\n      if (data.studAnte !== undefined) {\n        room.config.studAnte = data.studAnte;\n      }\n\n      console.log(`âš™ï¸ Room ${roomId} config updated: SB=${room.config.smallBlind}, BB=${room.config.bigBlind}, Ante=${room.config.studAnte}`);\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n      io.to(`room:${roomId}`).emit('config-updated', { config: room.config });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ¡ã‚¿ã‚²ãƒ¼ãƒ ãƒˆã‚°ãƒ« (7-2ã‚²ãƒ¼ãƒ , Stand Up)\n  socket.on('toggle-meta-game', (data: { game: 'sevenDeuce' | 'standUp'; enabled: boolean }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // metaGameãŒæœªåˆæœŸåŒ–ã®å ´åˆã¯åˆæœŸåŒ–\n      if (!room.metaGame) {\n        room.metaGame = {\n          standUp: { isActive: false, remainingPlayers: [] },\n          sevenDeuce: false\n        };\n      }\n\n      if (data.game === 'sevenDeuce') {\n        room.metaGame.sevenDeuce = data.enabled;\n        console.log(`ğŸ² Room ${roomId}: 7-2 game ${data.enabled ? 'enabled' : 'disabled'}`);\n      } else if (data.game === 'standUp') {\n        room.metaGame.standUp.isActive = data.enabled;\n        if (data.enabled) {\n          // Stand Upé–‹å§‹æ™‚ã€å…¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’remainingPlayersã«è¿½åŠ \n          room.metaGame.standUp.remainingPlayers = room.players\n            .filter(p => p !== null)\n            .map(p => p!.socketId);\n        }\n        console.log(`ğŸ† Room ${roomId}: Stand Up game ${data.enabled ? 'enabled' : 'disabled'}`);\n      }\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n      io.to(`room:${roomId}`).emit('meta-game-updated', { metaGame: room.metaGame });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ã‚²ãƒ¼ãƒ ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š\n  socket.on('set-rotation', (data: {\n    enabled: boolean;\n    gamesList?: string[];\n    handsPerGame?: number;\n  }) => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      // ãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šã‚’æ›´æ–°\n      room.rotation.enabled = data.enabled;\n\n      if (data.gamesList !== undefined && data.gamesList.length > 0) {\n        room.rotation.gamesList = data.gamesList;\n        room.rotation.currentGameIndex = 0;\n        // æœ€åˆã®ã‚²ãƒ¼ãƒ ã‚’è¨­å®š\n        room.gameState.gameVariant = data.gamesList[0];\n      }\n\n      if (data.handsPerGame !== undefined) {\n        room.rotation.handsPerGame = data.handsPerGame;\n        rotationManager.setHandsPerGame(data.handsPerGame);\n      }\n\n      const gamesStr = room.rotation.gamesList.join(' â†’ ');\n      console.log(`ğŸ”„ Room ${roomId}: Rotation ${data.enabled ? 'enabled' : 'disabled'} [${gamesStr}]`);\n\n      // å…¨å“¡ã«æ›´æ–°ã‚’é€šçŸ¥\n      broadcastRoomState(roomId, room, io);\n      io.to(`room:${roomId}`).emit('rotation-updated', { rotation: room.rotation });\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆå³æ™‚å¤‰æ›´ï¼ˆãƒ­ãƒ¼ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å¤–ï¼‰\n  const applyGameVariantChange = (variant: string) => {\n    const roomId = getRoomIdFromSocket(socket);\n    if (!roomId) {\n      socket.emit('error', { message: 'You are not in any room' });\n      return;\n    }\n\n    const room = roomManager.getRoomById(roomId);\n    if (!room) {\n      socket.emit('error', { message: 'Room not found' });\n      return;\n    }\n\n    if (room.gameState.status !== 'WAITING') {\n      socket.emit('error', { message: 'Cannot change game while hand is in progress' });\n      return;\n    }\n\n    const validVariants = ['NLH', 'PLO', 'PLO8', '7CS', '7CS8', 'RAZZ', '2-7_TD', 'BADUGI'];\n    if (!validVariants.includes(variant)) {\n      socket.emit('error', { message: `Invalid variant: ${variant}` });\n      return;\n    }\n\n    room.gameState.gameVariant = variant;\n    console.log(`ğŸ® Room ${roomId}: Game variant changed to ${variant}`);\n\n    broadcastRoomState(roomId, room, io);\n    io.to(`room:${roomId}`).emit('game-variant-changed', { variant });\n  };\n\n  socket.on('set-game-variant', (data: { variant: string }) => {\n    try {\n      applyGameVariantChange(data.variant);\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  socket.on('change-variant', (data: { variant: string }) => {\n    try {\n      applyGameVariantChange(data.variant);\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // ãƒ‡ãƒãƒƒã‚°ç”¨: æ¬¡ã‚²ãƒ¼ãƒ ã¸å¼·åˆ¶åˆ‡æ›¿\n  socket.on('force-next-game', () => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n\n      const room = roomManager.getRoomById(roomId);\n      if (!room) {\n        socket.emit('error', { message: 'Room not found' });\n        return;\n      }\n\n      if (room.gameState.status !== 'WAITING') {\n        socket.emit('error', { message: 'Cannot change game while hand is in progress' });\n        return;\n      }\n\n      if (room.rotation.gamesList.length <= 1) {\n        socket.emit('error', { message: 'Rotation is not enabled' });\n        return;\n      }\n\n      const nextIndex = (room.rotation.currentGameIndex + 1) % room.rotation.gamesList.length;\n      const nextGame = room.rotation.gamesList[nextIndex];\n      room.rotation.currentGameIndex = nextIndex;\n      room.gameState.gameVariant = nextGame;\n\n      if (nextIndex === 0) {\n        room.rotation.orbitCount = (room.rotation.orbitCount || 0) + 1;\n      }\n\n      io.to(`room:${roomId}`).emit('next-game', {\n        nextGame,\n        gamesList: room.rotation.gamesList\n      });\n      broadcastRoomState(roomId, room, io);\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // é›¢å¸­\n  socket.on('leave-seat', () => {\n    try {\n      const roomId = getRoomIdFromSocket(socket);\n      if (!roomId) {\n        socket.emit('error', { message: 'You are not in any room' });\n        return;\n      }\n      handleRoomExit(socket, roomId, io, { leaveRoom: false });\n      if ((socket.data as any).roomId === roomId) {\n        delete (socket.data as any).roomId;\n      }\n\n    } catch (error: any) {\n      socket.emit('error', { message: error.message });\n    }\n  });\n\n  // åˆ‡æ–­ã—ãŸæ™‚\n  socket.on('disconnect', () => {\n    const roomId = (socket.data as any).roomId || getRoomIdFromSocket(socket);\n    if (!roomId) {\n      console.log('ğŸ‘‹ Player disconnected (not in any room):', socket.id);\n      return;\n    }\n    console.log(`ğŸ‘‹ Player disconnected: ${socket.id} from room ${roomId}`);\n    logEvent('disconnect', { playerId: socket.id });\n    incrementMetric('disconnect');\n\n    try {\n      handleRoomExit(socket, roomId, io);\n      delete (socket.data as any).roomId;\n    } catch (error) {\n      // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ï¼ˆã™ã§ã«é›¢å¸­æ¸ˆã¿ã®å¯èƒ½æ€§ï¼‰\n    }\n\n    io.to('lobby').emit('room-list-update', roomManager.getAllRooms());\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\nconst HOST = '0.0.0.0';\nhttpServer.listen(Number(PORT), HOST, () => {\n  console.log(`\\nğŸš€ Server is running on http://${HOST}:${PORT}`);\n\n  // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ«ãƒ¼ãƒ ã‚’åˆæœŸåŒ–\n  roomManager.initializePresetRooms();\n});\n","usedDeprecatedRules":[]}]
