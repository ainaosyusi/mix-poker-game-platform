[{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/Dealer.ts","messages":[{"ruleId":"complexity","severity":1,"message":"Method 'collectBlinds' has a complexity of 14. Maximum allowed is 10.","line":198,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":198,"endColumn":18},{"ruleId":"complexity","severity":1,"message":"Method 'determineBringIn' has a complexity of 15. Maximum allowed is 10.","line":342,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":342,"endColumn":21},{"ruleId":"complexity","severity":1,"message":"Arrow function has a complexity of 12. Maximum allowed is 10.","line":414,"column":63,"nodeType":"ArrowFunctionExpression","messageId":"complex","endLine":414,"endColumn":65}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Phase 3-B: Dealer Class\n * ã‚«ãƒ¼ãƒ‰é…å¸ƒã€ãƒœã‚¿ãƒ³ç®¡ç†ã€ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å¾´åã‚’æ‹…å½“\n */\n\nimport type { Room, Player } from './types.js';\n\nexport class Dealer {\n    // ã‚«ãƒ¼ãƒ‰ãƒ‡ãƒƒã‚­ï¼ˆã‚¹ãƒ¼ãƒˆÃ—13ãƒ©ãƒ³ã‚¯ = 52æšï¼‰\n    private readonly SUITS = ['â™ ', 'â™¥', 'â™¦', 'â™£'];\n    private readonly RANKS = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];\n\n    /**\n     * 52æšã®ãƒ‡ãƒƒã‚­ã‚’ç”Ÿæˆã—ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«\n     */\n    createDeck(): string[] {\n        const deck: string[] = [];\n        for (const suit of this.SUITS) {\n            for (const rank of this.RANKS) {\n                deck.push(rank + suit);\n            }\n        }\n        return this.shuffle(deck);\n    }\n\n    /**\n     * Fisher-Yatesã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã‚·ãƒ£ãƒƒãƒ•ãƒ«\n     */\n    private shuffle(deck: string[]): string[] {\n        const shuffled = [...deck];\n        for (let i = shuffled.length - 1; i > 0; i--) {\n            const j = Math.floor(Math.random() * (i + 1));\n            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n        }\n        return shuffled;\n    }\n\n    /**\n     * ãƒ›ãƒ¼ãƒ«ã‚«ãƒ¼ãƒ‰ã‚’é…å¸ƒï¼ˆTexas Hold'em: 2æšï¼‰\n     * @param deck ãƒ‡ãƒƒã‚­ï¼ˆç ´å£Šçš„ã«ç·¨é›†ã•ã‚Œã‚‹ï¼‰\n     * @param players ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…åˆ—\n     * @param count å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é…ã‚‹æšæ•°ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ2ï¼‰\n     */\n    dealHoleCards(deck: string[], players: (Player | null)[], count: number = 2): void {\n        const activePlayers = players.filter(p =>\n            p !== null && p.stack > 0 && p.status === 'ACTIVE'\n        ) as Player[];\n\n        // ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ­ãƒ“ãƒ³æ–¹å¼ã§é…å¸ƒ\n        for (let i = 0; i < count; i++) {\n            for (const player of activePlayers) {\n                if (deck.length === 0) {\n                    throw new Error('Deck is empty');\n                }\n                const card = deck.shift()!;\n                if (!player.hand) {\n                    player.hand = [];\n                }\n                player.hand.push(card);\n            }\n        }\n    }\n\n    /**\n     * ãƒ•ãƒ­ãƒƒãƒ—ã‚’é…å¸ƒï¼ˆãƒãƒ¼ãƒ³1æš + ãƒ•ãƒ­ãƒƒãƒ—3æšï¼‰\n     */\n    dealFlop(deck: string[]): string[] {\n        if (deck.length < 4) {\n            throw new Error('Not enough cards for flop');\n        }\n\n        deck.shift(); // ãƒãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰\n        return [deck.shift()!, deck.shift()!, deck.shift()!];\n    }\n\n    /**\n     * ã‚¿ãƒ¼ãƒ³ã‚’é…å¸ƒï¼ˆãƒãƒ¼ãƒ³1æš + ã‚¿ãƒ¼ãƒ³1æšï¼‰\n     */\n    dealTurn(deck: string[]): string {\n        if (deck.length < 2) {\n            throw new Error('Not enough cards for turn');\n        }\n\n        deck.shift(); // ãƒãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰\n        return deck.shift()!;\n    }\n\n    /**\n     * ãƒªãƒãƒ¼ã‚’é…å¸ƒï¼ˆãƒãƒ¼ãƒ³1æš + ãƒªãƒãƒ¼1æšï¼‰\n     */\n    dealRiver(deck: string[]): string {\n        if (deck.length < 2) {\n            throw new Error('Not enough cards for river');\n        }\n\n        deck.shift(); // ãƒãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰\n        return deck.shift()!;\n    }\n\n    /**\n     * æ±ç”¨ãƒœãƒ¼ãƒ‰ã‚«ãƒ¼ãƒ‰é…å¸ƒï¼ˆãƒãƒ¼ãƒ³1æš + æŒ‡å®šæšæ•°ï¼‰\n     * boardPatternã«åŸºã¥ããƒ‡ãƒ¼ã‚¿é§†å‹•ã®ã‚«ãƒ¼ãƒ‰é…å¸ƒ\n     */\n    dealBoardCards(deck: string[], count: number): string[] {\n        if (deck.length < count + 1) {\n            throw new Error(`Not enough cards: need ${count + 1}, have ${deck.length}`);\n        }\n\n        deck.shift(); // ãƒãƒ¼ãƒ³ã‚«ãƒ¼ãƒ‰\n        const cards: string[] = [];\n        for (let i = 0; i < count; i++) {\n            cards.push(deck.shift()!);\n        }\n        return cards;\n    }\n\n    /**\n     * ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ãƒœã‚¿ãƒ³ã‚’æ¬¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ç§»å‹•\n     * @param room éƒ¨å±‹\n     * @returns æ–°ã—ã„ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     */\n    moveButton(room: Room): number {\n        const maxPlayers = room.config.maxPlayers;\n        let nextIndex = (room.dealerBtnIndex + 1) % maxPlayers;\n\n        // æ¬¡ã®æœ‰åŠ¹ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆç€å¸­ä¸­ï¼‰ã‚’æ¢ã™\n        let attempts = 0;\n        while (attempts < maxPlayers) {\n            const player = room.players[nextIndex];\n            if (player !== null && player.stack > 0) {\n                room.dealerBtnIndex = nextIndex;\n                return nextIndex;\n            }\n            nextIndex = (nextIndex + 1) % maxPlayers;\n            attempts++;\n        }\n\n        throw new Error('No active players to move button to');\n    }\n\n    /**\n     * æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n     * @param room éƒ¨å±‹\n     * @param currentIndex ç¾åœ¨ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     * @returns æ¬¡ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆ-1ã®å ´åˆã¯å…¨å“¡å®Œäº†ï¼‰\n     */\n    getNextActivePlayer(room: Room, currentIndex: number): number {\n        const maxPlayers = room.config.maxPlayers;\n        let nextIndex = (currentIndex + 1) % maxPlayers;\n        let attempts = 0;\n\n        while (attempts < maxPlayers) {\n            const player = room.players[nextIndex];\n            if (\n                player !== null &&\n                player.status === 'ACTIVE' &&\n                player.stack > 0  // ã‚¹ã‚¿ãƒƒã‚¯ãŒã‚ã‚‹\n            ) {\n                return nextIndex;\n            }\n            nextIndex = (nextIndex + 1) % maxPlayers;\n            attempts++;\n        }\n\n        return -1; // å…¨å“¡ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†\n    }\n\n    /**\n     * æ¬¡ã®ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å¯¾è±¡ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n     * @param includeWaitingForBB trueã®å ´åˆã€BBå¾…ã¡ã‚‚å¯¾è±¡ã«å«ã‚ã‚‹\n     */\n    getNextBlindPlayer(room: Room, currentIndex: number, includeWaitingForBB: boolean): number {\n        const maxPlayers = room.config.maxPlayers;\n        let nextIndex = (currentIndex + 1) % maxPlayers;\n        let attempts = 0;\n\n        while (attempts < maxPlayers) {\n            const player = room.players[nextIndex];\n            if (\n                player !== null &&\n                player.stack > 0 &&\n                (player.status === 'ACTIVE' || (includeWaitingForBB && player.waitingForBB))\n            ) {\n                return nextIndex;\n            }\n            nextIndex = (nextIndex + 1) % maxPlayers;\n            attempts++;\n        }\n\n        return -1;\n    }\n\n    /**\n     * ã‚¹ãƒ¢ãƒ¼ãƒ«ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ã¨ãƒ“ãƒƒã‚°ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ã‚’å¾´å\n     * @param room éƒ¨å±‹\n     * @returns {sbIndex, bbIndex} SBã¨BBã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     */\n    collectBlinds(room: Room): { sbIndex: number; bbIndex: number } {\n        const dealerIndex = room.dealerBtnIndex;\n        const maxPlayers = room.config.maxPlayers;\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’æ•°ãˆã‚‹\n        const activePlayers = room.players.filter(p =>\n            p !== null && p.stack > 0 && p.status === 'ACTIVE'\n        );\n\n        const blindEligible = room.players.filter(p =>\n            p !== null && p.stack > 0 && (p.status === 'ACTIVE' || p.waitingForBB)\n        );\n\n        if (blindEligible.length < 2) {\n            throw new Error('Need at least 2 players to collect blinds');\n        }\n\n        // ãƒ˜ãƒƒã‚ºã‚¢ãƒƒãƒ—ã®å ´åˆ: ãƒœã‚¿ãƒ³=SB, æ¬¡ãŒBB\n        // 3äººä»¥ä¸Šã®å ´åˆ: ãƒœã‚¿ãƒ³ã®æ¬¡=SB, ãã®æ¬¡=BB\n        let sbIndex: number;\n        let bbIndex: number;\n\n        if (activePlayers.length === 2) {\n            // ãƒ˜ãƒƒã‚ºã‚¢ãƒƒãƒ—\n            sbIndex = (room.players[dealerIndex]?.status === 'ACTIVE')\n                ? dealerIndex\n                : this.getNextActivePlayer(room, dealerIndex);\n            bbIndex = this.getNextBlindPlayer(room, sbIndex, true);\n        } else if (activePlayers.length < 2) {\n            sbIndex = (room.players[dealerIndex]?.status === 'ACTIVE')\n                ? dealerIndex\n                : this.getNextActivePlayer(room, dealerIndex);\n            if (sbIndex === -1) {\n                sbIndex = this.getNextBlindPlayer(room, dealerIndex, true);\n            }\n            bbIndex = this.getNextBlindPlayer(room, sbIndex, true);\n        } else {\n            // 3äººä»¥ä¸Š\n            sbIndex = this.getNextActivePlayer(room, dealerIndex);\n            bbIndex = this.getNextBlindPlayer(room, sbIndex, true);\n        }\n\n        // ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰å¾´å\n        const sbPlayer = room.players[sbIndex];\n        const bbPlayer = room.players[bbIndex];\n\n        if (!sbPlayer || !bbPlayer) {\n            throw new Error('Blind positions not found');\n        }\n\n        const sb = room.config.smallBlind;\n        const bb = room.config.bigBlind;\n\n        // SBå¾´å\n        const sbAmount = Math.min(sbPlayer.stack, sb);\n        sbPlayer.stack -= sbAmount;\n        sbPlayer.bet = sbAmount;\n        sbPlayer.totalBet = sbAmount;\n        room.gameState.pot.main += sbAmount;\n\n        // BBå¾´å\n        const bbAmount = Math.min(bbPlayer.stack, bb);\n        bbPlayer.stack -= bbAmount;\n        bbPlayer.bet = bbAmount;\n        bbPlayer.totalBet = bbAmount;\n        room.gameState.pot.main += bbAmount;\n\n        // BBå¾…ã¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã“ã“ã§å‚åŠ æ‰±ã„ã«ã™ã‚‹\n        if (bbPlayer.waitingForBB) {\n            bbPlayer.waitingForBB = false;\n            bbPlayer.pendingJoin = false;\n            bbPlayer.status = 'ACTIVE';\n        }\n\n        // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ãƒã‚§ãƒƒã‚¯\n        if (sbPlayer.stack === 0) {\n            sbPlayer.status = 'ALL_IN';\n        }\n        if (bbPlayer.stack === 0) {\n            bbPlayer.status = 'ALL_IN';\n        }\n\n        console.log(`ğŸ’° Blinds collected: SB=${sbAmount} (seat ${sbIndex}), BB=${bbAmount} (seat ${bbIndex})`);\n\n        return { sbIndex, bbIndex };\n    }\n\n    /**\n     * ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°ã‚’å–å¾—\n     */\n    getActivePlayerCount(room: Room): number {\n        return room.players.filter(p =>\n            p !== null &&\n            (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        ).length;\n    }\n\n    /**\n     * ãƒãƒ³ãƒ‰çµ‚äº†æ™‚ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—\n     */\n    clearHands(room: Room): void {\n        for (const player of room.players) {\n            if (player) {\n                player.hand = null;\n                player.bet = 0;\n                player.totalBet = 0;\n                if (player.status === 'FOLDED') {\n                    player.status = 'ACTIVE';\n                }\n            }\n        }\n        room.gameState.board = [];\n        room.gameState.pot = { main: 0, side: [] };\n    }\n\n    /**\n     * ã‚«ãƒ¼ãƒ‰ã®ãƒ©ãƒ³ã‚¯å€¤ã‚’å–å¾—ï¼ˆBring-Inåˆ¤å®šç”¨ï¼‰\n     */\n    private getCardRankValue(card: string): number {\n        const rank = card[0];\n        const values: { [key: string]: number } = {\n            '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10,\n            'J': 11, 'Q': 12, 'K': 13, 'A': 14\n        };\n        return values[rank] || 0;\n    }\n\n    /**\n     * ã‚«ãƒ¼ãƒ‰ã®ã‚¹ãƒ¼ãƒˆå€¤ã‚’å–å¾—ï¼ˆã‚¿ã‚¤ãƒ–ãƒ¬ãƒ¼ã‚¯ç”¨: â™£ < â™¦ < â™¥ < â™ ï¼‰\n     */\n    private getCardSuitValue(card: string): number {\n        const suit = card[1];\n        const values: { [key: string]: number } = {\n            'â™£': 1, 'â™¦': 2, 'â™¥': 3, 'â™ ': 4\n        };\n        return values[suit] || 0;\n    }\n\n    /**\n     * Stud Bring-Inåˆ¤å®š: æœ€ã‚‚å¼±ã„ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã‚’æŒã¤ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™\n     * @param players ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é…åˆ—\n     * @param isRazz Razzã®å ´åˆã¯æœ€ã‚‚å¼·ã„ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰\n     * @returns ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     */\n    determineBringIn(players: (Player | null)[], isRazz: boolean = false): number {\n        let bringInIndex = -1;\n        let targetRank = isRazz ? 0 : 15; // Razz: é«˜ã„æ–¹ã€é€šå¸¸: ä½ã„æ–¹\n        let targetSuit = isRazz ? 0 : 5;\n\n        for (let i = 0; i < players.length; i++) {\n            const player = players[i];\n            if (!player || !player.studUpCards || player.studUpCards.length === 0) continue;\n\n            const upCard = player.studUpCards[0]; // 3rd Streetã®æœ€åˆã®ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰\n            const rank = this.getCardRankValue(upCard);\n            const suit = this.getCardSuitValue(upCard);\n\n            if (isRazz) {\n                // Razz: æœ€ã‚‚é«˜ã„ã‚«ãƒ¼ãƒ‰ï¼ˆå¼·ã„ï¼æ‚ªã„ï¼‰ãŒBring-In\n                if (rank > targetRank || (rank === targetRank && suit > targetSuit)) {\n                    targetRank = rank;\n                    targetSuit = suit;\n                    bringInIndex = i;\n                }\n            } else {\n                // é€šå¸¸Stud: æœ€ã‚‚ä½ã„ã‚«ãƒ¼ãƒ‰ãŒBring-In\n                if (rank < targetRank || (rank === targetRank && suit < targetSuit)) {\n                    targetRank = rank;\n                    targetSuit = suit;\n                    bringInIndex = i;\n                }\n            }\n        }\n\n        return bringInIndex;\n    }\n\n    /**\n     * Bring-Inã‚’å¾´å\n     * @param room éƒ¨å±‹\n     * @param bringInIndex Bring-Inãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹\n     * @param bringInAmount Bring-Iné¡ï¼ˆé€šå¸¸ã¯SBã®åŠåˆ†ç¨‹åº¦ï¼‰\n     */\n    collectBringIn(room: Room, bringInIndex: number, bringInAmount: number): void {\n        const player = room.players[bringInIndex];\n        if (!player) return;\n\n        const amount = Math.min(player.stack, bringInAmount);\n        player.stack -= amount;\n        player.bet = amount;\n        player.totalBet = amount;\n        room.gameState.pot.main += amount;\n        room.gameState.currentBet = amount;\n\n        if (player.stack === 0) {\n            player.status = 'ALL_IN';\n        }\n\n        console.log(`ğŸ’° Bring-In: ${player.name} posts ${amount}`);\n    }\n\n    /**\n     * Studã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³é–‹å§‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ±ºå®š\n     * - é€šå¸¸: æœ€ã‚‚å¼·ã„ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼\n     * - Razz: æœ€ã‚‚å¼±ã„ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼\n     * ã‚¿ã‚¤ã¯ãƒ‡ã‚£ãƒ¼ãƒ©ãƒ¼ã®å·¦ã‹ã‚‰é †ã«å„ªå…ˆ\n     */\n    getStudActionStartIndex(room: Room, isRazz: boolean = false): number {\n        const candidates = room.players\n            .map((player, index) => ({ player, index }))\n            .filter(p => p.player !== null && p.player.status === 'ACTIVE' && (p.player.studUpCards?.length || 0) > 0);\n\n        if (candidates.length === 0) {\n            return this.getNextActivePlayer(room, -1);\n        }\n\n        const compareUpCards = (a: Player, b: Player): number => {\n            const aRanks = (a.studUpCards || []).map(card => this.getCardRankValue(card));\n            const bRanks = (b.studUpCards || []).map(card => this.getCardRankValue(card));\n\n            aRanks.sort((x, y) => isRazz ? x - y : y - x);\n            bRanks.sort((x, y) => isRazz ? x - y : y - x);\n\n            const maxLen = Math.max(aRanks.length, bRanks.length);\n            for (let i = 0; i < maxLen; i++) {\n                const av = aRanks[i] ?? (isRazz ? 99 : 0);\n                const bv = bRanks[i] ?? (isRazz ? 99 : 0);\n                if (av === bv) continue;\n                return isRazz ? (av < bv ? 1 : -1) : (av > bv ? 1 : -1);\n            }\n            return 0;\n        };\n\n        let best = candidates[0];\n        let tied: number[] = [best.index];\n\n        for (const candidate of candidates.slice(1)) {\n            const result = compareUpCards(candidate.player!, best.player!);\n            if (result > 0) {\n                best = candidate;\n                tied = [candidate.index];\n            } else if (result === 0) {\n                tied.push(candidate.index);\n            }\n        }\n\n        if (tied.length === 1) {\n            return tied[0];\n        }\n\n        const maxPlayers = room.config.maxPlayers;\n        let idx = (room.dealerBtnIndex + 1) % maxPlayers;\n        for (let i = 0; i < maxPlayers; i++) {\n            if (tied.includes(idx)) {\n                return idx;\n            }\n            idx = (idx + 1) % maxPlayers;\n        }\n\n        return tied[0];\n    }\n\n    /**\n     * ã‚¹ã‚¿ãƒƒãƒ‰ç”¨ã‚«ãƒ¼ãƒ‰é…å¸ƒï¼ˆ3rd Street: 2 down + 1 upï¼‰\n     */\n    dealStudInitial(deck: string[], players: (Player | null)[]): void {\n        const activePlayers = players.filter(p =>\n            p !== null && p.stack > 0 && p.status === 'ACTIVE'\n        ) as Player[];\n\n        // 2æšãƒ€ã‚¦ãƒ³ã‚«ãƒ¼ãƒ‰\n        for (let i = 0; i < 2; i++) {\n            for (const player of activePlayers) {\n                if (deck.length === 0) throw new Error('Deck is empty');\n                const card = deck.shift()!;\n                if (!player.hand) player.hand = [];\n                player.hand.push(card);\n            }\n        }\n\n        // 1æšã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰\n        for (const player of activePlayers) {\n            if (deck.length === 0) throw new Error('Deck is empty');\n            const card = deck.shift()!;\n            player.hand!.push(card);\n            // ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰ã¯studUpCardsã«è¨˜éŒ²\n            if (!player.studUpCards) player.studUpCards = [];\n            player.studUpCards.push(card);\n        }\n\n        console.log('ğŸ´ Dealt Stud 3rd Street: 2 down + 1 up');\n    }\n\n    /**\n     * ã‚¹ã‚¿ãƒƒãƒ‰ç”¨è¿½åŠ ã‚«ãƒ¼ãƒ‰é…å¸ƒï¼ˆ4th-6th Street: up cardsï¼‰\n     */\n    dealStudStreet(deck: string[], players: (Player | null)[], isLastStreet: boolean = false): void {\n        const activePlayers = players.filter(p =>\n            p !== null && (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        ) as Player[];\n\n        for (const player of activePlayers) {\n            if (deck.length === 0) throw new Error('Deck is empty');\n            const card = deck.shift()!;\n            player.hand!.push(card);\n\n            // 7th Streetã¯ãƒ€ã‚¦ãƒ³ã‚«ãƒ¼ãƒ‰ã€ãã‚Œä»¥å¤–ã¯ã‚¢ãƒƒãƒ—ã‚«ãƒ¼ãƒ‰\n            if (!isLastStreet) {\n                if (!player.studUpCards) player.studUpCards = [];\n                player.studUpCards.push(card);\n            }\n        }\n\n        console.log(`ğŸ´ Dealt Stud street: ${isLastStreet ? 'down card' : 'up card'}`);\n    }\n\n    /**\n     * ãƒ‰ãƒ­ãƒ¼äº¤æ›å‡¦ç†\n     * @param deck ãƒ‡ãƒƒã‚­\n     * @param player ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼\n     * @param discardIndexes æ¨ã¦ã‚‹ã‚«ãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é…åˆ—\n     */\n    exchangeDrawCards(deck: string[], player: Player, discardIndexes: number[]): void {\n        if (!player.hand) return;\n\n        const discardCount = discardIndexes.length;\n        if (deck.length < discardCount) {\n            throw new Error('Not enough cards for draw exchange');\n        }\n\n        // Sort indexes in descending order to avoid index shift issues\n        const sortedIndexes = [...discardIndexes].sort((a, b) => b - a);\n\n        // Remove discarded cards\n        for (const idx of sortedIndexes) {\n            if (idx >= 0 && idx < player.hand.length) {\n                player.hand.splice(idx, 1);\n            }\n        }\n\n        // Deal new cards\n        for (let i = 0; i < discardCount; i++) {\n            const card = deck.shift()!;\n            player.hand.push(card);\n        }\n\n        console.log(`ğŸ”„ ${player.name} exchanged ${discardCount} cards`);\n    }\n\n    /**\n     * ãƒªã‚·ãƒ£ãƒƒãƒ•ãƒ«ï¼ˆPattern C: é«˜åº¦ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰\n     * ãƒ‡ãƒƒã‚­ãŒä¸è¶³ã—ãŸå ´åˆã€ãƒ‡ã‚£ã‚¹ã‚«ãƒ¼ãƒ‰ãƒ‘ã‚¤ãƒ«ã¨ã‚¹ã‚¿ãƒ–ã‚’åˆã‚ã›ã¦ãƒªã‚·ãƒ£ãƒƒãƒ•ãƒ«\n     */\n    reshuffleIfNeeded(deck: string[], discardPile: string[], requiredCards: number): string[] {\n        if (deck.length >= requiredCards) {\n            return deck; // ååˆ†ãªã‚«ãƒ¼ãƒ‰ãŒã‚ã‚‹\n        }\n\n        console.log(`âš ï¸ Deck low (${deck.length} cards), need ${requiredCards}. Reshuffling...`);\n\n        // ã‚¹ã‚¿ãƒ–ã¨ãƒ‡ã‚£ã‚¹ã‚«ãƒ¼ãƒ‰ã‚’åˆã‚ã›ã‚‹\n        const combined = [...deck, ...discardPile];\n        const reshuffled = this.shuffle(combined);\n\n        console.log(`âœ… Reshuffled ${combined.length} cards`);\n\n        // ãƒ‡ã‚£ã‚¹ã‚«ãƒ¼ãƒ‰ãƒ‘ã‚¤ãƒ«ã‚’ã‚¯ãƒªã‚¢\n        discardPile.length = 0;\n\n        return reshuffled;\n    }\n}\n","usedDeprecatedRules":[]}]
