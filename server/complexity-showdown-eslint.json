[{"filePath":"/Users/naoai/Desktop/mix-poker-app/server/ShowdownManager.ts","messages":[{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":51,"column":21,"nodeType":"ForStatement","messageId":"tooDeeply","endLine":65,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":54,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":64,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 4.","line":60,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":63,"endColumn":30},{"ruleId":"complexity","severity":1,"message":"Function 'getBestPLOFiveCards' has a complexity of 11. Maximum allowed is 10.","line":75,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":75,"endColumn":29},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":90,"column":21,"nodeType":"ForStatement","messageId":"tooDeeply","endLine":106,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":96,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":105,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 4.","line":101,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":104,"endColumn":30},{"ruleId":"complexity","severity":1,"message":"Function 'getBestPLOLowFiveCards' has a complexity of 11. Maximum allowed is 10.","line":116,"column":1,"nodeType":"FunctionDeclaration","messageId":"complex","endLine":116,"endColumn":32},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":130,"column":21,"nodeType":"ForStatement","messageId":"tooDeeply","endLine":142,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":136,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":141,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 4.","line":137,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":140,"endColumn":30},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":163,"column":21,"nodeType":"ForStatement","messageId":"tooDeeply","endLine":172,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":166,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":171,"endColumn":26},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (7). Maximum allowed is 4.","line":167,"column":29,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":170,"endColumn":30},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (5). Maximum allowed is 4.","line":192,"column":21,"nodeType":"ForStatement","messageId":"tooDeeply","endLine":199,"endColumn":22},{"ruleId":"max-depth","severity":1,"message":"Blocks are nested too deeply (6). Maximum allowed is 4.","line":195,"column":25,"nodeType":"IfStatement","messageId":"tooDeeply","endLine":198,"endColumn":26},{"ruleId":"max-lines-per-function","severity":1,"message":"Method 'executeHiLoShowdown' has too many lines (155). Maximum allowed is 100.","line":435,"column":5,"nodeType":"MethodDefinition","messageId":"exceed","endLine":589,"endColumn":6},{"ruleId":"complexity","severity":1,"message":"Method 'executeHiLoShowdown' has a complexity of 11. Maximum allowed is 10.","line":435,"column":5,"nodeType":"FunctionExpression","messageId":"complex","endLine":435,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Phase 3-B: Showdown Manager\n * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³æ™‚ã®å‹è€…åˆ¤å®šã¨ãƒãƒƒãƒˆåˆ†é…\n */\n\nimport type { Room, Player, PotState } from './types.js';\nimport {\n    evaluateHand,\n    compareHands,\n    evaluateLowHand8OrBetter,\n    evaluateRazzHand,\n    evaluateBadugiHand,\n    evaluateDeuceSeven,\n    compareLowHands,\n    compareBadugiHands,\n    compareDeuceSeven\n} from './handEvaluator.js';\nimport { PotManager } from './PotManager.js';\nimport { getVariantConfig } from './gameVariants.js';\n\n// ã‚«ãƒ¼ãƒ‰æ–‡å­—åˆ—ã‚’Cardã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›\ninterface Card {\n    rank: string;\n    suit: string;\n}\n\nfunction parseCard(cardStr: string): Card {\n    // ã‚«ãƒ¼ãƒ‰æ–‡å­—åˆ—ã¯ \"AS\", \"KH\", \"TD\" ãªã©ã®å½¢å¼\n    // Tã¯10ã‚’è¡¨ã™\n    const rank = cardStr[0] === 'T' ? '10' : cardStr[0];\n    const suit = cardStr[1];\n    return { rank, suit };\n}\n\nfunction parseCards(cards: string[]): Card[] {\n    return cards.map(parseCard);\n}\n\n// 7æšã‹ã‚‰æœ€å¼·ã®5æšã‚’é¸ã¶\nfunction getBestFiveCards(cards: Card[]): Card[] {\n    if (cards.length <= 5) return cards;\n\n    // ã™ã¹ã¦ã®5æšã®çµ„ã¿åˆã‚ã›ã‚’è©¦ã™\n    let bestHand = cards.slice(0, 5);\n    let bestRank = evaluateHand(bestHand);\n\n    for (let i = 0; i < cards.length; i++) {\n        for (let j = i + 1; j < cards.length; j++) {\n            for (let k = j + 1; k < cards.length; k++) {\n                for (let l = k + 1; l < cards.length; l++) {\n                    for (let m = l + 1; m < cards.length; m++) {\n                        const hand = [cards[i], cards[j], cards[k], cards[l], cards[m]];\n                        const rank = evaluateHand(hand);\n                        if (rank.rank > bestRank.rank) {\n                            bestHand = hand;\n                            bestRank = rank;\n                        } else if (rank.rank === bestRank.rank) {\n                            // åŒã˜å½¹ã®å ´åˆã€é«˜ä½ã‚«ãƒ¼ãƒ‰ã§æ¯”è¼ƒ\n                            const comparison = compareHands(hand, bestHand);\n                            if (comparison > 0) {\n                                bestHand = hand;\n                                bestRank = rank;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// PLOç”¨: æ‰‹æœ­ã‹ã‚‰2æšã€ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšã‚’ä½¿ç”¨ã—ã¦æœ€å¼·ã®5æšã‚’é¸ã¶\nfunction getBestPLOFiveCards(holeCards: Card[], boardCards: Card[]): Card[] {\n    if (holeCards.length < 2 || boardCards.length < 3) {\n        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é€šå¸¸ã®è©•ä¾¡\n        return getBestFiveCards([...holeCards, ...boardCards]);\n    }\n\n    let bestHand = [...holeCards.slice(0, 2), ...boardCards.slice(0, 3)];\n    let bestRank = evaluateHand(bestHand);\n\n    // æ‰‹æœ­ã‹ã‚‰2æšé¸ã¶çµ„ã¿åˆã‚ã› (C(4,2) = 6é€šã‚Šã€ã¾ãŸã¯ C(n,2))\n    for (let h1 = 0; h1 < holeCards.length; h1++) {\n        for (let h2 = h1 + 1; h2 < holeCards.length; h2++) {\n            // ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšé¸ã¶çµ„ã¿åˆã‚ã› (C(5,3) = 10é€šã‚Š)\n            for (let b1 = 0; b1 < boardCards.length; b1++) {\n                for (let b2 = b1 + 1; b2 < boardCards.length; b2++) {\n                    for (let b3 = b2 + 1; b3 < boardCards.length; b3++) {\n                        const hand = [\n                            holeCards[h1], holeCards[h2],\n                            boardCards[b1], boardCards[b2], boardCards[b3]\n                        ];\n                        const rank = evaluateHand(hand);\n                        if (rank.rank > bestRank.rank) {\n                            bestHand = hand;\n                            bestRank = rank;\n                        } else if (rank.rank === bestRank.rank) {\n                            const comparison = compareHands(hand, bestHand);\n                            if (comparison > 0) {\n                                bestHand = hand;\n                                bestRank = rank;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// PLO8ç”¨: æ‰‹æœ­ã‹ã‚‰2æšã€ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšã‚’ä½¿ç”¨ã—ã¦æœ€å¼·ã®ãƒ­ãƒ¼ãƒãƒ³ãƒ‰5æšã‚’é¸ã¶\nfunction getBestPLOLowFiveCards(holeCards: Card[], boardCards: Card[]): Card[] | null {\n    if (holeCards.length < 2 || boardCards.length < 3) {\n        return null;\n    }\n\n    let bestHand: Card[] | null = null;\n    let bestLow = evaluateLowHand8OrBetter([]);\n\n    // æ‰‹æœ­ã‹ã‚‰2æšé¸ã¶çµ„ã¿åˆã‚ã›\n    for (let h1 = 0; h1 < holeCards.length; h1++) {\n        for (let h2 = h1 + 1; h2 < holeCards.length; h2++) {\n            // ãƒœãƒ¼ãƒ‰ã‹ã‚‰3æšé¸ã¶çµ„ã¿åˆã‚ã›\n            for (let b1 = 0; b1 < boardCards.length; b1++) {\n                for (let b2 = b1 + 1; b2 < boardCards.length; b2++) {\n                    for (let b3 = b2 + 1; b3 < boardCards.length; b3++) {\n                        const hand = [\n                            holeCards[h1], holeCards[h2],\n                            boardCards[b1], boardCards[b2], boardCards[b3]\n                        ];\n                        const lowResult = evaluateLowHand8OrBetter(hand);\n                        if (lowResult.valid) {\n                            if (!bestHand || compareLowHands(lowResult, bestLow) > 0) {\n                                bestHand = hand;\n                                bestLow = lowResult;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// 7æšã‹ã‚‰æœ€å¼·ã®ãƒ­ãƒ¼ãƒãƒ³ãƒ‰5æšã‚’é¸ã¶ï¼ˆ8-or-betterï¼‰\nfunction getBestLowFiveCards(cards: Card[]): Card[] | null {\n    if (cards.length < 5) return null;\n\n    let bestHand: Card[] | null = null;\n    let bestLow = evaluateLowHand8OrBetter([]);\n\n    // ã™ã¹ã¦ã®5æšã®çµ„ã¿åˆã‚ã›ã‚’è©¦ã™\n    for (let i = 0; i < cards.length; i++) {\n        for (let j = i + 1; j < cards.length; j++) {\n            for (let k = j + 1; k < cards.length; k++) {\n                for (let l = k + 1; l < cards.length; l++) {\n                    for (let m = l + 1; m < cards.length; m++) {\n                        const hand = [cards[i], cards[j], cards[k], cards[l], cards[m]];\n                        const lowResult = evaluateLowHand8OrBetter(hand);\n                        if (lowResult.valid) {\n                            if (!bestHand || compareLowHands(lowResult, bestLow) > 0) {\n                                bestHand = hand;\n                                bestLow = lowResult;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return bestHand;\n}\n\n// Razzç”¨: 7æšã‹ã‚‰æœ€å¼·ã®ãƒ­ãƒ¼ãƒãƒ³ãƒ‰5æšã‚’é¸ã¶\nfunction getBestRazzFiveCards(cards: Card[]): Card[] {\n    if (cards.length <= 5) return cards;\n\n    let bestHand = cards.slice(0, 5);\n    let bestLow = evaluateRazzHand(bestHand);\n\n    for (let i = 0; i < cards.length; i++) {\n        for (let j = i + 1; j < cards.length; j++) {\n            for (let k = j + 1; k < cards.length; k++) {\n                for (let l = k + 1; l < cards.length; l++) {\n                    for (let m = l + 1; m < cards.length; m++) {\n                        const hand = [cards[i], cards[j], cards[k], cards[l], cards[m]];\n                        const lowResult = evaluateRazzHand(hand);\n                        if (compareLowHands(lowResult, bestLow) > 0) {\n                            bestHand = hand;\n                            bestLow = lowResult;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return bestHand;\n}\n\nexport interface ShowdownResult {\n    winners: {\n        playerId: string;\n        playerName: string;\n        hand: string[];\n        handRank: string;\n        amount: number;\n    }[];\n    allHands: {\n        playerId: string;\n        playerName: string;\n        hand: string[] | null;  // nullã®å ´åˆã¯ãƒãƒƒã‚¯ï¼ˆéè¡¨ç¤ºï¼‰\n        handRank: string;\n        isMucked?: boolean;     // ãƒãƒƒã‚¯ã•ã‚ŒãŸã‹ã©ã†ã‹\n    }[];\n}\n\nexport class ShowdownManager {\n    private potManager: PotManager;\n\n    constructor() {\n        this.potManager = new PotManager();\n    }\n\n    /**\n     * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã‚’æ±ºå®š\n     * - ãƒ©ã‚¹ãƒˆã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ãŒã„ã‚‹å ´åˆ: ã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ã‹ã‚‰æ™‚è¨ˆå›ã‚Š\n     * - ã„ãªã„å ´åˆï¼ˆå…¨å“¡ãƒã‚§ãƒƒã‚¯ï¼‰: ãƒœã‚¿ãƒ³ã®å·¦ï¼ˆSBä½ç½®ï¼‰ã‹ã‚‰æ™‚è¨ˆå›ã‚Š\n     */\n    private getShowdownOrder(room: Room, players: Player[]): Player[] {\n        const maxPlayers = room.config.maxPlayers;\n        const lastAggressorIdx = room.lastAggressorIndex;\n        const buttonIdx = room.dealerBtnIndex;\n\n        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®seatIndexã‚’å–å¾—\n        const playerSeats = players.map(p => {\n            const seatIdx = room.players.findIndex(rp => rp?.socketId === p.socketId);\n            return { player: p, seatIndex: seatIdx };\n        });\n\n        let startIndex: number;\n        if (lastAggressorIdx !== -1 && room.players[lastAggressorIdx]) {\n            // ãƒ©ã‚¹ãƒˆã‚¢ã‚°ãƒ¬ãƒƒã‚µãƒ¼ãŒã„ã‚‹å ´åˆã€ãã®äººã‹ã‚‰é–‹å§‹\n            startIndex = lastAggressorIdx;\n        } else {\n            // å…¨å“¡ãƒã‚§ãƒƒã‚¯ã®å ´åˆã€ãƒœã‚¿ãƒ³ã®æ¬¡ï¼ˆSBä½ç½®ï¼‰ã‹ã‚‰é–‹å§‹\n            startIndex = (buttonIdx + 1) % maxPlayers;\n        }\n\n        // startIndexã‹ã‚‰æ™‚è¨ˆå›ã‚Šã«ã‚½ãƒ¼ãƒˆ\n        playerSeats.sort((a, b) => {\n            const distA = (a.seatIndex - startIndex + maxPlayers) % maxPlayers;\n            const distB = (b.seatIndex - startIndex + maxPlayers) % maxPlayers;\n            return distA - distB;\n        });\n\n        return playerSeats.map(ps => ps.player);\n    }\n\n    /**\n     * ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯\n     */\n    private hasAllInPlayer(room: Room): boolean {\n        return room.players.some(p => p !== null && p.status === 'ALL_IN');\n    }\n\n    /**\n     * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ã‚’å®Ÿè¡Œã—ã€å‹è€…ã‚’æ±ºå®šã—ã¦ãƒãƒƒãƒˆã‚’åˆ†é…\n     * ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆã«å¿œã˜ãŸè©•ä¾¡ã‚’è¡Œã†\n     */\n    executeShowdown(room: Room): ShowdownResult {\n        const board = room.gameState.board;\n        const variant = room.gameState.gameVariant;\n        const variantConfig = getVariantConfig(variant);\n\n        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å–å¾—\n        const showdownPlayers = room.players.filter(p =>\n            p !== null &&\n            (p.status === 'ACTIVE' || p.status === 'ALL_IN') &&\n            p.hand !== null\n        ) as Player[];\n\n        if (showdownPlayers.length === 0) {\n            return { winners: [], allHands: [] };\n        }\n\n        // ã‚²ãƒ¼ãƒ ãƒãƒªã‚¢ãƒ³ãƒˆã«å¿œã˜ãŸè©•ä¾¡\n        switch (variantConfig.handEvaluation) {\n            case 'highlow':\n                return this.executeHiLoShowdown(room, showdownPlayers, board);\n            case 'razz':\n                return this.executeRazzShowdown(room, showdownPlayers, board);\n            case 'badugi':\n                return this.executeBadugiShowdown(room, showdownPlayers);\n            case '2-7':\n                return this.executeDeuce7Showdown(room, showdownPlayers);\n            default:\n                return this.executeHighShowdown(room, showdownPlayers, board);\n        }\n    }\n\n    /**\n     * ãƒã‚¤ãƒãƒ³ãƒ‰ã®ã¿ã®è©•ä¾¡ï¼ˆNLH, PLOç­‰ï¼‰\n     */\n    private executeHighShowdown(room: Room, players: Player[], board: string[]): ShowdownResult {\n        const variant = room.gameState.gameVariant;\n        const variantConfig = getVariantConfig(variant);\n        const useOmahaSelection = variantConfig.holeCardsForSelection !== undefined;\n        const isAllInShowdown = this.hasAllInPlayer(room);\n\n        // ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã‚’æ±ºå®š\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        // å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ‰‹å½¹ã‚’è©•ä¾¡\n        const evaluations = orderedPlayers.map(player => {\n            const holeCards = parseCards(player.hand!);\n            const boardCards = parseCards(board);\n\n            // Omahaç³»: æ‰‹æœ­ã‹ã‚‰å¿…ãšNæšä½¿ç”¨ + ãƒœãƒ¼ãƒ‰3æšã®çµ„ã¿åˆã‚ã›\n            // Hold'emç³»: å…¨ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€å¼·ã®5æš\n            const bestFive = useOmahaSelection\n                ? getBestPLOFiveCards(holeCards, boardCards)\n                : getBestFiveCards([...holeCards, ...boardCards]);\n\n            const handResult = evaluateHand(bestFive);\n\n            return {\n                player,\n                bestFive,\n                handResult,\n                handRank: handResult.name\n            };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œã®ãƒãƒƒãƒˆåˆ†é…ï¼ˆå‹è€…ã®æ±ºå®šï¼‰\n        const winners = this.distributeToWinnersWithSidePots(room, evaluations, compareHands);\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n\n        if (isAllInShowdown) {\n            // ã‚ªãƒ¼ãƒ«ã‚¤ãƒ³ã®å ´åˆ: å…¨å“¡å¼·åˆ¶ã‚ªãƒ¼ãƒ—ãƒ³ï¼ˆå…±è¬€é˜²æ­¢ï¼‰\n            // ãƒãƒ³ãƒ‰ã¯ã‚³ãƒ”ãƒ¼ã—ã¦å‚ç…§å•é¡Œã‚’é˜²ã\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n            console.log(`ğŸ† All-In Showdown: All hands revealed`);\n        } else {\n            // é€šå¸¸ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³: é †åºã«å¾“ã£ã¦Show/Muckåˆ¤å®š\n            allHands = this.determineShowMuck(evaluations, winnerIds, compareHands);\n        }\n\n        console.log(`ğŸ† Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã«å¾“ã£ã¦Show/Muckã‚’åˆ¤å®š\n     * - 1ç•ªæ‰‹: å¿…ãšShow\n     * - 2ç•ªæ‰‹ä»¥é™: ç¾åœ¨ã®ãƒ™ã‚¹ãƒˆã‚ˆã‚Šå¼·ã„ã‹åŒã˜ãªã‚‰Showã€å¼±ã‘ã‚Œã°Muck\n     */\n    private determineShowMuck<T extends { player: Player; bestFive: Card[]; handRank: string }>(\n        evaluations: T[],\n        winnerIds: Set<string>,\n        compareFunc: (a: Card[], b: Card[]) => number\n    ): ShowdownResult['allHands'] {\n        let currentBestFive: Card[] | null = null;\n\n        return evaluations.map((e, index) => {\n            // 1ç•ªæ‰‹ã¯å¿…ãšShow\n            if (index === 0) {\n                currentBestFive = e.bestFive;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            }\n\n            // 2ç•ªæ‰‹ä»¥é™: ç¾åœ¨ã®ãƒ™ã‚¹ãƒˆã¨æ¯”è¼ƒ\n            const comparison = compareFunc(e.bestFive, currentBestFive!);\n\n            if (comparison > 0) {\n                // å‹ã£ã¦ã„ã‚‹ â†’ Show & ãƒ™ã‚¹ãƒˆæ›´æ–°\n                currentBestFive = e.bestFive;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else if (comparison === 0) {\n                // å¼•ãåˆ†ã‘ â†’ Showï¼ˆãƒãƒƒãƒˆåˆ†å‰²ã®æ¨©åˆ©ï¼‰\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else {\n                // è² ã‘ã¦ã„ã‚‹ â†’ Muck\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: null,\n                    handRank: 'Mucked',\n                    isMucked: true\n                };\n            }\n        });\n    }\n\n    /**\n     * Hi-Loè©•ä¾¡ï¼ˆPLO8, 7CS8ç­‰ï¼‰\n     * ãƒãƒƒãƒˆã‚’ãƒã‚¤ã¨ãƒ­ãƒ¼ã§åŠåˆ†ãšã¤åˆ†ã‘ã‚‹\n     * æ³¨: Hi-Loã§ã¯ã€Highã¾ãŸã¯Lowã®ã„ãšã‚Œã‹ã§å‹ã¦ã‚‹å ´åˆã«Showã€‚ä¸¡æ–¹ã§è² ã‘ã‚‹å ´åˆã®ã¿Muckã€‚\n     */\n    private executeHiLoShowdown(room: Room, players: Player[], board: string[]): ShowdownResult {\n        const variant = room.gameState.gameVariant;\n        const variantConfig = getVariantConfig(variant);\n        const useOmahaSelection = variantConfig.holeCardsForSelection !== undefined;\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        // ãƒã‚¤ãƒãƒ³ãƒ‰è©•ä¾¡ï¼ˆã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³é †åºã§è©•ä¾¡ï¼‰\n        const highEvaluations = orderedPlayers.map(player => {\n            const holeCards = parseCards(player.hand!);\n            const boardCards = parseCards(board);\n\n            // Omahaç³»: æ‰‹æœ­ã‹ã‚‰å¿…ãšNæšä½¿ç”¨ + ãƒœãƒ¼ãƒ‰3æšã®çµ„ã¿åˆã‚ã›\n            // Studç³»: å…¨ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€å¼·ã®5æš\n            const bestFive = useOmahaSelection\n                ? getBestPLOFiveCards(holeCards, boardCards)\n                : getBestFiveCards([...holeCards, ...boardCards]);\n\n            const handResult = evaluateHand(bestFive);\n            return { player, bestFive, handResult, handRank: handResult.name };\n        });\n\n        // ãƒ­ãƒ¼ãƒãƒ³ãƒ‰è©•ä¾¡\n        const lowEvaluations = orderedPlayers.map(player => {\n            const holeCards = parseCards(player.hand!);\n            const boardCards = parseCards(board);\n\n            // Omahaç³»: æ‰‹æœ­ã‹ã‚‰å¿…ãšNæšä½¿ç”¨ + ãƒœãƒ¼ãƒ‰3æšã®çµ„ã¿åˆã‚ã›\n            // Studç³»: å…¨ã‚«ãƒ¼ãƒ‰ã‹ã‚‰æœ€å¼·ã®5æš\n            const bestLowFive = useOmahaSelection\n                ? getBestPLOLowFiveCards(holeCards, boardCards)\n                : getBestLowFiveCards([...holeCards, ...boardCards]);\n\n            const lowResult = bestLowFive ? evaluateLowHand8OrBetter(bestLowFive) : { valid: false, cards: [], name: 'No Low' };\n            return { player, bestLowFive, lowResult, handRank: lowResult.name };\n        }).filter(e => e.lowResult.valid);\n\n        const winnersMap = new Map<string, { player: Player; amount: number; highRank?: string; lowRank?: string }>();\n\n        const addWinnings = (player: Player, amount: number, side: 'high' | 'low', handRank: string) => {\n            if (amount <= 0) return;\n            const existing = winnersMap.get(player.socketId);\n            if (existing) {\n                existing.amount += amount;\n                if (side === 'high') existing.highRank = handRank;\n                if (side === 'low') existing.lowRank = handRank;\n            } else {\n                winnersMap.set(player.socketId, {\n                    player,\n                    amount,\n                    highRank: side === 'high' ? handRank : undefined,\n                    lowRank: side === 'low' ? handRank : undefined\n                });\n            }\n        };\n\n        const allEligibleIds = highEvaluations.map(e => e.player.socketId);\n        const potSlices = [\n            { amount: room.gameState.pot.main, eligiblePlayers: allEligibleIds },\n            ...room.gameState.pot.side.map(p => ({ amount: p.amount, eligiblePlayers: p.eligiblePlayers }))\n        ];\n\n        for (const pot of potSlices) {\n            if (pot.amount <= 0) continue;\n\n            const eligibleHigh = highEvaluations.filter(e =>\n                pot.eligiblePlayers.includes(e.player.socketId)\n            );\n            if (eligibleHigh.length === 0) continue;\n\n            let bestHighEval = eligibleHigh[0];\n            for (const e of eligibleHigh) {\n                if (compareHands(e.bestFive, bestHighEval.bestFive) > 0) {\n                    bestHighEval = e;\n                }\n            }\n            const highWinners = eligibleHigh.filter(e =>\n                compareHands(e.bestFive, bestHighEval.bestFive) === 0\n            );\n\n            const eligibleLow = lowEvaluations.filter(e =>\n                pot.eligiblePlayers.includes(e.player.socketId)\n            );\n\n            const hasLowWinner = eligibleLow.length > 0;\n            const highPot = hasLowWinner ? Math.floor(pot.amount / 2) : pot.amount;\n            const lowPot = hasLowWinner ? pot.amount - highPot : 0;\n\n            const highShare = Math.floor(highPot / highWinners.length);\n            const highRemainder = highPot % highWinners.length;\n            highWinners.forEach((w, i) => {\n                const amount = highShare + (i < highRemainder ? 1 : 0);\n                w.player.stack += amount;\n                addWinnings(w.player, amount, 'high', w.handRank);\n            });\n\n            if (hasLowWinner) {\n                let bestLowEval = eligibleLow[0];\n                for (const e of eligibleLow) {\n                    if (compareLowHands(e.lowResult, bestLowEval.lowResult) > 0) {\n                        bestLowEval = e;\n                    }\n                }\n                const lowWinners = eligibleLow.filter(e =>\n                    compareLowHands(e.lowResult, bestLowEval.lowResult) === 0\n                );\n\n                const lowShare = Math.floor(lowPot / lowWinners.length);\n                const lowRemainder = lowPot % lowWinners.length;\n                lowWinners.forEach((w, i) => {\n                    const amount = lowShare + (i < lowRemainder ? 1 : 0);\n                    w.player.stack += amount;\n                    addWinnings(w.player, amount, 'low', w.handRank);\n                });\n            }\n        }\n\n        room.gameState.pot = { main: 0, side: [] };\n\n        const winners: ShowdownResult['winners'] = Array.from(winnersMap.values()).map(w => {\n            const rankParts: string[] = [];\n            if (w.highRank) rankParts.push(`High: ${w.highRank}`);\n            if (w.lowRank) rankParts.push(`Low: ${w.lowRank}`);\n            return {\n                playerId: w.player.socketId,\n                playerName: w.player.name,\n                hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: rankParts.join(' / '),\n                amount: w.amount\n            };\n        });\n\n        // å‹è€…ã®IDã‚»ãƒƒãƒˆ\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        const allHands = highEvaluations.map(e => {\n            const isWinner = winnerIds.has(e.player.socketId);\n            const lowEval = lowEvaluations.find(le => le.player.socketId === e.player.socketId);\n            const rankStr = isWinner || isAllInShowdown\n                ? (lowEval ? `High: ${e.handRank} / Low: ${lowEval.handRank}` : `High: ${e.handRank}`)\n                : 'Mucked';\n            return {\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: (isWinner || isAllInShowdown) ? [...e.player.hand!] : null,  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: rankStr,\n                isMucked: !(isWinner || isAllInShowdown)\n            };\n        });\n\n        console.log(`ğŸ† Hi-Lo Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * Razzè©•ä¾¡ï¼ˆæœ€ã‚‚ä½ã„ãƒãƒ³ãƒ‰ãŒå‹ã¡ï¼‰\n     */\n    private executeRazzShowdown(room: Room, players: Player[], board: string[]): ShowdownResult {\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        const evaluations = orderedPlayers.map(player => {\n            const allCards = parseCards([...player.hand!, ...board]);\n            const bestFive = getBestRazzFiveCards(allCards);\n            const handResult = evaluateRazzHand(bestFive);\n            return { player, bestFive, handResult, handRank: handResult.name };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œ: handResultã‚’ä½¿ã£ãŸæ¯”è¼ƒ\n        const winners = this.distributeWithHandResultComparison(\n            room,\n            evaluations,\n            (a, b) => compareLowHands(a.handResult, b.handResult)\n        );\n\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n        if (isAllInShowdown) {\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n        } else {\n            allHands = this.determineShowMuckWithHandResult(\n                evaluations,\n                winnerIds,\n                (a, b) => compareLowHands(a.handResult, b.handResult)\n            );\n        }\n\n        console.log(`ğŸ† Razz Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * Badugiè©•ä¾¡\n     */\n    private executeBadugiShowdown(room: Room, players: Player[]): ShowdownResult {\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        const evaluations = orderedPlayers.map(player => {\n            const cards = parseCards(player.hand!);\n            const handResult = evaluateBadugiHand(cards);\n            return { player, handResult, handRank: handResult.name };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œ\n        const winners = this.distributeWithHandResultComparison(\n            room,\n            evaluations,\n            (a, b) => compareBadugiHands(a.handResult, b.handResult)\n        );\n\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n        if (isAllInShowdown) {\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n        } else {\n            allHands = this.determineShowMuckWithHandResult(\n                evaluations,\n                winnerIds,\n                (a, b) => compareBadugiHands(a.handResult, b.handResult)\n            );\n        }\n\n        console.log(`ğŸ† Badugi Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * 2-7 Lowballè©•ä¾¡\n     */\n    private executeDeuce7Showdown(room: Room, players: Player[]): ShowdownResult {\n        const isAllInShowdown = this.hasAllInPlayer(room);\n        const orderedPlayers = this.getShowdownOrder(room, players);\n\n        const evaluations = orderedPlayers.map(player => {\n            const cards = parseCards(player.hand!);\n            const handResult = evaluateDeuceSeven(cards);\n            return { player, handResult, handRank: handResult.name };\n        });\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œ\n        const winners = this.distributeWithHandResultComparison(\n            room,\n            evaluations,\n            (a, b) => compareDeuceSeven(a.handResult, b.handResult)\n        );\n\n        const winnerIds = new Set(winners.map(w => w.playerId));\n\n        // æ‰‹æœ­ã®è¡¨ç¤º/ãƒãƒƒã‚¯åˆ¤å®š\n        let allHands: ShowdownResult['allHands'];\n        if (isAllInShowdown) {\n            allHands = evaluations.map(e => ({\n                playerId: e.player.socketId,\n                playerName: e.player.name,\n                hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: e.handRank,\n                isMucked: false\n            }));\n        } else {\n            allHands = this.determineShowMuckWithHandResult(\n                evaluations,\n                winnerIds,\n                (a, b) => compareDeuceSeven(a.handResult, b.handResult)\n            );\n        }\n\n        console.log(`ğŸ† 2-7 Showdown: ${winners.map(w => `${w.playerName} wins ${w.amount} (${w.handRank})`).join(', ')}`);\n\n        return { winners, allHands };\n    }\n\n    /**\n     * handResultãƒ™ãƒ¼ã‚¹ã®Show/Muckåˆ¤å®šï¼ˆRazz, Badugi, 2-7ç”¨ï¼‰\n     */\n    private determineShowMuckWithHandResult<T extends { player: Player; handResult: any; handRank: string }>(\n        evaluations: T[],\n        winnerIds: Set<string>,\n        compareFunc: (a: T, b: T) => number\n    ): ShowdownResult['allHands'] {\n        let currentBest: T | null = null;\n\n        return evaluations.map((e, index) => {\n            // 1ç•ªæ‰‹ã¯å¿…ãšShow\n            if (index === 0) {\n                currentBest = e;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            }\n\n            // 2ç•ªæ‰‹ä»¥é™: ç¾åœ¨ã®ãƒ™ã‚¹ãƒˆã¨æ¯”è¼ƒ\n            const comparison = compareFunc(e, currentBest!);\n\n            if (comparison > 0) {\n                // å‹ã£ã¦ã„ã‚‹ â†’ Show & ãƒ™ã‚¹ãƒˆæ›´æ–°\n                currentBest = e;\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else if (comparison === 0) {\n                // å¼•ãåˆ†ã‘ â†’ Show\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: [...e.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                    handRank: e.handRank,\n                    isMucked: false\n                };\n            } else {\n                // è² ã‘ã¦ã„ã‚‹ â†’ Muck\n                return {\n                    playerId: e.player.socketId,\n                    playerName: e.player.name,\n                    hand: null,\n                    handRank: 'Mucked',\n                    isMucked: true\n                };\n            }\n        });\n    }\n\n    /**\n     * æ±ç”¨çš„ãªã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œåˆ†é…ï¼ˆhandResultã‚’ä½¿ã†æ¯”è¼ƒç”¨ï¼‰\n     */\n    private distributeWithHandResultComparison<T extends { player: Player; handRank: string }>(\n        room: Room,\n        allEvaluations: T[],\n        compareFunc: (a: T, b: T) => number\n    ): ShowdownResult['winners'] {\n        const winnersMap = new Map<string, { player: Player; handRank: string; amount: number }>();\n\n        // ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆã®åˆ†é…\n        if (room.gameState.pot.main > 0 && allEvaluations.length > 0) {\n            let bestEval = allEvaluations[0];\n            for (const e of allEvaluations) {\n                if (compareFunc(e, bestEval) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            const mainWinners = allEvaluations.filter(e => compareFunc(e, bestEval) === 0);\n            const share = Math.floor(room.gameState.pot.main / mainWinners.length);\n            const remainder = room.gameState.pot.main % mainWinners.length;\n\n            mainWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n                winnersMap.set(w.player.socketId, {\n                    player: w.player,\n                    handRank: w.handRank,\n                    amount\n                });\n            });\n        }\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã®åˆ†é…\n        for (const sidePot of room.gameState.pot.side) {\n            if (sidePot.amount <= 0) continue;\n\n            const eligibleEvaluations = allEvaluations.filter(e =>\n                sidePot.eligiblePlayers.includes(e.player.socketId)\n            );\n            if (eligibleEvaluations.length === 0) continue;\n\n            let bestEval = eligibleEvaluations[0];\n            for (const e of eligibleEvaluations) {\n                if (compareFunc(e, bestEval) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            const sideWinners = eligibleEvaluations.filter(e => compareFunc(e, bestEval) === 0);\n            const share = Math.floor(sidePot.amount / sideWinners.length);\n            const remainder = sidePot.amount % sideWinners.length;\n\n            sideWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n\n                const existing = winnersMap.get(w.player.socketId);\n                if (existing) {\n                    existing.amount += amount;\n                } else {\n                    winnersMap.set(w.player.socketId, {\n                        player: w.player,\n                        handRank: w.handRank,\n                        amount\n                    });\n                }\n            });\n        }\n\n        room.gameState.pot = { main: 0, side: [] };\n\n        return Array.from(winnersMap.values()).map(w => ({\n            playerId: w.player.socketId,\n            playerName: w.player.name,\n            hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n            handRank: w.handRank,\n            amount: w.amount\n        }));\n    }\n\n    /**\n     * ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆå¯¾å¿œã®ãƒãƒƒãƒˆåˆ†é…\n     * å„ãƒãƒƒãƒˆã”ã¨ã«å‚åŠ è³‡æ ¼ã®ã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­ã‹ã‚‰å‹è€…ã‚’æ±ºå®š\n     */\n    private distributeToWinnersWithSidePots(\n        room: Room,\n        allEvaluations: { player: Player; bestFive: Card[]; handRank: string }[],\n        compareFunc: (a: Card[], b: Card[]) => number\n    ): ShowdownResult['winners'] {\n        const winnersMap = new Map<string, { player: Player; handRank: string; amount: number }>();\n\n        // å…¨å‚åŠ è€…ã®ã‚½ã‚±ãƒƒãƒˆIDï¼ˆãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆè³‡æ ¼è€…ï¼‰\n        const allPlayerIds = allEvaluations.map(e => e.player.socketId);\n\n        // ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒˆã®åˆ†é…\n        if (room.gameState.pot.main > 0) {\n            // å…¨å“¡ã®ä¸­ã‹ã‚‰æœ€å¼·ã®ãƒãƒ³ãƒ‰ã‚’è¦‹ã¤ã‘ã‚‹\n            let bestEval = allEvaluations[0];\n            for (const e of allEvaluations) {\n                if (compareFunc(e.bestFive, bestEval.bestFive) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            // åŒç€å‹è€…ã‚’è¦‹ã¤ã‘ã‚‹\n            const mainWinners = allEvaluations.filter(e =>\n                compareFunc(e.bestFive, bestEval.bestFive) === 0\n            );\n\n            const share = Math.floor(room.gameState.pot.main / mainWinners.length);\n            const remainder = room.gameState.pot.main % mainWinners.length;\n\n            mainWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n\n                winnersMap.set(w.player.socketId, {\n                    player: w.player,\n                    handRank: w.handRank,\n                    amount\n                });\n            });\n        }\n\n        // ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã®åˆ†é…\n        for (const sidePot of room.gameState.pot.side) {\n            if (sidePot.amount <= 0) continue;\n\n            // ã“ã®ã‚µã‚¤ãƒ‰ãƒãƒƒãƒˆã«å‚åŠ è³‡æ ¼ã®ã‚ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è©•ä¾¡ã®ã¿\n            const eligibleEvaluations = allEvaluations.filter(e =>\n                sidePot.eligiblePlayers.includes(e.player.socketId)\n            );\n\n            if (eligibleEvaluations.length === 0) continue;\n\n            // å‚åŠ è³‡æ ¼è€…ã®ä¸­ã‹ã‚‰æœ€å¼·ã®ãƒãƒ³ãƒ‰ã‚’è¦‹ã¤ã‘ã‚‹\n            let bestEval = eligibleEvaluations[0];\n            for (const e of eligibleEvaluations) {\n                if (compareFunc(e.bestFive, bestEval.bestFive) > 0) {\n                    bestEval = e;\n                }\n            }\n\n            // åŒç€å‹è€…ã‚’è¦‹ã¤ã‘ã‚‹\n            const sideWinners = eligibleEvaluations.filter(e =>\n                compareFunc(e.bestFive, bestEval.bestFive) === 0\n            );\n\n            const share = Math.floor(sidePot.amount / sideWinners.length);\n            const remainder = sidePot.amount % sideWinners.length;\n\n            sideWinners.forEach((w, i) => {\n                const amount = share + (i < remainder ? 1 : 0);\n                w.player.stack += amount;\n\n                const existing = winnersMap.get(w.player.socketId);\n                if (existing) {\n                    existing.amount += amount;\n                } else {\n                    winnersMap.set(w.player.socketId, {\n                        player: w.player,\n                        handRank: w.handRank,\n                        amount\n                    });\n                }\n            });\n        }\n\n        room.gameState.pot = { main: 0, side: [] };\n\n        return Array.from(winnersMap.values()).map(w => ({\n            playerId: w.player.socketId,\n            playerName: w.player.name,\n            hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n            handRank: w.handRank,\n            amount: w.amount\n        }));\n    }\n\n    /**\n     * å‹è€…ã¸ã®ãƒãƒƒãƒˆåˆ†é…å…±é€šå‡¦ç†ï¼ˆå¾Œæ–¹äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰\n     */\n    private distributeToWinners(room: Room, winningPlayers: any[]): ShowdownResult['winners'] {\n        const totalPot = room.gameState.pot.main +\n            room.gameState.pot.side.reduce((sum, s) => sum + s.amount, 0);\n\n        const share = Math.floor(totalPot / winningPlayers.length);\n        const remainder = totalPot % winningPlayers.length;\n\n        const winners = winningPlayers.map((w, i) => {\n            const amount = share + (i < remainder ? 1 : 0);\n            w.player.stack += amount;\n            return {\n                playerId: w.player.socketId,\n                playerName: w.player.name,\n                hand: [...w.player.hand!],  // æ·±ã„ã‚³ãƒ”ãƒ¼\n                handRank: w.handRank,\n                amount\n            };\n        });\n\n        room.gameState.pot = { main: 0, side: [] };\n        return winners;\n    }\n\n    /**\n     * 1äººã‚’é™¤ã„ã¦å…¨å“¡ãƒ•ã‚©ãƒ¼ãƒ«ãƒ‰ã—ãŸå ´åˆã®å‡¦ç†\n     * ä¸æˆ¦å‹ã®ãŸã‚ã€å‹è€…ã®ãƒãƒ³ãƒ‰ã¯è¡¨ç¤ºã—ãªã„ï¼ˆMuckæ‰±ã„ï¼‰\n     */\n    awardToLastPlayer(room: Room): ShowdownResult {\n        const lastPlayer = room.players.find(p =>\n            p !== null &&\n            (p.status === 'ACTIVE' || p.status === 'ALL_IN')\n        ) as Player | undefined;\n\n        if (!lastPlayer) {\n            return { winners: [], allHands: [] };\n        }\n\n        const totalPot = room.gameState.pot.main +\n            room.gameState.pot.side.reduce((sum, s) => sum + s.amount, 0);\n\n        lastPlayer.stack += totalPot;\n        room.gameState.pot = { main: 0, side: [] };\n\n        console.log(`ğŸ† ${lastPlayer.name} wins ${totalPot} (others folded)`);\n\n        // ä¸æˆ¦å‹: å‹è€…ã®ãƒãƒ³ãƒ‰ã¯è¡¨ç¤ºã—ãªã„ï¼ˆhand: nullï¼‰\n        // ãƒãƒ¼ã‚«ãƒ¼ãƒ«ãƒ¼ãƒ«: ã‚·ãƒ§ãƒ¼ãƒ€ã‚¦ãƒ³ã«é€²ã‚“ã§ã„ãªã„ãŸã‚ã€ãƒãƒ³ãƒ‰ã‚’è¦‹ã›ã‚‹ç¾©å‹™ã¯ãªã„\n        return {\n            winners: [{\n                playerId: lastPlayer.socketId,\n                playerName: lastPlayer.name,\n                hand: [],  // ç©ºé…åˆ— = ãƒãƒ³ãƒ‰éè¡¨ç¤º\n                handRank: 'Uncontested',\n                amount: totalPot\n            }],\n            allHands: []\n        };\n    }\n}\n","usedDeprecatedRules":[]}]
